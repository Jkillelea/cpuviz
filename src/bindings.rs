/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                val |= 1 << i;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            self.set_bit(i + bit_offset, val_bit_is_set);
        }
    }
}
pub const _SYS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201505;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 23;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const __clock_t_defined: ::std::os::raw::c_uint = 1;
pub const __time_t_defined: ::std::os::raw::c_uint = 1;
pub const __clockid_t_defined: ::std::os::raw::c_uint = 1;
pub const __timer_t_defined: ::std::os::raw::c_uint = 1;
pub const __BIT_TYPES_DEFINED__: ::std::os::raw::c_uint = 1;
pub const _ENDIAN_H: ::std::os::raw::c_uint = 1;
pub const __LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __FLOAT_WORD_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const _BITS_BYTESWAP_H: ::std::os::raw::c_uint = 1;
pub const _SYS_SELECT_H: ::std::os::raw::c_uint = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const _SIGSET_H_types: ::std::os::raw::c_uint = 1;
pub const __timespec_defined: ::std::os::raw::c_uint = 1;
pub const _STRUCT_TIMEVAL: ::std::os::raw::c_uint = 1;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _SYS_SYSMACROS_H: ::std::os::raw::c_uint = 1;
pub const _BITS_PTHREADTYPES_H: ::std::os::raw::c_uint = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: ::std::os::raw::c_uint = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_COND_T: ::std::os::raw::c_uint = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: ::std::os::raw::c_uint = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: ::std::os::raw::c_uint = 4;
pub const __have_pthread_attr_t: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: ::std::os::raw::c_uint = 1;
pub const G_GNUC_FUNCTION: &'static [u8; 1usize] = b"\0";
pub const G_GNUC_PRETTY_FUNCTION: &'static [u8; 1usize] = b"\0";
pub const G_ANALYZER_ANALYZING: ::std::os::raw::c_uint = 0;
pub const FALSE: ::std::os::raw::c_uint = 0;
pub const _LIBC_LIMITS_H_: ::std::os::raw::c_uint = 1;
pub const MB_LEN_MAX: ::std::os::raw::c_uint = 16;
pub const _BITS_POSIX1_LIM_H: ::std::os::raw::c_uint = 1;
pub const _POSIX_AIO_LISTIO_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX_AIO_MAX: ::std::os::raw::c_uint = 1;
pub const _POSIX_ARG_MAX: ::std::os::raw::c_uint = 4096;
pub const _POSIX_CHILD_MAX: ::std::os::raw::c_uint = 25;
pub const _POSIX_DELAYTIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_HOST_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_LINK_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_LOGIN_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX_MAX_CANON: ::std::os::raw::c_uint = 255;
pub const _POSIX_MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const _POSIX_MQ_OPEN_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_MQ_PRIO_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const _POSIX_NGROUPS_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_OPEN_MAX: ::std::os::raw::c_uint = 20;
pub const _POSIX_PATH_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_PIPE_BUF: ::std::os::raw::c_uint = 512;
pub const _POSIX_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_RTSIG_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_SEM_NSEMS_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_SEM_VALUE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_SIGQUEUE_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_SSIZE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_STREAM_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_SYMLINK_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_SYMLOOP_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_TTY_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX_TZNAME_MAX: ::std::os::raw::c_uint = 6;
pub const _POSIX_CLOCKRES_MIN: ::std::os::raw::c_uint = 20000000;
pub const NR_OPEN: ::std::os::raw::c_uint = 1024;
pub const NGROUPS_MAX: ::std::os::raw::c_uint = 65536;
pub const ARG_MAX: ::std::os::raw::c_uint = 131072;
pub const LINK_MAX: ::std::os::raw::c_uint = 127;
pub const MAX_CANON: ::std::os::raw::c_uint = 255;
pub const MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const NAME_MAX: ::std::os::raw::c_uint = 255;
pub const PATH_MAX: ::std::os::raw::c_uint = 4096;
pub const PIPE_BUF: ::std::os::raw::c_uint = 4096;
pub const XATTR_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const XATTR_SIZE_MAX: ::std::os::raw::c_uint = 65536;
pub const XATTR_LIST_MAX: ::std::os::raw::c_uint = 65536;
pub const RTSIG_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_THREAD_KEYS_MAX: ::std::os::raw::c_uint = 128;
pub const PTHREAD_KEYS_MAX: ::std::os::raw::c_uint = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const _POSIX_THREAD_THREADS_MAX: ::std::os::raw::c_uint = 64;
pub const AIO_PRIO_DELTA_MAX: ::std::os::raw::c_uint = 20;
pub const PTHREAD_STACK_MIN: ::std::os::raw::c_uint = 16384;
pub const DELAYTIMER_MAX: ::std::os::raw::c_uint = 2147483647;
pub const TTY_NAME_MAX: ::std::os::raw::c_uint = 32;
pub const LOGIN_NAME_MAX: ::std::os::raw::c_uint = 256;
pub const HOST_NAME_MAX: ::std::os::raw::c_uint = 64;
pub const MQ_PRIO_MAX: ::std::os::raw::c_uint = 32768;
pub const SEM_VALUE_MAX: ::std::os::raw::c_uint = 2147483647;
pub const _BITS_POSIX2_LIM_H: ::std::os::raw::c_uint = 1;
pub const _POSIX2_BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX2_EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX2_LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 255;
pub const EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 2048;
pub const RE_DUP_MAX: ::std::os::raw::c_uint = 32767;
pub const G_GINT16_MODIFIER: &'static [u8; 2usize] = b"h\0";
pub const G_GINT16_FORMAT: &'static [u8; 3usize] = b"hi\0";
pub const G_GUINT16_FORMAT: &'static [u8; 3usize] = b"hu\0";
pub const G_GINT32_MODIFIER: &'static [u8; 1usize] = b"\0";
pub const G_GINT32_FORMAT: &'static [u8; 2usize] = b"i\0";
pub const G_GUINT32_FORMAT: &'static [u8; 2usize] = b"u\0";
pub const G_HAVE_GINT64: ::std::os::raw::c_uint = 1;
pub const G_GINT64_MODIFIER: &'static [u8; 2usize] = b"l\0";
pub const G_GINT64_FORMAT: &'static [u8; 3usize] = b"li\0";
pub const G_GUINT64_FORMAT: &'static [u8; 3usize] = b"lu\0";
pub const GLIB_SIZEOF_VOID_P: ::std::os::raw::c_uint = 8;
pub const GLIB_SIZEOF_LONG: ::std::os::raw::c_uint = 8;
pub const GLIB_SIZEOF_SIZE_T: ::std::os::raw::c_uint = 8;
pub const GLIB_SIZEOF_SSIZE_T: ::std::os::raw::c_uint = 8;
pub const G_GSIZE_MODIFIER: &'static [u8; 2usize] = b"l\0";
pub const G_GSSIZE_MODIFIER: &'static [u8; 2usize] = b"l\0";
pub const G_GSIZE_FORMAT: &'static [u8; 3usize] = b"lu\0";
pub const G_GSSIZE_FORMAT: &'static [u8; 3usize] = b"li\0";
pub const G_GOFFSET_MODIFIER: &'static [u8; 2usize] = b"l\0";
pub const G_GOFFSET_FORMAT: &'static [u8; 3usize] = b"li\0";
pub const G_POLLFD_FORMAT: &'static [u8; 3usize] = b"%d\0";
pub const G_GINTPTR_MODIFIER: &'static [u8; 2usize] = b"l\0";
pub const G_GINTPTR_FORMAT: &'static [u8; 3usize] = b"li\0";
pub const G_GUINTPTR_FORMAT: &'static [u8; 3usize] = b"lu\0";
pub const GLIB_MAJOR_VERSION: ::std::os::raw::c_uint = 2;
pub const GLIB_MINOR_VERSION: ::std::os::raw::c_uint = 48;
pub const GLIB_MICRO_VERSION: ::std::os::raw::c_uint = 2;
pub const G_VA_COPY_AS_ARRAY: ::std::os::raw::c_uint = 1;
pub const G_HAVE_ISO_VARARGS: ::std::os::raw::c_uint = 1;
pub const G_HAVE_GNUC_VARARGS: ::std::os::raw::c_uint = 1;
pub const G_HAVE_GROWING_STACK: ::std::os::raw::c_uint = 0;
pub const G_HAVE_GNUC_VISIBILITY: ::std::os::raw::c_uint = 1;
pub const G_MODULE_SUFFIX: &'static [u8; 3usize] = b"so\0";
pub const GLIB_SYSDEF_AF_UNIX: ::std::os::raw::c_uint = 1;
pub const GLIB_SYSDEF_AF_INET: ::std::os::raw::c_uint = 2;
pub const GLIB_SYSDEF_AF_INET6: ::std::os::raw::c_uint = 10;
pub const GLIB_SYSDEF_MSG_OOB: ::std::os::raw::c_uint = 1;
pub const GLIB_SYSDEF_MSG_PEEK: ::std::os::raw::c_uint = 2;
pub const GLIB_SYSDEF_MSG_DONTROUTE: ::std::os::raw::c_uint = 4;
pub const _TIME_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TIME_H: ::std::os::raw::c_uint = 1;
pub const CLOCK_REALTIME: ::std::os::raw::c_uint = 0;
pub const CLOCK_MONOTONIC: ::std::os::raw::c_uint = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: ::std::os::raw::c_uint = 2;
pub const CLOCK_THREAD_CPUTIME_ID: ::std::os::raw::c_uint = 3;
pub const CLOCK_MONOTONIC_RAW: ::std::os::raw::c_uint = 4;
pub const CLOCK_REALTIME_COARSE: ::std::os::raw::c_uint = 5;
pub const CLOCK_MONOTONIC_COARSE: ::std::os::raw::c_uint = 6;
pub const CLOCK_BOOTTIME: ::std::os::raw::c_uint = 7;
pub const CLOCK_REALTIME_ALARM: ::std::os::raw::c_uint = 8;
pub const CLOCK_BOOTTIME_ALARM: ::std::os::raw::c_uint = 9;
pub const CLOCK_TAI: ::std::os::raw::c_uint = 11;
pub const TIMER_ABSTIME: ::std::os::raw::c_uint = 1;
pub const TIME_UTC: ::std::os::raw::c_uint = 1;
pub const _XLOCALE_H: ::std::os::raw::c_uint = 1;
pub const G_E: f64 = 2.718281828459045;
pub const G_LN2: f64 = 0.6931471805599453;
pub const G_LN10: f64 = 2.302585092994046;
pub const G_PI: f64 = 3.141592653589793;
pub const G_PI_2: f64 = 1.5707963267948966;
pub const G_PI_4: f64 = 0.7853981633974483;
pub const G_SQRT2: f64 = 1.4142135623730951;
pub const G_LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const G_BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const G_PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const G_IEEE754_FLOAT_BIAS: ::std::os::raw::c_uint = 127;
pub const G_IEEE754_DOUBLE_BIAS: ::std::os::raw::c_uint = 1023;
pub const G_LOG_2_BASE_10: f64 = 0.3010299956639812;
pub const __GNUC_VA_LIST: ::std::os::raw::c_uint = 1;
pub const _SIGSET_H_fns: ::std::os::raw::c_uint = 1;
pub const SIGHUP: ::std::os::raw::c_uint = 1;
pub const SIGINT: ::std::os::raw::c_uint = 2;
pub const SIGQUIT: ::std::os::raw::c_uint = 3;
pub const SIGILL: ::std::os::raw::c_uint = 4;
pub const SIGTRAP: ::std::os::raw::c_uint = 5;
pub const SIGABRT: ::std::os::raw::c_uint = 6;
pub const SIGIOT: ::std::os::raw::c_uint = 6;
pub const SIGBUS: ::std::os::raw::c_uint = 7;
pub const SIGFPE: ::std::os::raw::c_uint = 8;
pub const SIGKILL: ::std::os::raw::c_uint = 9;
pub const SIGUSR1: ::std::os::raw::c_uint = 10;
pub const SIGSEGV: ::std::os::raw::c_uint = 11;
pub const SIGUSR2: ::std::os::raw::c_uint = 12;
pub const SIGPIPE: ::std::os::raw::c_uint = 13;
pub const SIGALRM: ::std::os::raw::c_uint = 14;
pub const SIGTERM: ::std::os::raw::c_uint = 15;
pub const SIGSTKFLT: ::std::os::raw::c_uint = 16;
pub const SIGCHLD: ::std::os::raw::c_uint = 17;
pub const SIGCONT: ::std::os::raw::c_uint = 18;
pub const SIGSTOP: ::std::os::raw::c_uint = 19;
pub const SIGTSTP: ::std::os::raw::c_uint = 20;
pub const SIGTTIN: ::std::os::raw::c_uint = 21;
pub const SIGTTOU: ::std::os::raw::c_uint = 22;
pub const SIGURG: ::std::os::raw::c_uint = 23;
pub const SIGXCPU: ::std::os::raw::c_uint = 24;
pub const SIGXFSZ: ::std::os::raw::c_uint = 25;
pub const SIGVTALRM: ::std::os::raw::c_uint = 26;
pub const SIGPROF: ::std::os::raw::c_uint = 27;
pub const SIGWINCH: ::std::os::raw::c_uint = 28;
pub const SIGIO: ::std::os::raw::c_uint = 29;
pub const SIGPWR: ::std::os::raw::c_uint = 30;
pub const SIGSYS: ::std::os::raw::c_uint = 31;
pub const SIGUNUSED: ::std::os::raw::c_uint = 31;
pub const _NSIG: ::std::os::raw::c_uint = 65;
pub const __SIGRTMIN: ::std::os::raw::c_uint = 32;
pub const __SIGRTMAX: ::std::os::raw::c_uint = 64;
pub const __have_sigval_t: ::std::os::raw::c_uint = 1;
pub const __have_siginfo_t: ::std::os::raw::c_uint = 1;
pub const __SI_MAX_SIZE: ::std::os::raw::c_uint = 128;
pub const __have_sigevent_t: ::std::os::raw::c_uint = 1;
pub const __SIGEV_MAX_SIZE: ::std::os::raw::c_uint = 64;
pub const NSIG: ::std::os::raw::c_uint = 65;
pub const SA_NOCLDSTOP: ::std::os::raw::c_uint = 1;
pub const SA_NOCLDWAIT: ::std::os::raw::c_uint = 2;
pub const SA_SIGINFO: ::std::os::raw::c_uint = 4;
pub const SA_ONSTACK: ::std::os::raw::c_uint = 134217728;
pub const SA_RESTART: ::std::os::raw::c_uint = 268435456;
pub const SA_NODEFER: ::std::os::raw::c_uint = 1073741824;
pub const SA_RESETHAND: ::std::os::raw::c_uint = 2147483648;
pub const SA_INTERRUPT: ::std::os::raw::c_uint = 536870912;
pub const SA_NOMASK: ::std::os::raw::c_uint = 1073741824;
pub const SA_ONESHOT: ::std::os::raw::c_uint = 2147483648;
pub const SA_STACK: ::std::os::raw::c_uint = 134217728;
pub const SIG_BLOCK: ::std::os::raw::c_uint = 0;
pub const SIG_UNBLOCK: ::std::os::raw::c_uint = 1;
pub const SIG_SETMASK: ::std::os::raw::c_uint = 2;
pub const _BITS_SIGCONTEXT_H: ::std::os::raw::c_uint = 1;
pub const FP_XSTATE_MAGIC1: ::std::os::raw::c_uint = 1179670611;
pub const FP_XSTATE_MAGIC2: ::std::os::raw::c_uint = 1179670597;
pub const MINSIGSTKSZ: ::std::os::raw::c_uint = 2048;
pub const SIGSTKSZ: ::std::os::raw::c_uint = 8192;
pub const _SYS_UCONTEXT_H: ::std::os::raw::c_uint = 1;
pub const NGREG: ::std::os::raw::c_uint = 23;
pub const _BITS_SIGTHREAD_H: ::std::os::raw::c_uint = 1;
pub const G_DATALIST_FLAGS_MASK: ::std::os::raw::c_uint = 3;
pub const G_DATE_BAD_JULIAN: ::std::os::raw::c_uint = 0;
pub const G_DATE_BAD_DAY: ::std::os::raw::c_uint = 0;
pub const G_DATE_BAD_YEAR: ::std::os::raw::c_uint = 0;
pub const _DIRENT_H: ::std::os::raw::c_uint = 1;
pub const _DIRENT_MATCHES_DIRENT64: ::std::os::raw::c_uint = 1;
pub const MAXNAMLEN: ::std::os::raw::c_uint = 255;
pub const G_DIR_SEPARATOR: u8 = 47u8;
pub const G_DIR_SEPARATOR_S: &'static [u8; 2usize] = b"/\0";
pub const G_SEARCHPATH_SEPARATOR: u8 = 58u8;
pub const G_SEARCHPATH_SEPARATOR_S: &'static [u8; 2usize] = b":\0";
pub const G_MEM_ALIGN: ::std::os::raw::c_uint = 8;
pub const G_HOOK_FLAG_USER_SHIFT: ::std::os::raw::c_uint = 4;
pub const G_PRIORITY_HIGH: ::std::os::raw::c_int = -100;
pub const G_PRIORITY_DEFAULT: ::std::os::raw::c_uint = 0;
pub const G_PRIORITY_HIGH_IDLE: ::std::os::raw::c_uint = 100;
pub const G_PRIORITY_DEFAULT_IDLE: ::std::os::raw::c_uint = 200;
pub const G_PRIORITY_LOW: ::std::os::raw::c_uint = 300;
pub const G_SOURCE_REMOVE: ::std::os::raw::c_uint = 0;
pub const G_UNICHAR_MAX_DECOMPOSITION_LENGTH: ::std::os::raw::c_uint = 18;
pub const G_KEY_FILE_DESKTOP_GROUP: &'static [u8; 14usize] = b"Desktop Entry\0";
pub const G_KEY_FILE_DESKTOP_KEY_TYPE: &'static [u8; 5usize] = b"Type\0";
pub const G_KEY_FILE_DESKTOP_KEY_VERSION: &'static [u8; 8usize] = b"Version\0";
pub const G_KEY_FILE_DESKTOP_KEY_NAME: &'static [u8; 5usize] = b"Name\0";
pub const G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME: &'static [u8; 12usize] = b"GenericName\0";
pub const G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY: &'static [u8; 10usize] = b"NoDisplay\0";
pub const G_KEY_FILE_DESKTOP_KEY_COMMENT: &'static [u8; 8usize] = b"Comment\0";
pub const G_KEY_FILE_DESKTOP_KEY_ICON: &'static [u8; 5usize] = b"Icon\0";
pub const G_KEY_FILE_DESKTOP_KEY_HIDDEN: &'static [u8; 7usize] = b"Hidden\0";
pub const G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN: &'static [u8; 11usize] = b"OnlyShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN: &'static [u8; 10usize] = b"NotShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_TRY_EXEC: &'static [u8; 8usize] = b"TryExec\0";
pub const G_KEY_FILE_DESKTOP_KEY_EXEC: &'static [u8; 5usize] = b"Exec\0";
pub const G_KEY_FILE_DESKTOP_KEY_PATH: &'static [u8; 5usize] = b"Path\0";
pub const G_KEY_FILE_DESKTOP_KEY_TERMINAL: &'static [u8; 9usize] = b"Terminal\0";
pub const G_KEY_FILE_DESKTOP_KEY_MIME_TYPE: &'static [u8; 9usize] = b"MimeType\0";
pub const G_KEY_FILE_DESKTOP_KEY_CATEGORIES: &'static [u8; 11usize] = b"Categories\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY: &'static [u8; 14usize] = b"StartupNotify\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS: &'static [u8; 15usize] = b"StartupWMClass\0";
pub const G_KEY_FILE_DESKTOP_KEY_URL: &'static [u8; 4usize] = b"URL\0";
pub const G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE: &'static [u8; 16usize] = b"DBusActivatable\0";
pub const G_KEY_FILE_DESKTOP_KEY_ACTIONS: &'static [u8; 8usize] = b"Actions\0";
pub const G_KEY_FILE_DESKTOP_KEY_GETTEXT_DOMAIN: &'static [u8; 23usize] = b"X-GNOME-Gettext-Domain\0";
pub const G_KEY_FILE_DESKTOP_KEY_FULLNAME: &'static [u8; 17usize] = b"X-GNOME-FullName\0";
pub const G_KEY_FILE_DESKTOP_KEY_KEYWORDS: &'static [u8; 9usize] = b"Keywords\0";
pub const G_KEY_FILE_DESKTOP_TYPE_APPLICATION: &'static [u8; 12usize] = b"Application\0";
pub const G_KEY_FILE_DESKTOP_TYPE_LINK: &'static [u8; 5usize] = b"Link\0";
pub const G_KEY_FILE_DESKTOP_TYPE_DIRECTORY: &'static [u8; 10usize] = b"Directory\0";
pub const G_LOG_LEVEL_USER_SHIFT: ::std::os::raw::c_uint = 8;
pub const G_OPTION_REMAINING: &'static [u8; 1usize] = b"\0";
pub const G_CSET_A_2_Z: &'static [u8; 27usize] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\0";
pub const G_CSET_a_2_z: &'static [u8; 27usize] = b"abcdefghijklmnopqrstuvwxyz\0";
pub const G_CSET_DIGITS: &'static [u8; 11usize] = b"0123456789\0";
pub const G_CSET_LATINC: [u8; 31usize] = [
    192u8, 193u8, 194u8, 195u8, 196u8, 197u8, 198u8, 199u8, 200u8, 201u8, 202u8, 203u8, 204u8, 205u8, 206u8, 207u8, 208u8, 209u8, 210u8,
    211u8, 212u8, 213u8, 214u8, 216u8, 217u8, 218u8, 219u8, 220u8, 221u8, 222u8, 0u8,
];
pub const G_CSET_LATINS: [u8; 33usize] = [
    223u8, 224u8, 225u8, 226u8, 227u8, 228u8, 229u8, 230u8, 231u8, 232u8, 233u8, 234u8, 235u8, 236u8, 237u8, 238u8, 239u8, 240u8, 241u8,
    242u8, 243u8, 244u8, 245u8, 246u8, 248u8, 249u8, 250u8, 251u8, 252u8, 253u8, 254u8, 255u8, 0u8,
];
pub const G_STR_DELIMITERS: &'static [u8; 8usize] = b"_-|> <.\0";
pub const G_ASCII_DTOSTR_BUF_SIZE: ::std::os::raw::c_uint = 39;
pub const G_USEC_PER_SEC: ::std::os::raw::c_uint = 1000000;
pub const G_URI_RESERVED_CHARS_GENERIC_DELIMITERS: &'static [u8; 8usize] = b":/?#[]@\0";
pub const G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS: &'static [u8; 12usize] = b"!$&'()*+,;=\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT: &'static [u8; 14usize] = b"!$&'()*+,;=:@\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH: &'static [u8; 15usize] = b"!$&'()*+,;=:@/\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_USERINFO: &'static [u8; 13usize] = b"!$&'()*+,;=:\0";
pub const G_ALLOC_ONLY: ::std::os::raw::c_uint = 1;
pub const G_ALLOC_AND_FREE: ::std::os::raw::c_uint = 2;
pub const G_ALLOCATOR_LIST: ::std::os::raw::c_uint = 1;
pub const G_ALLOCATOR_SLIST: ::std::os::raw::c_uint = 2;
pub const G_ALLOCATOR_NODE: ::std::os::raw::c_uint = 3;
pub const _PTHREAD_H: ::std::os::raw::c_uint = 1;
pub const _SCHED_H: ::std::os::raw::c_uint = 1;
pub const SCHED_OTHER: ::std::os::raw::c_uint = 0;
pub const SCHED_FIFO: ::std::os::raw::c_uint = 1;
pub const SCHED_RR: ::std::os::raw::c_uint = 2;
pub const __defined_schedparam: ::std::os::raw::c_uint = 1;
pub const __CPU_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _BITS_SETJMP_H: ::std::os::raw::c_uint = 1;
pub const PTHREAD_ONCE_INIT: ::std::os::raw::c_uint = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: ::std::os::raw::c_int = -1;
pub const G_TYPE_FUNDAMENTAL_SHIFT: ::std::os::raw::c_uint = 2;
pub const G_TYPE_RESERVED_GLIB_FIRST: ::std::os::raw::c_uint = 22;
pub const G_TYPE_RESERVED_GLIB_LAST: ::std::os::raw::c_uint = 31;
pub const G_TYPE_RESERVED_BSE_FIRST: ::std::os::raw::c_uint = 32;
pub const G_TYPE_RESERVED_BSE_LAST: ::std::os::raw::c_uint = 48;
pub const G_TYPE_RESERVED_USER_FIRST: ::std::os::raw::c_uint = 49;
pub const G_VALUE_NOCOPY_CONTENTS: ::std::os::raw::c_uint = 134217728;
pub const G_PARAM_MASK: ::std::os::raw::c_uint = 255;
pub const G_PARAM_USER_SHIFT: ::std::os::raw::c_uint = 8;
pub const G_SIGNAL_FLAGS_MASK: ::std::os::raw::c_uint = 511;
pub const G_SIGNAL_MATCH_MASK: ::std::os::raw::c_uint = 63;
pub const LIBGTOP_MAJOR_VERSION: ::std::os::raw::c_uint = 2;
pub const LIBGTOP_MINOR_VERSION: ::std::os::raw::c_uint = 32;
pub const LIBGTOP_MICRO_VERSION: ::std::os::raw::c_uint = 0;
pub const _STDIO_H: ::std::os::raw::c_uint = 1;
pub const __FILE_defined: ::std::os::raw::c_uint = 1;
pub const ____FILE_defined: ::std::os::raw::c_uint = 1;
pub const _G_config_h: ::std::os::raw::c_uint = 1;
pub const ____mbstate_t_defined: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MMAP: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MREMAP: ::std::os::raw::c_uint = 1;
pub const _G_IO_IO_FILE_VERSION: ::std::os::raw::c_uint = 131073;
pub const _G_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const _IO_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const _IO_UNIFIED_JUMPTABLES: ::std::os::raw::c_uint = 1;
pub const EOF: ::std::os::raw::c_int = -1;
pub const _IOS_INPUT: ::std::os::raw::c_uint = 1;
pub const _IOS_OUTPUT: ::std::os::raw::c_uint = 2;
pub const _IOS_ATEND: ::std::os::raw::c_uint = 4;
pub const _IOS_APPEND: ::std::os::raw::c_uint = 8;
pub const _IOS_TRUNC: ::std::os::raw::c_uint = 16;
pub const _IOS_NOCREATE: ::std::os::raw::c_uint = 32;
pub const _IOS_NOREPLACE: ::std::os::raw::c_uint = 64;
pub const _IOS_BIN: ::std::os::raw::c_uint = 128;
pub const _IO_MAGIC: ::std::os::raw::c_uint = 4222418944;
pub const _OLD_STDIO_MAGIC: ::std::os::raw::c_uint = 4206624768;
pub const _IO_MAGIC_MASK: ::std::os::raw::c_uint = 4294901760;
pub const _IO_USER_BUF: ::std::os::raw::c_uint = 1;
pub const _IO_UNBUFFERED: ::std::os::raw::c_uint = 2;
pub const _IO_NO_READS: ::std::os::raw::c_uint = 4;
pub const _IO_NO_WRITES: ::std::os::raw::c_uint = 8;
pub const _IO_EOF_SEEN: ::std::os::raw::c_uint = 16;
pub const _IO_ERR_SEEN: ::std::os::raw::c_uint = 32;
pub const _IO_DELETE_DONT_CLOSE: ::std::os::raw::c_uint = 64;
pub const _IO_LINKED: ::std::os::raw::c_uint = 128;
pub const _IO_IN_BACKUP: ::std::os::raw::c_uint = 256;
pub const _IO_LINE_BUF: ::std::os::raw::c_uint = 512;
pub const _IO_TIED_PUT_GET: ::std::os::raw::c_uint = 1024;
pub const _IO_CURRENTLY_PUTTING: ::std::os::raw::c_uint = 2048;
pub const _IO_IS_APPENDING: ::std::os::raw::c_uint = 4096;
pub const _IO_IS_FILEBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_BAD_SEEN: ::std::os::raw::c_uint = 16384;
pub const _IO_USER_LOCK: ::std::os::raw::c_uint = 32768;
pub const _IO_FLAGS2_MMAP: ::std::os::raw::c_uint = 1;
pub const _IO_FLAGS2_NOTCANCEL: ::std::os::raw::c_uint = 2;
pub const _IO_FLAGS2_USER_WBUF: ::std::os::raw::c_uint = 8;
pub const _IO_SKIPWS: ::std::os::raw::c_uint = 1;
pub const _IO_LEFT: ::std::os::raw::c_uint = 2;
pub const _IO_RIGHT: ::std::os::raw::c_uint = 4;
pub const _IO_INTERNAL: ::std::os::raw::c_uint = 8;
pub const _IO_DEC: ::std::os::raw::c_uint = 16;
pub const _IO_OCT: ::std::os::raw::c_uint = 32;
pub const _IO_HEX: ::std::os::raw::c_uint = 64;
pub const _IO_SHOWBASE: ::std::os::raw::c_uint = 128;
pub const _IO_SHOWPOINT: ::std::os::raw::c_uint = 256;
pub const _IO_UPPERCASE: ::std::os::raw::c_uint = 512;
pub const _IO_SHOWPOS: ::std::os::raw::c_uint = 1024;
pub const _IO_SCIENTIFIC: ::std::os::raw::c_uint = 2048;
pub const _IO_FIXED: ::std::os::raw::c_uint = 4096;
pub const _IO_UNITBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_STDIO: ::std::os::raw::c_uint = 16384;
pub const _IO_DONT_CLOSE: ::std::os::raw::c_uint = 32768;
pub const _IO_BOOLALPHA: ::std::os::raw::c_uint = 65536;
pub const _IOFBF: ::std::os::raw::c_uint = 0;
pub const _IOLBF: ::std::os::raw::c_uint = 1;
pub const _IONBF: ::std::os::raw::c_uint = 2;
pub const BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const L_tmpnam: ::std::os::raw::c_uint = 20;
pub const TMP_MAX: ::std::os::raw::c_uint = 238328;
pub const FILENAME_MAX: ::std::os::raw::c_uint = 4096;
pub const L_ctermid: ::std::os::raw::c_uint = 9;
pub const FOPEN_MAX: ::std::os::raw::c_uint = 16;
pub const _STDLIB_H: ::std::os::raw::c_uint = 1;
pub const WNOHANG: ::std::os::raw::c_uint = 1;
pub const WUNTRACED: ::std::os::raw::c_uint = 2;
pub const WSTOPPED: ::std::os::raw::c_uint = 2;
pub const WEXITED: ::std::os::raw::c_uint = 4;
pub const WCONTINUED: ::std::os::raw::c_uint = 8;
pub const WNOWAIT: ::std::os::raw::c_uint = 16777216;
pub const __WNOTHREAD: ::std::os::raw::c_uint = 536870912;
pub const __WALL: ::std::os::raw::c_uint = 1073741824;
pub const __WCLONE: ::std::os::raw::c_uint = 2147483648;
pub const __ENUM_IDTYPE_T: ::std::os::raw::c_uint = 1;
pub const __W_CONTINUED: ::std::os::raw::c_uint = 65535;
pub const __WCOREFLAG: ::std::os::raw::c_uint = 128;
pub const __ldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const __lldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const RAND_MAX: ::std::os::raw::c_uint = 2147483647;
pub const EXIT_FAILURE: ::std::os::raw::c_uint = 1;
pub const EXIT_SUCCESS: ::std::os::raw::c_uint = 0;
pub const _ALLOCA_H: ::std::os::raw::c_uint = 1;
pub const _STRING_H: ::std::os::raw::c_uint = 1;
pub const _ERRNO_H: ::std::os::raw::c_uint = 1;
pub const EPERM: ::std::os::raw::c_uint = 1;
pub const ENOENT: ::std::os::raw::c_uint = 2;
pub const ESRCH: ::std::os::raw::c_uint = 3;
pub const EINTR: ::std::os::raw::c_uint = 4;
pub const EIO: ::std::os::raw::c_uint = 5;
pub const ENXIO: ::std::os::raw::c_uint = 6;
pub const E2BIG: ::std::os::raw::c_uint = 7;
pub const ENOEXEC: ::std::os::raw::c_uint = 8;
pub const EBADF: ::std::os::raw::c_uint = 9;
pub const ECHILD: ::std::os::raw::c_uint = 10;
pub const EAGAIN: ::std::os::raw::c_uint = 11;
pub const ENOMEM: ::std::os::raw::c_uint = 12;
pub const EACCES: ::std::os::raw::c_uint = 13;
pub const EFAULT: ::std::os::raw::c_uint = 14;
pub const ENOTBLK: ::std::os::raw::c_uint = 15;
pub const EBUSY: ::std::os::raw::c_uint = 16;
pub const EEXIST: ::std::os::raw::c_uint = 17;
pub const EXDEV: ::std::os::raw::c_uint = 18;
pub const ENODEV: ::std::os::raw::c_uint = 19;
pub const ENOTDIR: ::std::os::raw::c_uint = 20;
pub const EISDIR: ::std::os::raw::c_uint = 21;
pub const EINVAL: ::std::os::raw::c_uint = 22;
pub const ENFILE: ::std::os::raw::c_uint = 23;
pub const EMFILE: ::std::os::raw::c_uint = 24;
pub const ENOTTY: ::std::os::raw::c_uint = 25;
pub const ETXTBSY: ::std::os::raw::c_uint = 26;
pub const EFBIG: ::std::os::raw::c_uint = 27;
pub const ENOSPC: ::std::os::raw::c_uint = 28;
pub const ESPIPE: ::std::os::raw::c_uint = 29;
pub const EROFS: ::std::os::raw::c_uint = 30;
pub const EMLINK: ::std::os::raw::c_uint = 31;
pub const EPIPE: ::std::os::raw::c_uint = 32;
pub const EDOM: ::std::os::raw::c_uint = 33;
pub const ERANGE: ::std::os::raw::c_uint = 34;
pub const EDEADLK: ::std::os::raw::c_uint = 35;
pub const ENAMETOOLONG: ::std::os::raw::c_uint = 36;
pub const ENOLCK: ::std::os::raw::c_uint = 37;
pub const ENOSYS: ::std::os::raw::c_uint = 38;
pub const ENOTEMPTY: ::std::os::raw::c_uint = 39;
pub const ELOOP: ::std::os::raw::c_uint = 40;
pub const EWOULDBLOCK: ::std::os::raw::c_uint = 11;
pub const ENOMSG: ::std::os::raw::c_uint = 42;
pub const EIDRM: ::std::os::raw::c_uint = 43;
pub const ECHRNG: ::std::os::raw::c_uint = 44;
pub const EL2NSYNC: ::std::os::raw::c_uint = 45;
pub const EL3HLT: ::std::os::raw::c_uint = 46;
pub const EL3RST: ::std::os::raw::c_uint = 47;
pub const ELNRNG: ::std::os::raw::c_uint = 48;
pub const EUNATCH: ::std::os::raw::c_uint = 49;
pub const ENOCSI: ::std::os::raw::c_uint = 50;
pub const EL2HLT: ::std::os::raw::c_uint = 51;
pub const EBADE: ::std::os::raw::c_uint = 52;
pub const EBADR: ::std::os::raw::c_uint = 53;
pub const EXFULL: ::std::os::raw::c_uint = 54;
pub const ENOANO: ::std::os::raw::c_uint = 55;
pub const EBADRQC: ::std::os::raw::c_uint = 56;
pub const EBADSLT: ::std::os::raw::c_uint = 57;
pub const EDEADLOCK: ::std::os::raw::c_uint = 35;
pub const EBFONT: ::std::os::raw::c_uint = 59;
pub const ENOSTR: ::std::os::raw::c_uint = 60;
pub const ENODATA: ::std::os::raw::c_uint = 61;
pub const ETIME: ::std::os::raw::c_uint = 62;
pub const ENOSR: ::std::os::raw::c_uint = 63;
pub const ENONET: ::std::os::raw::c_uint = 64;
pub const ENOPKG: ::std::os::raw::c_uint = 65;
pub const EREMOTE: ::std::os::raw::c_uint = 66;
pub const ENOLINK: ::std::os::raw::c_uint = 67;
pub const EADV: ::std::os::raw::c_uint = 68;
pub const ESRMNT: ::std::os::raw::c_uint = 69;
pub const ECOMM: ::std::os::raw::c_uint = 70;
pub const EPROTO: ::std::os::raw::c_uint = 71;
pub const EMULTIHOP: ::std::os::raw::c_uint = 72;
pub const EDOTDOT: ::std::os::raw::c_uint = 73;
pub const EBADMSG: ::std::os::raw::c_uint = 74;
pub const EOVERFLOW: ::std::os::raw::c_uint = 75;
pub const ENOTUNIQ: ::std::os::raw::c_uint = 76;
pub const EBADFD: ::std::os::raw::c_uint = 77;
pub const EREMCHG: ::std::os::raw::c_uint = 78;
pub const ELIBACC: ::std::os::raw::c_uint = 79;
pub const ELIBBAD: ::std::os::raw::c_uint = 80;
pub const ELIBSCN: ::std::os::raw::c_uint = 81;
pub const ELIBMAX: ::std::os::raw::c_uint = 82;
pub const ELIBEXEC: ::std::os::raw::c_uint = 83;
pub const EILSEQ: ::std::os::raw::c_uint = 84;
pub const ERESTART: ::std::os::raw::c_uint = 85;
pub const ESTRPIPE: ::std::os::raw::c_uint = 86;
pub const EUSERS: ::std::os::raw::c_uint = 87;
pub const ENOTSOCK: ::std::os::raw::c_uint = 88;
pub const EDESTADDRREQ: ::std::os::raw::c_uint = 89;
pub const EMSGSIZE: ::std::os::raw::c_uint = 90;
pub const EPROTOTYPE: ::std::os::raw::c_uint = 91;
pub const ENOPROTOOPT: ::std::os::raw::c_uint = 92;
pub const EPROTONOSUPPORT: ::std::os::raw::c_uint = 93;
pub const ESOCKTNOSUPPORT: ::std::os::raw::c_uint = 94;
pub const EOPNOTSUPP: ::std::os::raw::c_uint = 95;
pub const EPFNOSUPPORT: ::std::os::raw::c_uint = 96;
pub const EAFNOSUPPORT: ::std::os::raw::c_uint = 97;
pub const EADDRINUSE: ::std::os::raw::c_uint = 98;
pub const EADDRNOTAVAIL: ::std::os::raw::c_uint = 99;
pub const ENETDOWN: ::std::os::raw::c_uint = 100;
pub const ENETUNREACH: ::std::os::raw::c_uint = 101;
pub const ENETRESET: ::std::os::raw::c_uint = 102;
pub const ECONNABORTED: ::std::os::raw::c_uint = 103;
pub const ECONNRESET: ::std::os::raw::c_uint = 104;
pub const ENOBUFS: ::std::os::raw::c_uint = 105;
pub const EISCONN: ::std::os::raw::c_uint = 106;
pub const ENOTCONN: ::std::os::raw::c_uint = 107;
pub const ESHUTDOWN: ::std::os::raw::c_uint = 108;
pub const ETOOMANYREFS: ::std::os::raw::c_uint = 109;
pub const ETIMEDOUT: ::std::os::raw::c_uint = 110;
pub const ECONNREFUSED: ::std::os::raw::c_uint = 111;
pub const EHOSTDOWN: ::std::os::raw::c_uint = 112;
pub const EHOSTUNREACH: ::std::os::raw::c_uint = 113;
pub const EALREADY: ::std::os::raw::c_uint = 114;
pub const EINPROGRESS: ::std::os::raw::c_uint = 115;
pub const ESTALE: ::std::os::raw::c_uint = 116;
pub const EUCLEAN: ::std::os::raw::c_uint = 117;
pub const ENOTNAM: ::std::os::raw::c_uint = 118;
pub const ENAVAIL: ::std::os::raw::c_uint = 119;
pub const EISNAM: ::std::os::raw::c_uint = 120;
pub const EREMOTEIO: ::std::os::raw::c_uint = 121;
pub const EDQUOT: ::std::os::raw::c_uint = 122;
pub const ENOMEDIUM: ::std::os::raw::c_uint = 123;
pub const EMEDIUMTYPE: ::std::os::raw::c_uint = 124;
pub const ECANCELED: ::std::os::raw::c_uint = 125;
pub const ENOKEY: ::std::os::raw::c_uint = 126;
pub const EKEYEXPIRED: ::std::os::raw::c_uint = 127;
pub const EKEYREVOKED: ::std::os::raw::c_uint = 128;
pub const EKEYREJECTED: ::std::os::raw::c_uint = 129;
pub const EOWNERDEAD: ::std::os::raw::c_uint = 130;
pub const ENOTRECOVERABLE: ::std::os::raw::c_uint = 131;
pub const ERFKILL: ::std::os::raw::c_uint = 132;
pub const EHWPOISON: ::std::os::raw::c_uint = 133;
pub const ENOTSUP: ::std::os::raw::c_uint = 95;
pub const GLIBTOP_SUID_CPU: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SUID_MEM: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SUID_SWAP: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SUID_UPTIME: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SUID_LOADAVG: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SUID_SHM_LIMITS: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SUID_MSG_LIMITS: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SUID_SEM_LIMITS: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SUID_PROCLIST: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SUID_PROC_STATE: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SUID_PROC_UID: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SUID_PROC_MEM: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SUID_PROC_TIME: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SUID_PROC_SIGNAL: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SUID_PROC_KERNEL: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SUID_PROC_SEGMENT: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SUID_PROC_ARGS: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SUID_PROC_MAP: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SUID_NETLOAD: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SUID_NETLIST: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SUID_PROC_WD: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SUID_PROC_AFFINITY: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SUID_PPP: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SUID_PROC_FILE: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_MOUNTENTRY_LEN: ::std::os::raw::c_uint = 79;
pub const GLIBTOP_SYSDEPS_FEATURES: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_SYSDEPS_CPU: ::std::os::raw::c_uint = 1;
pub const GLIBTOP_SYSDEPS_MEM: ::std::os::raw::c_uint = 2;
pub const GLIBTOP_SYSDEPS_SWAP: ::std::os::raw::c_uint = 3;
pub const GLIBTOP_SYSDEPS_UPTIME: ::std::os::raw::c_uint = 4;
pub const GLIBTOP_SYSDEPS_LOADAVG: ::std::os::raw::c_uint = 5;
pub const GLIBTOP_SYSDEPS_SHM_LIMITS: ::std::os::raw::c_uint = 6;
pub const GLIBTOP_SYSDEPS_MSG_LIMITS: ::std::os::raw::c_uint = 7;
pub const GLIBTOP_SYSDEPS_SEM_LIMITS: ::std::os::raw::c_uint = 8;
pub const GLIBTOP_SYSDEPS_PROCLIST: ::std::os::raw::c_uint = 9;
pub const GLIBTOP_SYSDEPS_PROC_STATE: ::std::os::raw::c_uint = 10;
pub const GLIBTOP_SYSDEPS_PROC_UID: ::std::os::raw::c_uint = 11;
pub const GLIBTOP_SYSDEPS_PROC_MEM: ::std::os::raw::c_uint = 12;
pub const GLIBTOP_SYSDEPS_PROC_TIME: ::std::os::raw::c_uint = 13;
pub const GLIBTOP_SYSDEPS_PROC_SIGNAL: ::std::os::raw::c_uint = 14;
pub const GLIBTOP_SYSDEPS_PROC_KERNEL: ::std::os::raw::c_uint = 15;
pub const GLIBTOP_SYSDEPS_PROC_SEGMENT: ::std::os::raw::c_uint = 16;
pub const GLIBTOP_SYSDEPS_PROC_ARGS: ::std::os::raw::c_uint = 17;
pub const GLIBTOP_SYSDEPS_PROC_MAP: ::std::os::raw::c_uint = 18;
pub const GLIBTOP_SYSDEPS_MOUNTLIST: ::std::os::raw::c_uint = 19;
pub const GLIBTOP_SYSDEPS_FSUSAGE: ::std::os::raw::c_uint = 20;
pub const GLIBTOP_SYSDEPS_NETLOAD: ::std::os::raw::c_uint = 21;
pub const GLIBTOP_SYSDEPS_PPP: ::std::os::raw::c_uint = 22;
pub const GLIBTOP_SYSDEPS_NETLIST: ::std::os::raw::c_uint = 23;
pub const GLIBTOP_SYSDEPS_PROC_OPEN_FILES: ::std::os::raw::c_uint = 24;
pub const GLIBTOP_SYSDEPS_PROC_WD: ::std::os::raw::c_uint = 25;
pub const GLIBTOP_SYSDEPS_PROC_AFFINITY: ::std::os::raw::c_uint = 26;
pub const GLIBTOP_MAX_SYSDEPS: ::std::os::raw::c_uint = 27;
pub const GLIBTOP_SYSDEPS_ALL: ::std::os::raw::c_uint = 134217727;
pub const GLIBTOP_CPU_TOTAL: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_CPU_USER: ::std::os::raw::c_uint = 1;
pub const GLIBTOP_CPU_NICE: ::std::os::raw::c_uint = 2;
pub const GLIBTOP_CPU_SYS: ::std::os::raw::c_uint = 3;
pub const GLIBTOP_CPU_IDLE: ::std::os::raw::c_uint = 4;
pub const GLIBTOP_CPU_FREQUENCY: ::std::os::raw::c_uint = 5;
pub const GLIBTOP_XCPU_TOTAL: ::std::os::raw::c_uint = 6;
pub const GLIBTOP_XCPU_USER: ::std::os::raw::c_uint = 7;
pub const GLIBTOP_XCPU_NICE: ::std::os::raw::c_uint = 8;
pub const GLIBTOP_XCPU_SYS: ::std::os::raw::c_uint = 9;
pub const GLIBTOP_XCPU_IDLE: ::std::os::raw::c_uint = 10;
pub const GLIBTOP_XCPU_FLAGS: ::std::os::raw::c_uint = 11;
pub const GLIBTOP_CPU_IOWAIT: ::std::os::raw::c_uint = 12;
pub const GLIBTOP_CPU_IRQ: ::std::os::raw::c_uint = 13;
pub const GLIBTOP_CPU_SOFTIRQ: ::std::os::raw::c_uint = 14;
pub const GLIBTOP_XCPU_IOWAIT: ::std::os::raw::c_uint = 15;
pub const GLIBTOP_XCPU_IRQ: ::std::os::raw::c_uint = 16;
pub const GLIBTOP_XCPU_SOFTIRQ: ::std::os::raw::c_uint = 17;
pub const GLIBTOP_MAX_CPU: ::std::os::raw::c_uint = 18;
pub const GLIBTOP_NCPU: ::std::os::raw::c_uint = 1024;
pub const GLIBTOP_MEM_TOTAL: ::std::os::raw::c_uint = 0;
pub const GLIBTOP_MEM_USED: ::std::os::raw::c_uint = 1;
pub const GLIBTOP_MEM_FREE: ::std::os::raw::c_uint = 2;
pub const GLIBTOP_MEM_SHARED: ::std::os::raw::c_uint = 3;
pub const GLIBTOP_MEM_BUFFER: ::std::os::raw::c_uint = 4;
pub const GLIBTOP_MEM_CACHED: ::std::os::raw::c_uint = 5;
pub const GLIBTOP_MEM_USER: ::std::os::raw::c_uint = 6;
pub const GLIBTOP_MEM_LOCKED: ::std::os::raw::c_uint = 7;
pub const GLIBTOP_MAX_MEM: ::std::os::raw::c_uint = 8;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint, __minor: ::std::os::raw::c_uint) -> ::std::os::raw::c_ulonglong;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: pthread_mutex_t___pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t___pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pthread_mutex_t___pthread_mutex_s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: pthread_cond_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__futex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__total_seq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__total_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__wakeup_seq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__wakeup_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__woken_seq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__woken_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__mutex as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__nwaiters as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__nwaiters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__broadcast_seq as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__broadcast_seq)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: pthread_rwlock_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__nr_readers as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__nr_readers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__readers_wakeup as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__readers_wakeup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__writer_wakeup as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__writer_wakeup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__nr_readers_queued as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__nr_readers_queued)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__nr_writers_queued as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__nr_writers_queued)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__writer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__writer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__shared as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__rwelision as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__flags)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type gint8 = ::std::os::raw::c_schar;
pub type guint8 = ::std::os::raw::c_uchar;
pub type gint16 = ::std::os::raw::c_short;
pub type guint16 = ::std::os::raw::c_ushort;
pub type gint32 = ::std::os::raw::c_int;
pub type guint32 = ::std::os::raw::c_uint;
pub type gint64 = ::std::os::raw::c_long;
pub type guint64 = ::std::os::raw::c_ulong;
pub type gssize = ::std::os::raw::c_long;
pub type gsize = ::std::os::raw::c_ulong;
pub type goffset = gint64;
pub type gintptr = ::std::os::raw::c_long;
pub type guintptr = ::std::os::raw::c_ulong;
pub type GPid = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(__s: *mut ::std::os::raw::c_char, __maxsize: usize, __format: *const ::std::os::raw::c_char, __tp: *const tm) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: __locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(__tp: *const tm, __buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(__timer: *const time_t, __buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(__requested_time: *const timespec, __remaining: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(__clock_id: clockid_t, __evp: *mut sigevent, __timerid: *mut timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type gchar = ::std::os::raw::c_char;
pub type gshort = ::std::os::raw::c_short;
pub type glong = ::std::os::raw::c_long;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guchar = ::std::os::raw::c_uchar;
pub type gushort = ::std::os::raw::c_ushort;
pub type gulong = ::std::os::raw::c_ulong;
pub type guint = ::std::os::raw::c_uint;
pub type gfloat = f32;
pub type gdouble = f64;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type gconstpointer = *const ::std::os::raw::c_void;
pub type GCompareFunc = ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gint>;
pub type GCompareDataFunc = ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer, user_data: gpointer) -> gint>;
pub type GEqualFunc = ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gboolean>;
pub type GDestroyNotify = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer)>;
pub type GHashFunc = ::std::option::Option<unsafe extern "C" fn(key: gconstpointer) -> guint>;
pub type GHFunc = ::std::option::Option<unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer)>;
/// GFreeFunc:
/// @data: a data pointer
///
/// Declares a type of function which takes an arbitrary
/// data pointer argument and has no return value. It is
/// not currently used in GLib or GTK+.
pub type GFreeFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
/// GTranslateFunc:
/// @str: the untranslated string
/// @data: user data specified when installing the function, e.g.
/// in g_option_group_set_translate_func()
///
/// The type of functions which are used to translate user-visible
/// strings, for <option>--help</option> output.
///
/// Returns: a translation of the string for the current locale.
/// The returned string is owned by GLib and must not be freed.
pub type GTranslateFunc = ::std::option::Option<unsafe extern "C" fn(str: *const gchar, data: gpointer) -> *const gchar>;
pub type GDoubleIEEE754 = _GDoubleIEEE754;
pub type GFloatIEEE754 = _GFloatIEEE754;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GFloatIEEE754 {
    pub v_float: gfloat,
    pub mpn: _GFloatIEEE754__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFloatIEEE754__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__GFloatIEEE754__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GFloatIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_GFloatIEEE754__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFloatIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_GFloatIEEE754__bindgen_ty_1))
    );
}
impl _GFloatIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mantissa: guint, biased_exponent: guint, sign: guint) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 23u8, {
            let mantissa: u32 = unsafe { ::std::mem::transmute(mantissa) };
            mantissa as u64
        });
        __bindgen_bitfield_unit.set(23usize, 8u8, {
            let biased_exponent: u32 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__GFloatIEEE754() {
    assert_eq!(
        ::std::mem::size_of::<_GFloatIEEE754>(),
        4usize,
        concat!("Size of: ", stringify!(_GFloatIEEE754))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFloatIEEE754>(),
        4usize,
        concat!("Alignment of ", stringify!(_GFloatIEEE754))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFloatIEEE754>())).v_float as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFloatIEEE754),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFloatIEEE754>())).mpn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFloatIEEE754),
            "::",
            stringify!(mpn)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GDoubleIEEE754 {
    pub v_double: gdouble,
    pub mpn: _GDoubleIEEE754__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDoubleIEEE754__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__GDoubleIEEE754__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GDoubleIEEE754__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GDoubleIEEE754__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDoubleIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_GDoubleIEEE754__bindgen_ty_1))
    );
}
impl _GDoubleIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa_low(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_low(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn mantissa_high(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_high(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa_low: guint,
        mantissa_high: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u32> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let mantissa_low: u32 = unsafe { ::std::mem::transmute(mantissa_low) };
            mantissa_low as u64
        });
        __bindgen_bitfield_unit.set(32usize, 20u8, {
            let mantissa_high: u32 = unsafe { ::std::mem::transmute(mantissa_high) };
            mantissa_high as u64
        });
        __bindgen_bitfield_unit.set(52usize, 11u8, {
            let biased_exponent: u32 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__GDoubleIEEE754() {
    assert_eq!(
        ::std::mem::size_of::<_GDoubleIEEE754>(),
        8usize,
        concat!("Size of: ", stringify!(_GDoubleIEEE754))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDoubleIEEE754>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDoubleIEEE754))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDoubleIEEE754>())).v_double as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDoubleIEEE754),
            "::",
            stringify!(v_double)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDoubleIEEE754>())).mpn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDoubleIEEE754),
            "::",
            stringify!(mpn)
        )
    );
}
pub type GTimeVal = _GTimeVal;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeVal {
    pub tv_sec: glong,
    pub tv_usec: glong,
}
#[test]
fn bindgen_test_layout__GTimeVal() {
    assert_eq!(
        ::std::mem::size_of::<_GTimeVal>(),
        16usize,
        concat!("Size of: ", stringify!(_GTimeVal))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTimeVal>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTimeVal))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTimeVal>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTimeVal),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTimeVal>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTimeVal),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBytes {
    _unused: [u8; 0],
}
pub type GBytes = _GBytes;
pub type GArray = _GArray;
pub type GByteArray = _GByteArray;
pub type GPtrArray = _GPtrArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GArray {
    pub data: *mut gchar,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GArray() {
    assert_eq!(
        ::std::mem::size_of::<_GArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GArray>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GArray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GArray>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GArray),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GByteArray {
    pub data: *mut guint8,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GByteArray() {
    assert_eq!(
        ::std::mem::size_of::<_GByteArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GByteArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GByteArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GByteArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GByteArray>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GByteArray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GByteArray>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GByteArray),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPtrArray {
    pub pdata: *mut gpointer,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GPtrArray() {
    assert_eq!(
        ::std::mem::size_of::<_GPtrArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GPtrArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPtrArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPtrArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPtrArray>())).pdata as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPtrArray),
            "::",
            stringify!(pdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPtrArray>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPtrArray),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    pub fn g_array_new(zero_terminated: gboolean, clear_: gboolean, element_size: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_sized_new(zero_terminated: gboolean, clear_: gboolean, element_size: guint, reserved_size: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_free(array: *mut GArray, free_segment: gboolean) -> *mut gchar;
}
extern "C" {
    pub fn g_array_ref(array: *mut GArray) -> *mut GArray;
}
extern "C" {
    pub fn g_array_unref(array: *mut GArray);
}
extern "C" {
    pub fn g_array_get_element_size(array: *mut GArray) -> guint;
}
extern "C" {
    pub fn g_array_append_vals(array: *mut GArray, data: gconstpointer, len: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_prepend_vals(array: *mut GArray, data: gconstpointer, len: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_insert_vals(array: *mut GArray, index_: guint, data: gconstpointer, len: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_set_size(array: *mut GArray, length: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_remove_index(array: *mut GArray, index_: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_remove_index_fast(array: *mut GArray, index_: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_remove_range(array: *mut GArray, index_: guint, length: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_sort(array: *mut GArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_array_sort_with_data(array: *mut GArray, compare_func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_array_set_clear_func(array: *mut GArray, clear_func: GDestroyNotify);
}
extern "C" {
    pub fn g_ptr_array_new() -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_with_free_func(element_free_func: GDestroyNotify) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_sized_new(reserved_size: guint) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_full(reserved_size: guint, element_free_func: GDestroyNotify) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_free(array: *mut GPtrArray, free_seg: gboolean) -> *mut gpointer;
}
extern "C" {
    pub fn g_ptr_array_ref(array: *mut GPtrArray) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_unref(array: *mut GPtrArray);
}
extern "C" {
    pub fn g_ptr_array_set_free_func(array: *mut GPtrArray, element_free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_ptr_array_set_size(array: *mut GPtrArray, length: gint);
}
extern "C" {
    pub fn g_ptr_array_remove_index(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_remove_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_remove(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_ptr_array_remove_fast(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_ptr_array_remove_range(array: *mut GPtrArray, index_: guint, length: guint) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_add(array: *mut GPtrArray, data: gpointer);
}
extern "C" {
    pub fn g_ptr_array_insert(array: *mut GPtrArray, index_: gint, data: gpointer);
}
extern "C" {
    pub fn g_ptr_array_sort(array: *mut GPtrArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_ptr_array_sort_with_data(array: *mut GPtrArray, compare_func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_ptr_array_foreach(array: *mut GPtrArray, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_byte_array_new() -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_new_take(data: *mut guint8, len: gsize) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_sized_new(reserved_size: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_free(array: *mut GByteArray, free_segment: gboolean) -> *mut guint8;
}
extern "C" {
    pub fn g_byte_array_free_to_bytes(array: *mut GByteArray) -> *mut GBytes;
}
extern "C" {
    pub fn g_byte_array_ref(array: *mut GByteArray) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_unref(array: *mut GByteArray);
}
extern "C" {
    pub fn g_byte_array_append(array: *mut GByteArray, data: *const guint8, len: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_prepend(array: *mut GByteArray, data: *const guint8, len: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_set_size(array: *mut GByteArray, length: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_remove_index(array: *mut GByteArray, index_: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_remove_index_fast(array: *mut GByteArray, index_: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_remove_range(array: *mut GByteArray, index_: guint, length: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_sort(array: *mut GByteArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_byte_array_sort_with_data(array: *mut GByteArray, compare_func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_atomic_int_get(atomic: *const gint) -> gint;
}
extern "C" {
    pub fn g_atomic_int_set(atomic: *mut gint, newval: gint);
}
extern "C" {
    pub fn g_atomic_int_inc(atomic: *mut gint);
}
extern "C" {
    pub fn g_atomic_int_dec_and_test(atomic: *mut gint) -> gboolean;
}
extern "C" {
    pub fn g_atomic_int_compare_and_exchange(atomic: *mut gint, oldval: gint, newval: gint) -> gboolean;
}
extern "C" {
    pub fn g_atomic_int_add(atomic: *mut gint, val: gint) -> gint;
}
extern "C" {
    pub fn g_atomic_int_and(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    pub fn g_atomic_int_or(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    pub fn g_atomic_int_xor(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    pub fn g_atomic_pointer_get(atomic: *const ::std::os::raw::c_void) -> gpointer;
}
extern "C" {
    pub fn g_atomic_pointer_set(atomic: *mut ::std::os::raw::c_void, newval: gpointer);
}
extern "C" {
    pub fn g_atomic_pointer_compare_and_exchange(atomic: *mut ::std::os::raw::c_void, oldval: gpointer, newval: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_atomic_pointer_add(atomic: *mut ::std::os::raw::c_void, val: gssize) -> gssize;
}
extern "C" {
    pub fn g_atomic_pointer_and(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    pub fn g_atomic_pointer_or(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    pub fn g_atomic_pointer_xor(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    pub fn g_atomic_int_exchange_and_add(atomic: *mut gint, val: gint) -> gint;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type GQuark = guint32;
extern "C" {
    pub fn g_quark_try_string(string: *const gchar) -> GQuark;
}
extern "C" {
    pub fn g_quark_from_static_string(string: *const gchar) -> GQuark;
}
extern "C" {
    pub fn g_quark_from_string(string: *const gchar) -> GQuark;
}
extern "C" {
    pub fn g_quark_to_string(quark: GQuark) -> *const gchar;
}
extern "C" {
    pub fn g_intern_string(string: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_intern_static_string(string: *const gchar) -> *const gchar;
}
/// GError:
/// @domain: error domain, e.g. #G_FILE_ERROR
/// @code: error code, e.g. %G_FILE_ERROR_NOENT
/// @message: human-readable informative error message
///
/// The `GError` structure contains information about
/// an error that has occurred.
pub type GError = _GError;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GError {
    pub domain: GQuark,
    pub code: gint,
    pub message: *mut gchar,
}
#[test]
fn bindgen_test_layout__GError() {
    assert_eq!(
        ::std::mem::size_of::<_GError>(),
        16usize,
        concat!("Size of: ", stringify!(_GError))
    );
    assert_eq!(
        ::std::mem::align_of::<_GError>(),
        8usize,
        concat!("Alignment of ", stringify!(_GError))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GError>())).domain as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GError>())).code as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GError>())).message as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(message)
        )
    );
}
extern "C" {
    pub fn g_error_new(domain: GQuark, code: gint, format: *const gchar, ...) -> *mut GError;
}
extern "C" {
    pub fn g_error_new_literal(domain: GQuark, code: gint, message: *const gchar) -> *mut GError;
}
extern "C" {
    pub fn g_error_new_valist(domain: GQuark, code: gint, format: *const gchar, args: *mut __va_list_tag) -> *mut GError;
}
extern "C" {
    pub fn g_error_free(error: *mut GError);
}
extern "C" {
    pub fn g_error_copy(error: *const GError) -> *mut GError;
}
extern "C" {
    pub fn g_error_matches(error: *const GError, domain: GQuark, code: gint) -> gboolean;
}
extern "C" {
    pub fn g_set_error(err: *mut *mut GError, domain: GQuark, code: gint, format: *const gchar, ...);
}
extern "C" {
    pub fn g_set_error_literal(err: *mut *mut GError, domain: GQuark, code: gint, message: *const gchar);
}
extern "C" {
    pub fn g_propagate_error(dest: *mut *mut GError, src: *mut GError);
}
extern "C" {
    pub fn g_clear_error(err: *mut *mut GError);
}
extern "C" {
    pub fn g_prefix_error(err: *mut *mut GError, format: *const gchar, ...);
}
extern "C" {
    pub fn g_propagate_prefixed_error(dest: *mut *mut GError, src: *mut GError, format: *const gchar, ...);
}
extern "C" {
    pub fn g_get_user_name() -> *const gchar;
}
extern "C" {
    pub fn g_get_real_name() -> *const gchar;
}
extern "C" {
    pub fn g_get_home_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_tmp_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_host_name() -> *const gchar;
}
extern "C" {
    pub fn g_get_prgname() -> *const gchar;
}
extern "C" {
    pub fn g_set_prgname(prgname: *const gchar);
}
extern "C" {
    pub fn g_get_application_name() -> *const gchar;
}
extern "C" {
    pub fn g_set_application_name(application_name: *const gchar);
}
extern "C" {
    pub fn g_reload_user_special_dirs_cache();
}
extern "C" {
    pub fn g_get_user_data_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_user_config_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_user_cache_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_system_data_dirs() -> *const *const gchar;
}
extern "C" {
    pub fn g_get_system_config_dirs() -> *const *const gchar;
}
extern "C" {
    pub fn g_get_user_runtime_dir() -> *const gchar;
}
pub const GUserDirectory_G_USER_DIRECTORY_DESKTOP: GUserDirectory = 0;
pub const GUserDirectory_G_USER_DIRECTORY_DOCUMENTS: GUserDirectory = 1;
pub const GUserDirectory_G_USER_DIRECTORY_DOWNLOAD: GUserDirectory = 2;
pub const GUserDirectory_G_USER_DIRECTORY_MUSIC: GUserDirectory = 3;
pub const GUserDirectory_G_USER_DIRECTORY_PICTURES: GUserDirectory = 4;
pub const GUserDirectory_G_USER_DIRECTORY_PUBLIC_SHARE: GUserDirectory = 5;
pub const GUserDirectory_G_USER_DIRECTORY_TEMPLATES: GUserDirectory = 6;
pub const GUserDirectory_G_USER_DIRECTORY_VIDEOS: GUserDirectory = 7;
pub const GUserDirectory_G_USER_N_DIRECTORIES: GUserDirectory = 8;
pub type GUserDirectory = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_get_user_special_dir(directory: GUserDirectory) -> *const gchar;
}
/// GDebugKey:
/// @key: the string
/// @value: the flag
///
/// Associates a string with a bit flag.
/// Used in g_parse_debug_string().
pub type GDebugKey = _GDebugKey;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDebugKey {
    pub key: *const gchar,
    pub value: guint,
}
#[test]
fn bindgen_test_layout__GDebugKey() {
    assert_eq!(
        ::std::mem::size_of::<_GDebugKey>(),
        16usize,
        concat!("Size of: ", stringify!(_GDebugKey))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDebugKey>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDebugKey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDebugKey>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugKey),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDebugKey>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugKey),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    pub fn g_parse_debug_string(string: *const gchar, keys: *const GDebugKey, nkeys: guint) -> guint;
}
extern "C" {
    pub fn g_snprintf(string: *mut gchar, n: gulong, format: *const gchar, ...) -> gint;
}
extern "C" {
    pub fn g_vsnprintf(string: *mut gchar, n: gulong, format: *const gchar, args: *mut __va_list_tag) -> gint;
}
extern "C" {
    pub fn g_nullify_pointer(nullify_location: *mut gpointer);
}
pub const GFormatSizeFlags_G_FORMAT_SIZE_DEFAULT: GFormatSizeFlags = 0;
pub const GFormatSizeFlags_G_FORMAT_SIZE_LONG_FORMAT: GFormatSizeFlags = 1;
pub const GFormatSizeFlags_G_FORMAT_SIZE_IEC_UNITS: GFormatSizeFlags = 2;
pub type GFormatSizeFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_format_size_full(size: guint64, flags: GFormatSizeFlags) -> *mut gchar;
}
extern "C" {
    pub fn g_format_size(size: guint64) -> *mut gchar;
}
extern "C" {
    pub fn g_format_size_for_display(size: goffset) -> *mut gchar;
}
/// GVoidFunc:
///
/// Declares a type of function which takes no arguments
/// and has no return value. It is used to specify the type
/// function passed to g_atexit().
pub type GVoidFunc = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn g_atexit(func: GVoidFunc);
}
extern "C" {
    pub fn g_find_program_in_path(program: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_bit_nth_lsf(mask: gulong, nth_bit: gint) -> gint;
}
extern "C" {
    pub fn g_bit_nth_msf(mask: gulong, nth_bit: gint) -> gint;
}
extern "C" {
    pub fn g_bit_storage(number: gulong) -> guint;
}
extern "C" {
    pub fn g_thread_error_quark() -> GQuark;
}
pub const GThreadError_G_THREAD_ERROR_AGAIN: GThreadError = 0;
pub type GThreadError = ::std::os::raw::c_uint;
pub type GThreadFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer) -> gpointer>;
pub type GThread = _GThread;
pub type GMutex = _GMutex;
pub type GRecMutex = _GRecMutex;
pub type GRWLock = _GRWLock;
pub type GCond = _GCond;
pub type GPrivate = _GPrivate;
pub type GOnce = _GOnce;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__GMutex() {
    assert_eq!(
        ::std::mem::size_of::<_GMutex>(),
        8usize,
        concat!("Size of: ", stringify!(_GMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMutex>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMutex),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMutex>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMutex),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRWLock {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GRWLock() {
    assert_eq!(
        ::std::mem::size_of::<_GRWLock>(),
        16usize,
        concat!("Size of: ", stringify!(_GRWLock))
    );
    assert_eq!(
        ::std::mem::align_of::<_GRWLock>(),
        8usize,
        concat!("Alignment of ", stringify!(_GRWLock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GRWLock>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRWLock),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GRWLock>())).i as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRWLock),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCond {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GCond() {
    assert_eq!(
        ::std::mem::size_of::<_GCond>(),
        16usize,
        concat!("Size of: ", stringify!(_GCond))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCond>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCond))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCond>())).p as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_GCond), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCond>())).i as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_GCond), "::", stringify!(i))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRecMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GRecMutex() {
    assert_eq!(
        ::std::mem::size_of::<_GRecMutex>(),
        16usize,
        concat!("Size of: ", stringify!(_GRecMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GRecMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GRecMutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GRecMutex>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRecMutex),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GRecMutex>())).i as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRecMutex),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPrivate {
    pub p: gpointer,
    pub notify: GDestroyNotify,
    pub future: [gpointer; 2usize],
}
#[test]
fn bindgen_test_layout__GPrivate() {
    assert_eq!(
        ::std::mem::size_of::<_GPrivate>(),
        32usize,
        concat!("Size of: ", stringify!(_GPrivate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPrivate>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPrivate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPrivate>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPrivate>())).notify as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPrivate>())).future as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(future)
        )
    );
}
pub const GOnceStatus_G_ONCE_STATUS_NOTCALLED: GOnceStatus = 0;
pub const GOnceStatus_G_ONCE_STATUS_PROGRESS: GOnceStatus = 1;
pub const GOnceStatus_G_ONCE_STATUS_READY: GOnceStatus = 2;
pub type GOnceStatus = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOnce {
    pub status: GOnceStatus,
    pub retval: gpointer,
}
#[test]
fn bindgen_test_layout__GOnce() {
    assert_eq!(
        ::std::mem::size_of::<_GOnce>(),
        16usize,
        concat!("Size of: ", stringify!(_GOnce))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOnce>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOnce))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOnce>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOnce),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOnce>())).retval as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOnce),
            "::",
            stringify!(retval)
        )
    );
}
extern "C" {
    pub fn g_thread_ref(thread: *mut GThread) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_unref(thread: *mut GThread);
}
extern "C" {
    pub fn g_thread_new(name: *const gchar, func: GThreadFunc, data: gpointer) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_try_new(name: *const gchar, func: GThreadFunc, data: gpointer, error: *mut *mut GError) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_self() -> *mut GThread;
}
extern "C" {
    pub fn g_thread_exit(retval: gpointer);
}
extern "C" {
    pub fn g_thread_join(thread: *mut GThread) -> gpointer;
}
extern "C" {
    pub fn g_thread_yield();
}
extern "C" {
    pub fn g_mutex_init(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_mutex_clear(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_mutex_lock(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_mutex_trylock(mutex: *mut GMutex) -> gboolean;
}
extern "C" {
    pub fn g_mutex_unlock(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_rw_lock_init(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_clear(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_writer_lock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_writer_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
extern "C" {
    pub fn g_rw_lock_writer_unlock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_reader_lock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_reader_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
extern "C" {
    pub fn g_rw_lock_reader_unlock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rec_mutex_init(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_rec_mutex_clear(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_rec_mutex_lock(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_rec_mutex_trylock(rec_mutex: *mut GRecMutex) -> gboolean;
}
extern "C" {
    pub fn g_rec_mutex_unlock(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_cond_init(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_clear(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_wait(cond: *mut GCond, mutex: *mut GMutex);
}
extern "C" {
    pub fn g_cond_signal(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_broadcast(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_wait_until(cond: *mut GCond, mutex: *mut GMutex, end_time: gint64) -> gboolean;
}
extern "C" {
    pub fn g_private_get(key: *mut GPrivate) -> gpointer;
}
extern "C" {
    pub fn g_private_set(key: *mut GPrivate, value: gpointer);
}
extern "C" {
    pub fn g_private_replace(key: *mut GPrivate, value: gpointer);
}
extern "C" {
    pub fn g_once_impl(once: *mut GOnce, func: GThreadFunc, arg: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_once_init_enter(location: *mut ::std::os::raw::c_void) -> gboolean;
}
extern "C" {
    pub fn g_once_init_leave(location: *mut ::std::os::raw::c_void, result: gsize);
}
extern "C" {
    pub fn g_get_num_processors() -> guint;
}
/// GMutexLocker:
///
/// Opaque type. See g_mutex_locker_new() for details.
/// Since: 2.44
pub type GMutexLocker = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncQueue {
    _unused: [u8; 0],
}
pub type GAsyncQueue = _GAsyncQueue;
extern "C" {
    pub fn g_async_queue_new() -> *mut GAsyncQueue;
}
extern "C" {
    pub fn g_async_queue_new_full(item_free_func: GDestroyNotify) -> *mut GAsyncQueue;
}
extern "C" {
    pub fn g_async_queue_lock(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_unlock(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_ref(queue: *mut GAsyncQueue) -> *mut GAsyncQueue;
}
extern "C" {
    pub fn g_async_queue_unref(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_ref_unlocked(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_unref_and_unlock(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_push(queue: *mut GAsyncQueue, data: gpointer);
}
extern "C" {
    pub fn g_async_queue_push_unlocked(queue: *mut GAsyncQueue, data: gpointer);
}
extern "C" {
    pub fn g_async_queue_push_sorted(queue: *mut GAsyncQueue, data: gpointer, func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_async_queue_push_sorted_unlocked(queue: *mut GAsyncQueue, data: gpointer, func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_async_queue_pop(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_try_pop(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_try_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_timeout_pop(queue: *mut GAsyncQueue, timeout: guint64) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_timeout_pop_unlocked(queue: *mut GAsyncQueue, timeout: guint64) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_length(queue: *mut GAsyncQueue) -> gint;
}
extern "C" {
    pub fn g_async_queue_length_unlocked(queue: *mut GAsyncQueue) -> gint;
}
extern "C" {
    pub fn g_async_queue_sort(queue: *mut GAsyncQueue, func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_async_queue_sort_unlocked(queue: *mut GAsyncQueue, func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_async_queue_remove(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_async_queue_remove_unlocked(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_async_queue_push_front(queue: *mut GAsyncQueue, item: gpointer);
}
extern "C" {
    pub fn g_async_queue_push_front_unlocked(queue: *mut GAsyncQueue, item: gpointer);
}
extern "C" {
    pub fn g_async_queue_timed_pop(queue: *mut GAsyncQueue, end_time: *mut GTimeVal) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_timed_pop_unlocked(queue: *mut GAsyncQueue, end_time: *mut GTimeVal) -> gpointer;
}
extern "C" {
    pub fn __sigismember(arg1: *const __sigset_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sigaddset(arg1: *mut __sigset_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sigdelset(arg1: *mut __sigset_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
pub type sigval_t = sigval;
pub type __sigchld_clock_t = __clock_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 28usize],
    pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7,
    _bindgen_union_align: [u64; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_1>())).si_pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_1>())).si_uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_uid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: ::std::os::raw::c_int,
    pub si_overrun: ::std::os::raw::c_int,
    pub si_sigval: sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_tid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_overrun as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_overrun)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_sigval as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_sigval)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_sigval as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_sigval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_utime: __sigchld_clock_t,
    pub si_stime: __sigchld_clock_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_status as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_utime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_stime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_stime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_addr_lsb: ::std::os::raw::c_short,
    pub si_addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()))._lower as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_lower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()))._upper as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_upper)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>())).si_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>())).si_addr_lsb as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(si_addr_lsb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>())).si_addr_bnd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(si_addr_bnd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: ::std::os::raw::c_long,
    pub si_fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_6>())).si_band as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_6>())).si_fd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(si_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._call_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_call_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._syscall as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_syscall)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._arch as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_arch)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1>(),
        112usize,
        concat!("Size of: ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._kill as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_kill)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._timer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._rt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_rt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigchld as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigchld)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigfault as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigfault)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigpoll as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigpoll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigsys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigsys)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t>(),
        128usize,
        concat!("Size of: ", stringify!(siginfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_errno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>()))._sifields as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(_sifields)
        )
    );
}
pub const SI_ASYNCNL: _bindgen_ty_1 = -60;
pub const SI_TKILL: _bindgen_ty_1 = -6;
pub const SI_SIGIO: _bindgen_ty_1 = -5;
pub const SI_ASYNCIO: _bindgen_ty_1 = -4;
pub const SI_MESGQ: _bindgen_ty_1 = -3;
pub const SI_TIMER: _bindgen_ty_1 = -2;
pub const SI_QUEUE: _bindgen_ty_1 = -1;
pub const SI_USER: _bindgen_ty_1 = 0;
pub const SI_KERNEL: _bindgen_ty_1 = 128;
pub type _bindgen_ty_1 = ::std::os::raw::c_int;
pub const ILL_ILLOPC: _bindgen_ty_2 = 1;
pub const ILL_ILLOPN: _bindgen_ty_2 = 2;
pub const ILL_ILLADR: _bindgen_ty_2 = 3;
pub const ILL_ILLTRP: _bindgen_ty_2 = 4;
pub const ILL_PRVOPC: _bindgen_ty_2 = 5;
pub const ILL_PRVREG: _bindgen_ty_2 = 6;
pub const ILL_COPROC: _bindgen_ty_2 = 7;
pub const ILL_BADSTK: _bindgen_ty_2 = 8;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const FPE_INTDIV: _bindgen_ty_3 = 1;
pub const FPE_INTOVF: _bindgen_ty_3 = 2;
pub const FPE_FLTDIV: _bindgen_ty_3 = 3;
pub const FPE_FLTOVF: _bindgen_ty_3 = 4;
pub const FPE_FLTUND: _bindgen_ty_3 = 5;
pub const FPE_FLTRES: _bindgen_ty_3 = 6;
pub const FPE_FLTINV: _bindgen_ty_3 = 7;
pub const FPE_FLTSUB: _bindgen_ty_3 = 8;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const SEGV_MAPERR: _bindgen_ty_4 = 1;
pub const SEGV_ACCERR: _bindgen_ty_4 = 2;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const BUS_ADRALN: _bindgen_ty_5 = 1;
pub const BUS_ADRERR: _bindgen_ty_5 = 2;
pub const BUS_OBJERR: _bindgen_ty_5 = 3;
pub const BUS_MCEERR_AR: _bindgen_ty_5 = 4;
pub const BUS_MCEERR_AO: _bindgen_ty_5 = 5;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const CLD_EXITED: _bindgen_ty_6 = 1;
pub const CLD_KILLED: _bindgen_ty_6 = 2;
pub const CLD_DUMPED: _bindgen_ty_6 = 3;
pub const CLD_TRAPPED: _bindgen_ty_6 = 4;
pub const CLD_STOPPED: _bindgen_ty_6 = 5;
pub const CLD_CONTINUED: _bindgen_ty_6 = 6;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const POLL_IN: _bindgen_ty_7 = 1;
pub const POLL_OUT: _bindgen_ty_7 = 2;
pub const POLL_MSG: _bindgen_ty_7 = 3;
pub const POLL_ERR: _bindgen_ty_7 = 4;
pub const POLL_PRI: _bindgen_ty_7 = 5;
pub const POLL_HUP: _bindgen_ty_7 = 6;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 12usize],
    pub _tid: __pid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._function as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._attribute as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_attribute)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._tid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._sigev_thread as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_sigev_thread)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        64usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>()))._sigev_un as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(_sigev_un)
        )
    );
}
pub type sigevent_t = sigevent;
pub const SIGEV_SIGNAL: _bindgen_ty_8 = 0;
pub const SIGEV_NONE: _bindgen_ty_8 = 1;
pub const SIGEV_THREAD: _bindgen_ty_8 = 2;
pub const SIGEV_THREAD_ID: _bindgen_ty_8 = 4;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub type __sighandler_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
extern "C" {
    pub fn __sysv_signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn kill(__pid: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn killpg(__pgrp: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raise(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ssignal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn gsignal(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psignal(__sig: ::std::os::raw::c_int, __s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn psiginfo(__pinfo: *const siginfo_t, __s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sigblock(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsetmask(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siggetmask() -> ::std::os::raw::c_int;
}
pub type sig_t = __sighandler_t;
extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember(__set: *const sigset_t, __signo: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction:
        ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: *mut siginfo_t, arg3: *mut ::std::os::raw::c_void)>,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction__bindgen_ty_1>())).sa_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction__bindgen_ty_1>())).sa_sigaction as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_sigaction)
        )
    );
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        152usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).__sigaction_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_restorer as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_restorer)
        )
    );
}
extern "C" {
    pub fn sigprocmask(__how: ::std::os::raw::c_int, __set: *const sigset_t, __oset: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsuspend(__set: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaction(__sig: ::std::os::raw::c_int, __act: *const sigaction, __oact: *mut sigaction) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait(__set: *const sigset_t, __sig: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigtimedwait(__set: *const sigset_t, __info: *mut siginfo_t, __timeout: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigqueue(__pid: __pid_t, __sig: ::std::os::raw::c_int, __val: sigval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut _sys_siglist: [*const ::std::os::raw::c_char; 65usize];
}
extern "C" {
    pub static mut sys_siglist: [*const ::std::os::raw::c_char; 65usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub padding: [__uint32_t; 7usize],
}
#[test]
fn bindgen_test_layout__fpx_sw_bytes() {
    assert_eq!(
        ::std::mem::size_of::<_fpx_sw_bytes>(),
        48usize,
        concat!("Size of: ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpx_sw_bytes>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).magic1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(magic1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).extended_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(extended_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).xstate_bv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_bv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).xstate_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).padding as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__fpreg() {
    assert_eq!(
        ::std::mem::size_of::<_fpreg>(),
        10usize,
        concat!("Size of: ", stringify!(_fpreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(exponent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub padding: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__fpxreg() {
    assert_eq!(
        ::std::mem::size_of::<_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_fpxreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpxreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).padding as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__xmmreg() {
    assert_eq!(
        ::std::mem::size_of::<_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_xmmreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_xmmreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xmmreg>())).element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 16usize],
    pub padding: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__fpstate() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate>(),
        512usize,
        concat!("Size of: ", stringify!(_fpstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).ftw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(ftw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).rip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).rdp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).mxcr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(mxcr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>()))._st as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>()))._xmm as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(_xmm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).padding as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: ::std::os::raw::c_ushort,
    pub gs: ::std::os::raw::c_ushort,
    pub fs: ::std::os::raw::c_ushort,
    pub __pad0: ::std::os::raw::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub __bindgen_anon_1: sigcontext__bindgen_ty_1,
    pub __reserved1: [__uint64_t; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigcontext__bindgen_ty_1 {
    pub fpstate: *mut _fpstate,
    pub __fpstate_word: __uint64_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigcontext__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigcontext__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigcontext__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext__bindgen_ty_1>())).fpstate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext__bindgen_ty_1),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext__bindgen_ty_1>())).__fpstate_word as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext__bindgen_ty_1),
            "::",
            stringify!(__fpstate_word)
        )
    );
}
#[test]
fn bindgen_test_layout_sigcontext() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext>(),
        256usize,
        concat!("Size of: ", stringify!(sigcontext))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext>(),
        8usize,
        concat!("Alignment of ", stringify!(sigcontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r9 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r10 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r11 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r12 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r13 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r14 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r15 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rdi as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rsi as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rbp as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rbp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rbx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rdx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rax as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rcx as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rsp as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).eflags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(eflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).cs as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).gs as *const _ as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(gs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).fs as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).__pad0 as *const _ as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).err as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).trapno as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(trapno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).oldmask as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(oldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).cr2 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).__reserved1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub reserved1: [__uint64_t; 2usize],
    pub reserved2: [__uint64_t; 5usize],
}
#[test]
fn bindgen_test_layout__xsave_hdr() {
    assert_eq!(
        ::std::mem::size_of::<_xsave_hdr>(),
        64usize,
        concat!("Size of: ", stringify!(_xsave_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<_xsave_hdr>(),
        8usize,
        concat!("Alignment of ", stringify!(_xsave_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xsave_hdr>())).xstate_bv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(xstate_bv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xsave_hdr>())).reserved1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xsave_hdr>())).reserved2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ymmh_state {
    pub ymmh_space: [__uint32_t; 64usize],
}
#[test]
fn bindgen_test_layout__ymmh_state() {
    assert_eq!(
        ::std::mem::size_of::<_ymmh_state>(),
        256usize,
        concat!("Size of: ", stringify!(_ymmh_state))
    );
    assert_eq!(
        ::std::mem::align_of::<_ymmh_state>(),
        4usize,
        concat!("Alignment of ", stringify!(_ymmh_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ymmh_state>())).ymmh_space as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ymmh_state),
            "::",
            stringify!(ymmh_space)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _xstate {
    pub fpstate: _fpstate,
    pub xstate_hdr: _xsave_hdr,
    pub ymmh: _ymmh_state,
}
#[test]
fn bindgen_test_layout__xstate() {
    assert_eq!(
        ::std::mem::size_of::<_xstate>(),
        832usize,
        concat!("Size of: ", stringify!(_xstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_xstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_xstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).fpstate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).xstate_hdr as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(xstate_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).ymmh as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(ymmh)
        )
    );
}
extern "C" {
    pub fn sigreturn(__scp: *mut sigcontext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siginterrupt(__sig: ::std::os::raw::c_int, __interrupt: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_onstack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
pub const SS_ONSTACK: _bindgen_ty_9 = 1;
pub const SS_DISABLE: _bindgen_ty_9 = 2;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: usize,
}
#[test]
fn bindgen_test_layout_sigaltstack() {
    assert_eq!(
        ::std::mem::size_of::<sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaltstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaltstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaltstack>())).ss_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaltstack>())).ss_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
}
pub type stack_t = sigaltstack;
pub type greg_t = ::std::os::raw::c_longlong;
pub type gregset_t = [greg_t; 23usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub padding: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__libc_fpxreg() {
    assert_eq!(
        ::std::mem::size_of::<_libc_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_libc_fpxreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_libc_fpxreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpxreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpxreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpxreg>())).padding as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__libc_xmmreg() {
    assert_eq!(
        ::std::mem::size_of::<_libc_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_libc_xmmreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_libc_xmmreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_xmmreg>())).element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_libc_fpxreg; 8usize],
    pub _xmm: [_libc_xmmreg; 16usize],
    pub padding: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__libc_fpstate() {
    assert_eq!(
        ::std::mem::size_of::<_libc_fpstate>(),
        512usize,
        concat!("Size of: ", stringify!(_libc_fpstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_fpstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_libc_fpstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).ftw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(ftw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).rip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).rdp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).mxcr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(mxcr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>()))._st as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>()))._xmm as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(_xmm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).padding as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(padding)
        )
    );
}
pub type fpregset_t = *mut _libc_fpstate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [::std::os::raw::c_ulonglong; 8usize],
}
#[test]
fn bindgen_test_layout_mcontext_t() {
    assert_eq!(
        ::std::mem::size_of::<mcontext_t>(),
        256usize,
        concat!("Size of: ", stringify!(mcontext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mcontext_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mcontext_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).gregs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(gregs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).fpregs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(fpregs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).__reserved1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(__reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucontext {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut ucontext,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: __sigset_t,
    pub __fpregs_mem: _libc_fpstate,
}
#[test]
fn bindgen_test_layout_ucontext() {
    assert_eq!(
        ::std::mem::size_of::<ucontext>(),
        936usize,
        concat!("Size of: ", stringify!(ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(ucontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext>())).uc_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext>())).uc_link as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext>())).uc_stack as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext>())).uc_mcontext as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext>())).uc_sigmask as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext>())).__fpregs_mem as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(__fpregs_mem)
        )
    );
}
pub type ucontext_t = ucontext;
extern "C" {
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaltstack(__ss: *const sigaltstack, __oss: *mut sigaltstack) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_sigmask(__how: ::std::os::raw::c_int, __newmask: *const __sigset_t, __oldmask: *mut __sigset_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(__threadid: pthread_t, __signo: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_on_error_query(prg_name: *const gchar);
}
extern "C" {
    pub fn g_on_error_stack_trace(prg_name: *const gchar);
}
extern "C" {
    pub fn g_base64_encode_step(
        in_: *const guchar,
        len: gsize,
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
}
extern "C" {
    pub fn g_base64_encode_close(break_lines: gboolean, out: *mut gchar, state: *mut gint, save: *mut gint) -> gsize;
}
extern "C" {
    pub fn g_base64_encode(data: *const guchar, len: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_base64_decode_step(in_: *const gchar, len: gsize, out: *mut guchar, state: *mut gint, save: *mut guint) -> gsize;
}
extern "C" {
    pub fn g_base64_decode(text: *const gchar, out_len: *mut gsize) -> *mut guchar;
}
extern "C" {
    pub fn g_base64_decode_inplace(text: *mut gchar, out_len: *mut gsize) -> *mut guchar;
}
extern "C" {
    pub fn g_bit_lock(address: *mut gint, lock_bit: gint);
}
extern "C" {
    pub fn g_bit_trylock(address: *mut gint, lock_bit: gint) -> gboolean;
}
extern "C" {
    pub fn g_bit_unlock(address: *mut gint, lock_bit: gint);
}
extern "C" {
    pub fn g_pointer_bit_lock(address: *mut ::std::os::raw::c_void, lock_bit: gint);
}
extern "C" {
    pub fn g_pointer_bit_trylock(address: *mut ::std::os::raw::c_void, lock_bit: gint) -> gboolean;
}
extern "C" {
    pub fn g_pointer_bit_unlock(address: *mut ::std::os::raw::c_void, lock_bit: gint);
}
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_URI: GBookmarkFileError = 0;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_VALUE: GBookmarkFileError = 1;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: GBookmarkFileError = 2;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: GBookmarkFileError = 3;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_READ: GBookmarkFileError = 4;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: GBookmarkFileError = 5;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_WRITE: GBookmarkFileError = 6;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: GBookmarkFileError = 7;
pub type GBookmarkFileError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_bookmark_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBookmarkFile {
    _unused: [u8; 0],
}
/// GBookmarkFile:
///
/// The `GBookmarkFile` structure contains only
/// private data and should not be directly accessed.
pub type GBookmarkFile = _GBookmarkFile;
extern "C" {
    pub fn g_bookmark_file_new() -> *mut GBookmarkFile;
}
extern "C" {
    pub fn g_bookmark_file_free(bookmark: *mut GBookmarkFile);
}
extern "C" {
    pub fn g_bookmark_file_load_from_file(bookmark: *mut GBookmarkFile, filename: *const gchar, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_load_from_data(
        bookmark: *mut GBookmarkFile,
        data: *const gchar,
        length: gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_load_from_data_dirs(
        bookmark: *mut GBookmarkFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_to_data(bookmark: *mut GBookmarkFile, length: *mut gsize, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_to_file(bookmark: *mut GBookmarkFile, filename: *const gchar, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_title(bookmark: *mut GBookmarkFile, uri: *const gchar, title: *const gchar);
}
extern "C" {
    pub fn g_bookmark_file_get_title(bookmark: *mut GBookmarkFile, uri: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_description(bookmark: *mut GBookmarkFile, uri: *const gchar, description: *const gchar);
}
extern "C" {
    pub fn g_bookmark_file_get_description(bookmark: *mut GBookmarkFile, uri: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_mime_type(bookmark: *mut GBookmarkFile, uri: *const gchar, mime_type: *const gchar);
}
extern "C" {
    pub fn g_bookmark_file_get_mime_type(bookmark: *mut GBookmarkFile, uri: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_groups(bookmark: *mut GBookmarkFile, uri: *const gchar, groups: *mut *const gchar, length: gsize);
}
extern "C" {
    pub fn g_bookmark_file_add_group(bookmark: *mut GBookmarkFile, uri: *const gchar, group: *const gchar);
}
extern "C" {
    pub fn g_bookmark_file_has_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_add_application(bookmark: *mut GBookmarkFile, uri: *const gchar, name: *const gchar, exec: *const gchar);
}
extern "C" {
    pub fn g_bookmark_file_has_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_applications(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
        count: gint,
        stamp: time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *mut *mut gchar,
        count: *mut guint,
        stamp: *mut time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_is_private(bookmark: *mut GBookmarkFile, uri: *const gchar, is_private: gboolean);
}
extern "C" {
    pub fn g_bookmark_file_get_is_private(bookmark: *mut GBookmarkFile, uri: *const gchar, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_icon(bookmark: *mut GBookmarkFile, uri: *const gchar, href: *const gchar, mime_type: *const gchar);
}
extern "C" {
    pub fn g_bookmark_file_get_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *mut *mut gchar,
        mime_type: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_added(bookmark: *mut GBookmarkFile, uri: *const gchar, added: time_t);
}
extern "C" {
    pub fn g_bookmark_file_get_added(bookmark: *mut GBookmarkFile, uri: *const gchar, error: *mut *mut GError) -> time_t;
}
extern "C" {
    pub fn g_bookmark_file_set_modified(bookmark: *mut GBookmarkFile, uri: *const gchar, modified: time_t);
}
extern "C" {
    pub fn g_bookmark_file_get_modified(bookmark: *mut GBookmarkFile, uri: *const gchar, error: *mut *mut GError) -> time_t;
}
extern "C" {
    pub fn g_bookmark_file_set_visited(bookmark: *mut GBookmarkFile, uri: *const gchar, visited: time_t);
}
extern "C" {
    pub fn g_bookmark_file_get_visited(bookmark: *mut GBookmarkFile, uri: *const gchar, error: *mut *mut GError) -> time_t;
}
extern "C" {
    pub fn g_bookmark_file_has_item(bookmark: *mut GBookmarkFile, uri: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_size(bookmark: *mut GBookmarkFile) -> gint;
}
extern "C" {
    pub fn g_bookmark_file_get_uris(bookmark: *mut GBookmarkFile, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_remove_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_remove_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_remove_item(bookmark: *mut GBookmarkFile, uri: *const gchar, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_move_item(
        bookmark: *mut GBookmarkFile,
        old_uri: *const gchar,
        new_uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bytes_new(data: gconstpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_take(data: gpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_static(data: gconstpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_with_free_func(data: gconstpointer, size: gsize, free_func: GDestroyNotify, user_data: gpointer) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_from_bytes(bytes: *mut GBytes, offset: gsize, length: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_get_data(bytes: *mut GBytes, size: *mut gsize) -> gconstpointer;
}
extern "C" {
    pub fn g_bytes_get_size(bytes: *mut GBytes) -> gsize;
}
extern "C" {
    pub fn g_bytes_ref(bytes: *mut GBytes) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_unref(bytes: *mut GBytes);
}
extern "C" {
    pub fn g_bytes_unref_to_data(bytes: *mut GBytes, size: *mut gsize) -> gpointer;
}
extern "C" {
    pub fn g_bytes_unref_to_array(bytes: *mut GBytes) -> *mut GByteArray;
}
extern "C" {
    pub fn g_bytes_hash(bytes: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_bytes_equal(bytes1: gconstpointer, bytes2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_bytes_compare(bytes1: gconstpointer, bytes2: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_get_charset(charset: *mut *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    pub fn g_get_codeset() -> *mut gchar;
}
extern "C" {
    pub fn g_get_language_names() -> *const *const gchar;
}
extern "C" {
    pub fn g_get_locale_variants(locale: *const gchar) -> *mut *mut gchar;
}
pub const GChecksumType_G_CHECKSUM_MD5: GChecksumType = 0;
pub const GChecksumType_G_CHECKSUM_SHA1: GChecksumType = 1;
pub const GChecksumType_G_CHECKSUM_SHA256: GChecksumType = 2;
pub const GChecksumType_G_CHECKSUM_SHA512: GChecksumType = 3;
pub type GChecksumType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GChecksum {
    _unused: [u8; 0],
}
/// GChecksum:
///
/// An opaque structure representing a checksumming operation.
/// To create a new GChecksum, use g_checksum_new(). To free
/// a GChecksum, use g_checksum_free().
///
/// Since: 2.16
pub type GChecksum = _GChecksum;
extern "C" {
    pub fn g_checksum_type_get_length(checksum_type: GChecksumType) -> gssize;
}
extern "C" {
    pub fn g_checksum_new(checksum_type: GChecksumType) -> *mut GChecksum;
}
extern "C" {
    pub fn g_checksum_reset(checksum: *mut GChecksum);
}
extern "C" {
    pub fn g_checksum_copy(checksum: *const GChecksum) -> *mut GChecksum;
}
extern "C" {
    pub fn g_checksum_free(checksum: *mut GChecksum);
}
extern "C" {
    pub fn g_checksum_update(checksum: *mut GChecksum, data: *const guchar, length: gssize);
}
extern "C" {
    pub fn g_checksum_get_string(checksum: *mut GChecksum) -> *const gchar;
}
extern "C" {
    pub fn g_checksum_get_digest(checksum: *mut GChecksum, buffer: *mut guint8, digest_len: *mut gsize);
}
extern "C" {
    pub fn g_compute_checksum_for_data(checksum_type: GChecksumType, data: *const guchar, length: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_checksum_for_string(checksum_type: GChecksumType, str: *const gchar, length: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_checksum_for_bytes(checksum_type: GChecksumType, data: *mut GBytes) -> *mut gchar;
}
pub const GConvertError_G_CONVERT_ERROR_NO_CONVERSION: GConvertError = 0;
pub const GConvertError_G_CONVERT_ERROR_ILLEGAL_SEQUENCE: GConvertError = 1;
pub const GConvertError_G_CONVERT_ERROR_FAILED: GConvertError = 2;
pub const GConvertError_G_CONVERT_ERROR_PARTIAL_INPUT: GConvertError = 3;
pub const GConvertError_G_CONVERT_ERROR_BAD_URI: GConvertError = 4;
pub const GConvertError_G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: GConvertError = 5;
pub const GConvertError_G_CONVERT_ERROR_NO_MEMORY: GConvertError = 6;
pub type GConvertError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_convert_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIConv {
    _unused: [u8; 0],
}
/// GIConv:
///
/// The GIConv struct wraps an iconv() conversion descriptor. It contains
/// private data and should only be accessed using the following functions.
pub type GIConv = *mut _GIConv;
extern "C" {
    pub fn g_iconv_open(to_codeset: *const gchar, from_codeset: *const gchar) -> GIConv;
}
extern "C" {
    pub fn g_iconv(
        converter: GIConv,
        inbuf: *mut *mut gchar,
        inbytes_left: *mut gsize,
        outbuf: *mut *mut gchar,
        outbytes_left: *mut gsize,
    ) -> gsize;
}
extern "C" {
    pub fn g_iconv_close(converter: GIConv) -> gint;
}
extern "C" {
    pub fn g_convert(
        str: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_convert_with_iconv(
        str: *const gchar,
        len: gssize,
        converter: GIConv,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_convert_with_fallback(
        str: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        fallback: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_locale_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_locale_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_from_uri(uri: *const gchar, hostname: *mut *mut gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_to_uri(filename: *const gchar, hostname: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_display_name(filename: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_get_filename_charsets(charsets: *mut *mut *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_filename_display_basename(filename: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_uri_list_extract_uris(uri_list: *const gchar) -> *mut *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GData {
    _unused: [u8; 0],
}
pub type GData = _GData;
pub type GDataForeachFunc = ::std::option::Option<unsafe extern "C" fn(key_id: GQuark, data: gpointer, user_data: gpointer)>;
extern "C" {
    pub fn g_datalist_init(datalist: *mut *mut GData);
}
extern "C" {
    pub fn g_datalist_clear(datalist: *mut *mut GData);
}
extern "C" {
    pub fn g_datalist_id_get_data(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_datalist_id_set_data_full(datalist: *mut *mut GData, key_id: GQuark, data: gpointer, destroy_func: GDestroyNotify);
}
pub type GDuplicateFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer) -> gpointer>;
extern "C" {
    pub fn g_datalist_id_dup_data(datalist: *mut *mut GData, key_id: GQuark, dup_func: GDuplicateFunc, user_data: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_datalist_id_replace_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    pub fn g_datalist_id_remove_no_notify(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_datalist_foreach(datalist: *mut *mut GData, func: GDataForeachFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_datalist_set_flags(datalist: *mut *mut GData, flags: guint);
}
extern "C" {
    pub fn g_datalist_unset_flags(datalist: *mut *mut GData, flags: guint);
}
extern "C" {
    pub fn g_datalist_get_flags(datalist: *mut *mut GData) -> guint;
}
extern "C" {
    pub fn g_dataset_destroy(dataset_location: gconstpointer);
}
extern "C" {
    pub fn g_dataset_id_get_data(dataset_location: gconstpointer, key_id: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_datalist_get_data(datalist: *mut *mut GData, key: *const gchar) -> gpointer;
}
extern "C" {
    pub fn g_dataset_id_set_data_full(dataset_location: gconstpointer, key_id: GQuark, data: gpointer, destroy_func: GDestroyNotify);
}
extern "C" {
    pub fn g_dataset_id_remove_no_notify(dataset_location: gconstpointer, key_id: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_dataset_foreach(dataset_location: gconstpointer, func: GDataForeachFunc, user_data: gpointer);
}
pub type GTime = gint32;
pub type GDateYear = guint16;
pub type GDateDay = guint8;
pub type GDate = _GDate;
pub const GDateDMY_G_DATE_DAY: GDateDMY = 0;
pub const GDateDMY_G_DATE_MONTH: GDateDMY = 1;
pub const GDateDMY_G_DATE_YEAR: GDateDMY = 2;
pub type GDateDMY = ::std::os::raw::c_uint;
pub const GDateWeekday_G_DATE_BAD_WEEKDAY: GDateWeekday = 0;
pub const GDateWeekday_G_DATE_MONDAY: GDateWeekday = 1;
pub const GDateWeekday_G_DATE_TUESDAY: GDateWeekday = 2;
pub const GDateWeekday_G_DATE_WEDNESDAY: GDateWeekday = 3;
pub const GDateWeekday_G_DATE_THURSDAY: GDateWeekday = 4;
pub const GDateWeekday_G_DATE_FRIDAY: GDateWeekday = 5;
pub const GDateWeekday_G_DATE_SATURDAY: GDateWeekday = 6;
pub const GDateWeekday_G_DATE_SUNDAY: GDateWeekday = 7;
pub type GDateWeekday = ::std::os::raw::c_uint;
pub const GDateMonth_G_DATE_BAD_MONTH: GDateMonth = 0;
pub const GDateMonth_G_DATE_JANUARY: GDateMonth = 1;
pub const GDateMonth_G_DATE_FEBRUARY: GDateMonth = 2;
pub const GDateMonth_G_DATE_MARCH: GDateMonth = 3;
pub const GDateMonth_G_DATE_APRIL: GDateMonth = 4;
pub const GDateMonth_G_DATE_MAY: GDateMonth = 5;
pub const GDateMonth_G_DATE_JUNE: GDateMonth = 6;
pub const GDateMonth_G_DATE_JULY: GDateMonth = 7;
pub const GDateMonth_G_DATE_AUGUST: GDateMonth = 8;
pub const GDateMonth_G_DATE_SEPTEMBER: GDateMonth = 9;
pub const GDateMonth_G_DATE_OCTOBER: GDateMonth = 10;
pub const GDateMonth_G_DATE_NOVEMBER: GDateMonth = 11;
pub const GDateMonth_G_DATE_DECEMBER: GDateMonth = 12;
pub type GDateMonth = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDate {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__GDate() {
    assert_eq!(
        ::std::mem::size_of::<_GDate>(),
        8usize,
        concat!("Size of: ", stringify!(_GDate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDate>(),
        4usize,
        concat!("Alignment of ", stringify!(_GDate))
    );
}
impl _GDate {
    #[inline]
    pub fn julian_days(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_julian_days(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn julian(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_julian(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dmy(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dmy(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn day(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_day(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn month(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_month(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn year(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_year(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        julian_days: guint,
        julian: guint,
        dmy: guint,
        day: guint,
        month: guint,
        year: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u32> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let julian_days: u32 = unsafe { ::std::mem::transmute(julian_days) };
            julian_days as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let julian: u32 = unsafe { ::std::mem::transmute(julian) };
            julian as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let dmy: u32 = unsafe { ::std::mem::transmute(dmy) };
            dmy as u64
        });
        __bindgen_bitfield_unit.set(34usize, 6u8, {
            let day: u32 = unsafe { ::std::mem::transmute(day) };
            day as u64
        });
        __bindgen_bitfield_unit.set(40usize, 4u8, {
            let month: u32 = unsafe { ::std::mem::transmute(month) };
            month as u64
        });
        __bindgen_bitfield_unit.set(44usize, 16u8, {
            let year: u32 = unsafe { ::std::mem::transmute(year) };
            year as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn g_date_new() -> *mut GDate;
}
extern "C" {
    pub fn g_date_new_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> *mut GDate;
}
extern "C" {
    pub fn g_date_new_julian(julian_day: guint32) -> *mut GDate;
}
extern "C" {
    pub fn g_date_free(date: *mut GDate);
}
extern "C" {
    pub fn g_date_valid(date: *const GDate) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_day(day: GDateDay) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_month(month: GDateMonth) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_year(year: GDateYear) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_weekday(weekday: GDateWeekday) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_julian(julian_date: guint32) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> gboolean;
}
extern "C" {
    pub fn g_date_get_weekday(date: *const GDate) -> GDateWeekday;
}
extern "C" {
    pub fn g_date_get_month(date: *const GDate) -> GDateMonth;
}
extern "C" {
    pub fn g_date_get_year(date: *const GDate) -> GDateYear;
}
extern "C" {
    pub fn g_date_get_day(date: *const GDate) -> GDateDay;
}
extern "C" {
    pub fn g_date_get_julian(date: *const GDate) -> guint32;
}
extern "C" {
    pub fn g_date_get_day_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_get_monday_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_get_sunday_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_get_iso8601_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_clear(date: *mut GDate, n_dates: guint);
}
extern "C" {
    pub fn g_date_set_parse(date: *mut GDate, str: *const gchar);
}
extern "C" {
    pub fn g_date_set_time_t(date: *mut GDate, timet: time_t);
}
extern "C" {
    pub fn g_date_set_time_val(date: *mut GDate, timeval: *mut GTimeVal);
}
extern "C" {
    pub fn g_date_set_time(date: *mut GDate, time_: GTime);
}
extern "C" {
    pub fn g_date_set_month(date: *mut GDate, month: GDateMonth);
}
extern "C" {
    pub fn g_date_set_day(date: *mut GDate, day: GDateDay);
}
extern "C" {
    pub fn g_date_set_year(date: *mut GDate, year: GDateYear);
}
extern "C" {
    pub fn g_date_set_dmy(date: *mut GDate, day: GDateDay, month: GDateMonth, y: GDateYear);
}
extern "C" {
    pub fn g_date_set_julian(date: *mut GDate, julian_date: guint32);
}
extern "C" {
    pub fn g_date_is_first_of_month(date: *const GDate) -> gboolean;
}
extern "C" {
    pub fn g_date_is_last_of_month(date: *const GDate) -> gboolean;
}
extern "C" {
    pub fn g_date_add_days(date: *mut GDate, n_days: guint);
}
extern "C" {
    pub fn g_date_subtract_days(date: *mut GDate, n_days: guint);
}
extern "C" {
    pub fn g_date_add_months(date: *mut GDate, n_months: guint);
}
extern "C" {
    pub fn g_date_subtract_months(date: *mut GDate, n_months: guint);
}
extern "C" {
    pub fn g_date_add_years(date: *mut GDate, n_years: guint);
}
extern "C" {
    pub fn g_date_subtract_years(date: *mut GDate, n_years: guint);
}
extern "C" {
    pub fn g_date_is_leap_year(year: GDateYear) -> gboolean;
}
extern "C" {
    pub fn g_date_get_days_in_month(month: GDateMonth, year: GDateYear) -> guint8;
}
extern "C" {
    pub fn g_date_get_monday_weeks_in_year(year: GDateYear) -> guint8;
}
extern "C" {
    pub fn g_date_get_sunday_weeks_in_year(year: GDateYear) -> guint8;
}
extern "C" {
    pub fn g_date_days_between(date1: *const GDate, date2: *const GDate) -> gint;
}
extern "C" {
    pub fn g_date_compare(lhs: *const GDate, rhs: *const GDate) -> gint;
}
extern "C" {
    pub fn g_date_to_struct_tm(date: *const GDate, tm: *mut tm);
}
extern "C" {
    pub fn g_date_clamp(date: *mut GDate, min_date: *const GDate, max_date: *const GDate);
}
extern "C" {
    pub fn g_date_order(date1: *mut GDate, date2: *mut GDate);
}
extern "C" {
    pub fn g_date_strftime(s: *mut gchar, slen: gsize, format: *const gchar, date: *const GDate) -> gsize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeZone {
    _unused: [u8; 0],
}
pub type GTimeZone = _GTimeZone;
pub const GTimeType_G_TIME_TYPE_STANDARD: GTimeType = 0;
pub const GTimeType_G_TIME_TYPE_DAYLIGHT: GTimeType = 1;
pub const GTimeType_G_TIME_TYPE_UNIVERSAL: GTimeType = 2;
pub type GTimeType = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_time_zone_new(identifier: *const gchar) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_new_utc() -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_new_local() -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_ref(tz: *mut GTimeZone) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_unref(tz: *mut GTimeZone);
}
extern "C" {
    pub fn g_time_zone_find_interval(tz: *mut GTimeZone, type_: GTimeType, time_: gint64) -> gint;
}
extern "C" {
    pub fn g_time_zone_adjust_time(tz: *mut GTimeZone, type_: GTimeType, time_: *mut gint64) -> gint;
}
extern "C" {
    pub fn g_time_zone_get_abbreviation(tz: *mut GTimeZone, interval: gint) -> *const gchar;
}
extern "C" {
    pub fn g_time_zone_get_offset(tz: *mut GTimeZone, interval: gint) -> gint32;
}
extern "C" {
    pub fn g_time_zone_is_dst(tz: *mut GTimeZone, interval: gint) -> gboolean;
}
/// GTimeSpan:
///
/// A value representing an interval of time, in microseconds.
///
/// Since: 2.26
pub type GTimeSpan = gint64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDateTime {
    _unused: [u8; 0],
}
/// GDateTime:
///
/// `GDateTime` is an opaque structure whose members
/// cannot be accessed directly.
///
/// Since: 2.26
pub type GDateTime = _GDateTime;
extern "C" {
    pub fn g_date_time_unref(datetime: *mut GDateTime);
}
extern "C" {
    pub fn g_date_time_ref(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_now(tz: *mut GTimeZone) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_now_local() -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_now_utc() -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_unix_local(t: gint64) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_unix_utc(t: gint64) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_timeval_local(tv: *const GTimeVal) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_timeval_utc(tv: *const GTimeVal) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new(
        tz: *mut GTimeZone,
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_local(year: gint, month: gint, day: gint, hour: gint, minute: gint, seconds: gdouble) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_utc(year: gint, month: gint, day: gint, hour: gint, minute: gint, seconds: gdouble) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add(datetime: *mut GDateTime, timespan: GTimeSpan) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_years(datetime: *mut GDateTime, years: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_months(datetime: *mut GDateTime, months: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_weeks(datetime: *mut GDateTime, weeks: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_days(datetime: *mut GDateTime, days: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_hours(datetime: *mut GDateTime, hours: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_minutes(datetime: *mut GDateTime, minutes: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_seconds(datetime: *mut GDateTime, seconds: gdouble) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_full(
        datetime: *mut GDateTime,
        years: gint,
        months: gint,
        days: gint,
        hours: gint,
        minutes: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_compare(dt1: gconstpointer, dt2: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_date_time_difference(end: *mut GDateTime, begin: *mut GDateTime) -> GTimeSpan;
}
extern "C" {
    pub fn g_date_time_hash(datetime: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_date_time_equal(dt1: gconstpointer, dt2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_date_time_get_ymd(datetime: *mut GDateTime, year: *mut gint, month: *mut gint, day: *mut gint);
}
extern "C" {
    pub fn g_date_time_get_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_month(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_day_of_month(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_week_numbering_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_week_of_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_day_of_week(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_day_of_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_hour(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_minute(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_second(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_microsecond(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_seconds(datetime: *mut GDateTime) -> gdouble;
}
extern "C" {
    pub fn g_date_time_to_unix(datetime: *mut GDateTime) -> gint64;
}
extern "C" {
    pub fn g_date_time_to_timeval(datetime: *mut GDateTime, tv: *mut GTimeVal) -> gboolean;
}
extern "C" {
    pub fn g_date_time_get_utc_offset(datetime: *mut GDateTime) -> GTimeSpan;
}
extern "C" {
    pub fn g_date_time_get_timezone_abbreviation(datetime: *mut GDateTime) -> *const gchar;
}
extern "C" {
    pub fn g_date_time_is_daylight_savings(datetime: *mut GDateTime) -> gboolean;
}
extern "C" {
    pub fn g_date_time_to_timezone(datetime: *mut GDateTime, tz: *mut GTimeZone) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_to_local(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_to_utc(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_format(datetime: *mut GDateTime, format: *const gchar) -> *mut gchar;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dirent {
    pub d_ino: __ino_t,
    pub d_off: __off_t,
    pub d_reclen: ::std::os::raw::c_ushort,
    pub d_type: ::std::os::raw::c_uchar,
    pub d_name: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_dirent() {
    assert_eq!(
        ::std::mem::size_of::<dirent>(),
        280usize,
        concat!("Size of: ", stringify!(dirent))
    );
    assert_eq!(
        ::std::mem::align_of::<dirent>(),
        8usize,
        concat!("Alignment of ", stringify!(dirent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_ino as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_off as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_reclen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_reclen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_type as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_name as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_name)
        )
    );
}
pub const DT_UNKNOWN: _bindgen_ty_10 = 0;
pub const DT_FIFO: _bindgen_ty_10 = 1;
pub const DT_CHR: _bindgen_ty_10 = 2;
pub const DT_DIR: _bindgen_ty_10 = 4;
pub const DT_BLK: _bindgen_ty_10 = 6;
pub const DT_REG: _bindgen_ty_10 = 8;
pub const DT_LNK: _bindgen_ty_10 = 10;
pub const DT_SOCK: _bindgen_ty_10 = 12;
pub const DT_WHT: _bindgen_ty_10 = 14;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dirstream {
    _unused: [u8; 0],
}
pub type DIR = __dirstream;
extern "C" {
    pub fn opendir(__name: *const ::std::os::raw::c_char) -> *mut DIR;
}
extern "C" {
    pub fn fdopendir(__fd: ::std::os::raw::c_int) -> *mut DIR;
}
extern "C" {
    pub fn closedir(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readdir(__dirp: *mut DIR) -> *mut dirent;
}
extern "C" {
    pub fn readdir_r(__dirp: *mut DIR, __entry: *mut dirent, __result: *mut *mut dirent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewinddir(__dirp: *mut DIR);
}
extern "C" {
    pub fn seekdir(__dirp: *mut DIR, __pos: ::std::os::raw::c_long);
}
extern "C" {
    pub fn telldir(__dirp: *mut DIR) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn dirfd(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scandir(
        __dir: *const ::std::os::raw::c_char,
        __namelist: *mut *mut *mut dirent,
        __selector: ::std::option::Option<unsafe extern "C" fn(arg1: *const dirent) -> ::std::os::raw::c_int>,
        __cmp: ::std::option::Option<unsafe extern "C" fn(arg1: *mut *const dirent, arg2: *mut *const dirent) -> ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alphasort(__e1: *mut *const dirent, __e2: *mut *const dirent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdirentries(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
        __basep: *mut __off_t,
    ) -> __ssize_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDir {
    _unused: [u8; 0],
}
pub type GDir = _GDir;
extern "C" {
    pub fn g_dir_open(path: *const gchar, flags: guint, error: *mut *mut GError) -> *mut GDir;
}
extern "C" {
    pub fn g_dir_read_name(dir: *mut GDir) -> *const gchar;
}
extern "C" {
    pub fn g_dir_rewind(dir: *mut GDir);
}
extern "C" {
    pub fn g_dir_close(dir: *mut GDir);
}
extern "C" {
    pub fn g_getenv(variable: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_setenv(variable: *const gchar, value: *const gchar, overwrite: gboolean) -> gboolean;
}
extern "C" {
    pub fn g_unsetenv(variable: *const gchar);
}
extern "C" {
    pub fn g_listenv() -> *mut *mut gchar;
}
extern "C" {
    pub fn g_get_environ() -> *mut *mut gchar;
}
extern "C" {
    pub fn g_environ_getenv(envp: *mut *mut gchar, variable: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_environ_setenv(envp: *mut *mut gchar, variable: *const gchar, value: *const gchar, overwrite: gboolean) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_environ_unsetenv(envp: *mut *mut gchar, variable: *const gchar) -> *mut *mut gchar;
}
pub const GFileError_G_FILE_ERROR_EXIST: GFileError = 0;
pub const GFileError_G_FILE_ERROR_ISDIR: GFileError = 1;
pub const GFileError_G_FILE_ERROR_ACCES: GFileError = 2;
pub const GFileError_G_FILE_ERROR_NAMETOOLONG: GFileError = 3;
pub const GFileError_G_FILE_ERROR_NOENT: GFileError = 4;
pub const GFileError_G_FILE_ERROR_NOTDIR: GFileError = 5;
pub const GFileError_G_FILE_ERROR_NXIO: GFileError = 6;
pub const GFileError_G_FILE_ERROR_NODEV: GFileError = 7;
pub const GFileError_G_FILE_ERROR_ROFS: GFileError = 8;
pub const GFileError_G_FILE_ERROR_TXTBSY: GFileError = 9;
pub const GFileError_G_FILE_ERROR_FAULT: GFileError = 10;
pub const GFileError_G_FILE_ERROR_LOOP: GFileError = 11;
pub const GFileError_G_FILE_ERROR_NOSPC: GFileError = 12;
pub const GFileError_G_FILE_ERROR_NOMEM: GFileError = 13;
pub const GFileError_G_FILE_ERROR_MFILE: GFileError = 14;
pub const GFileError_G_FILE_ERROR_NFILE: GFileError = 15;
pub const GFileError_G_FILE_ERROR_BADF: GFileError = 16;
pub const GFileError_G_FILE_ERROR_INVAL: GFileError = 17;
pub const GFileError_G_FILE_ERROR_PIPE: GFileError = 18;
pub const GFileError_G_FILE_ERROR_AGAIN: GFileError = 19;
pub const GFileError_G_FILE_ERROR_INTR: GFileError = 20;
pub const GFileError_G_FILE_ERROR_IO: GFileError = 21;
pub const GFileError_G_FILE_ERROR_PERM: GFileError = 22;
pub const GFileError_G_FILE_ERROR_NOSYS: GFileError = 23;
pub const GFileError_G_FILE_ERROR_FAILED: GFileError = 24;
pub type GFileError = ::std::os::raw::c_uint;
pub const GFileTest_G_FILE_TEST_IS_REGULAR: GFileTest = 1;
pub const GFileTest_G_FILE_TEST_IS_SYMLINK: GFileTest = 2;
pub const GFileTest_G_FILE_TEST_IS_DIR: GFileTest = 4;
pub const GFileTest_G_FILE_TEST_IS_EXECUTABLE: GFileTest = 8;
pub const GFileTest_G_FILE_TEST_EXISTS: GFileTest = 16;
pub type GFileTest = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_file_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_file_error_from_errno(err_no: gint) -> GFileError;
}
extern "C" {
    pub fn g_file_test(filename: *const gchar, test: GFileTest) -> gboolean;
}
extern "C" {
    pub fn g_file_get_contents(filename: *const gchar, contents: *mut *mut gchar, length: *mut gsize, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_file_set_contents(filename: *const gchar, contents: *const gchar, length: gssize, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_file_read_link(filename: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_mkdtemp(tmpl: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_mkdtemp_full(tmpl: *mut gchar, mode: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_mkstemp(tmpl: *mut gchar) -> gint;
}
extern "C" {
    pub fn g_mkstemp_full(tmpl: *mut gchar, flags: gint, mode: gint) -> gint;
}
extern "C" {
    pub fn g_file_open_tmp(tmpl: *const gchar, name_used: *mut *mut gchar, error: *mut *mut GError) -> gint;
}
extern "C" {
    pub fn g_dir_make_tmp(tmpl: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_build_path(separator: *const gchar, first_element: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_build_pathv(separator: *const gchar, args: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_build_filename(first_element: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_build_filenamev(args: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_mkdir_with_parents(pathname: *const gchar, mode: gint) -> gint;
}
extern "C" {
    pub fn g_path_is_absolute(file_name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_path_skip_root(file_name: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_basename(file_name: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_get_current_dir() -> *mut gchar;
}
extern "C" {
    pub fn g_path_get_basename(file_name: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_path_get_dirname(file_name: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strip_context(msgid: *const gchar, msgval: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_dgettext(domain: *const gchar, msgid: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_dcgettext(domain: *const gchar, msgid: *const gchar, category: gint) -> *const gchar;
}
extern "C" {
    pub fn g_dngettext(domain: *const gchar, msgid: *const gchar, msgid_plural: *const gchar, n: gulong) -> *const gchar;
}
extern "C" {
    pub fn g_dpgettext(domain: *const gchar, msgctxtid: *const gchar, msgidoffset: gsize) -> *const gchar;
}
extern "C" {
    pub fn g_dpgettext2(domain: *const gchar, context: *const gchar, msgid: *const gchar) -> *const gchar;
}
/// GMemVTable:
/// @malloc: function to use for allocating memory.
/// @realloc: function to use for reallocating memory.
/// @free: function to use to free memory.
/// @calloc: function to use for allocating zero-filled memory.
/// @try_malloc: function to use for allocating memory without a default error handler.
/// @try_realloc: function to use for reallocating memory without a default error handler.
///
/// A set of functions used to perform memory allocation. The same #GMemVTable must
/// be used for all allocations in the same program; a call to g_mem_set_vtable(),
/// if it exists, should be prior to any use of GLib.
///
/// This functions related to this has been deprecated in 2.46, and no longer work.
pub type GMemVTable = _GMemVTable;
extern "C" {
    pub fn g_free(mem: gpointer);
}
extern "C" {
    pub fn g_clear_pointer(pp: *mut gpointer, destroy: GDestroyNotify);
}
extern "C" {
    pub fn g_malloc(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_malloc0(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc0(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemVTable {
    pub malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub realloc: ::std::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
    pub free: ::std::option::Option<unsafe extern "C" fn(mem: gpointer)>,
    pub calloc: ::std::option::Option<unsafe extern "C" fn(n_blocks: gsize, n_block_bytes: gsize) -> gpointer>,
    pub try_malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub try_realloc: ::std::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
}
#[test]
fn bindgen_test_layout__GMemVTable() {
    assert_eq!(
        ::std::mem::size_of::<_GMemVTable>(),
        48usize,
        concat!("Size of: ", stringify!(_GMemVTable))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMemVTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMemVTable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMemVTable>())).malloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(malloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMemVTable>())).realloc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(realloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMemVTable>())).free as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMemVTable>())).calloc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(calloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMemVTable>())).try_malloc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(try_malloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMemVTable>())).try_realloc as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(try_realloc)
        )
    );
}
extern "C" {
    pub fn g_mem_set_vtable(vtable: *mut GMemVTable);
}
extern "C" {
    pub fn g_mem_is_system_malloc() -> gboolean;
}
extern "C" {
    pub static mut g_mem_gc_friendly: gboolean;
}
extern "C" {
    pub static mut glib_mem_profiler_table: *mut GMemVTable;
}
extern "C" {
    pub fn g_mem_profile();
}
pub type GNode = _GNode;
pub const GTraverseFlags_G_TRAVERSE_LEAVES: GTraverseFlags = 1;
pub const GTraverseFlags_G_TRAVERSE_NON_LEAVES: GTraverseFlags = 2;
pub const GTraverseFlags_G_TRAVERSE_ALL: GTraverseFlags = 3;
pub const GTraverseFlags_G_TRAVERSE_MASK: GTraverseFlags = 3;
pub const GTraverseFlags_G_TRAVERSE_LEAFS: GTraverseFlags = 1;
pub const GTraverseFlags_G_TRAVERSE_NON_LEAFS: GTraverseFlags = 2;
pub type GTraverseFlags = ::std::os::raw::c_uint;
pub const GTraverseType_G_IN_ORDER: GTraverseType = 0;
pub const GTraverseType_G_PRE_ORDER: GTraverseType = 1;
pub const GTraverseType_G_POST_ORDER: GTraverseType = 2;
pub const GTraverseType_G_LEVEL_ORDER: GTraverseType = 3;
pub type GTraverseType = ::std::os::raw::c_uint;
pub type GNodeTraverseFunc = ::std::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer) -> gboolean>;
pub type GNodeForeachFunc = ::std::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer)>;
/// GCopyFunc:
/// @src: (not nullable): A pointer to the data which should be copied
/// @data: Additional data
///
/// A function of this signature is used to copy the node data
/// when doing a deep-copy of a tree.
///
/// Returns: (not nullable): A pointer to the copy
///
/// Since: 2.4
pub type GCopyFunc = ::std::option::Option<unsafe extern "C" fn(src: gconstpointer, data: gpointer) -> gpointer>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNode {
    pub data: gpointer,
    pub next: *mut GNode,
    pub prev: *mut GNode,
    pub parent: *mut GNode,
    pub children: *mut GNode,
}
#[test]
fn bindgen_test_layout__GNode() {
    assert_eq!(
        ::std::mem::size_of::<_GNode>(),
        40usize,
        concat!("Size of: ", stringify!(_GNode))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNode>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GNode>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GNode>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GNode>())).prev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GNode>())).parent as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GNode>())).children as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(children)
        )
    );
}
extern "C" {
    pub fn g_node_new(data: gpointer) -> *mut GNode;
}
extern "C" {
    pub fn g_node_destroy(root: *mut GNode);
}
extern "C" {
    pub fn g_node_unlink(node: *mut GNode);
}
extern "C" {
    pub fn g_node_copy_deep(node: *mut GNode, copy_func: GCopyFunc, data: gpointer) -> *mut GNode;
}
extern "C" {
    pub fn g_node_copy(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_insert(parent: *mut GNode, position: gint, node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_insert_before(parent: *mut GNode, sibling: *mut GNode, node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_insert_after(parent: *mut GNode, sibling: *mut GNode, node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_prepend(parent: *mut GNode, node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_n_nodes(root: *mut GNode, flags: GTraverseFlags) -> guint;
}
extern "C" {
    pub fn g_node_get_root(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_is_ancestor(node: *mut GNode, descendant: *mut GNode) -> gboolean;
}
extern "C" {
    pub fn g_node_depth(node: *mut GNode) -> guint;
}
extern "C" {
    pub fn g_node_find(root: *mut GNode, order: GTraverseType, flags: GTraverseFlags, data: gpointer) -> *mut GNode;
}
extern "C" {
    pub fn g_node_traverse(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        max_depth: gint,
        func: GNodeTraverseFunc,
        data: gpointer,
    );
}
extern "C" {
    pub fn g_node_max_height(root: *mut GNode) -> guint;
}
extern "C" {
    pub fn g_node_children_foreach(node: *mut GNode, flags: GTraverseFlags, func: GNodeForeachFunc, data: gpointer);
}
extern "C" {
    pub fn g_node_reverse_children(node: *mut GNode);
}
extern "C" {
    pub fn g_node_n_children(node: *mut GNode) -> guint;
}
extern "C" {
    pub fn g_node_nth_child(node: *mut GNode, n: guint) -> *mut GNode;
}
extern "C" {
    pub fn g_node_last_child(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_find_child(node: *mut GNode, flags: GTraverseFlags, data: gpointer) -> *mut GNode;
}
extern "C" {
    pub fn g_node_child_position(node: *mut GNode, child: *mut GNode) -> gint;
}
extern "C" {
    pub fn g_node_child_index(node: *mut GNode, data: gpointer) -> gint;
}
extern "C" {
    pub fn g_node_first_sibling(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_last_sibling(node: *mut GNode) -> *mut GNode;
}
pub type GList = _GList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}
#[test]
fn bindgen_test_layout__GList() {
    assert_eq!(
        ::std::mem::size_of::<_GList>(),
        24usize,
        concat!("Size of: ", stringify!(_GList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GList>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GList>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GList>())).prev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(prev)
        )
    );
}
extern "C" {
    pub fn g_list_alloc() -> *mut GList;
}
extern "C" {
    pub fn g_list_free(list: *mut GList);
}
extern "C" {
    pub fn g_list_free_1(list: *mut GList);
}
extern "C" {
    pub fn g_list_free_full(list: *mut GList, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_list_append(list: *mut GList, data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_prepend(list: *mut GList, data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert(list: *mut GList, data: gpointer, position: gint) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_sorted(list: *mut GList, data: gpointer, func: GCompareFunc) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_sorted_with_data(list: *mut GList, data: gpointer, func: GCompareDataFunc, user_data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_before(list: *mut GList, sibling: *mut GList, data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_concat(list1: *mut GList, list2: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_remove(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_remove_all(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_remove_link(list: *mut GList, llink: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_delete_link(list: *mut GList, link_: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_reverse(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_copy(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_copy_deep(list: *mut GList, func: GCopyFunc, user_data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_nth(list: *mut GList, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_list_nth_prev(list: *mut GList, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_list_find(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_find_custom(list: *mut GList, data: gconstpointer, func: GCompareFunc) -> *mut GList;
}
extern "C" {
    pub fn g_list_position(list: *mut GList, llink: *mut GList) -> gint;
}
extern "C" {
    pub fn g_list_index(list: *mut GList, data: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_list_last(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_first(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_length(list: *mut GList) -> guint;
}
extern "C" {
    pub fn g_list_foreach(list: *mut GList, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_list_sort(list: *mut GList, compare_func: GCompareFunc) -> *mut GList;
}
extern "C" {
    pub fn g_list_sort_with_data(list: *mut GList, compare_func: GCompareDataFunc, user_data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_nth_data(list: *mut GList, n: guint) -> gpointer;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTable {
    _unused: [u8; 0],
}
pub type GHashTable = _GHashTable;
pub type GHRFunc = ::std::option::Option<unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer) -> gboolean>;
pub type GHashTableIter = _GHashTableIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTableIter {
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: gpointer,
    pub dummy4: ::std::os::raw::c_int,
    pub dummy5: gboolean,
    pub dummy6: gpointer,
}
#[test]
fn bindgen_test_layout__GHashTableIter() {
    assert_eq!(
        ::std::mem::size_of::<_GHashTableIter>(),
        40usize,
        concat!("Size of: ", stringify!(_GHashTableIter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GHashTableIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHashTableIter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHashTableIter>())).dummy1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHashTableIter>())).dummy2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHashTableIter>())).dummy3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHashTableIter>())).dummy4 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHashTableIter>())).dummy5 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHashTableIter>())).dummy6 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy6)
        )
    );
}
extern "C" {
    pub fn g_hash_table_new(hash_func: GHashFunc, key_equal_func: GEqualFunc) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_new_full(
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_destroy(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_insert(hash_table: *mut GHashTable, key: gpointer, value: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_replace(hash_table: *mut GHashTable, key: gpointer, value: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_add(hash_table: *mut GHashTable, key: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_remove(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_remove_all(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_steal(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_steal_all(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_lookup(hash_table: *mut GHashTable, key: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_hash_table_contains(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_lookup_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_foreach(hash_table: *mut GHashTable, func: GHFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_hash_table_find(hash_table: *mut GHashTable, predicate: GHRFunc, user_data: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_hash_table_foreach_remove(hash_table: *mut GHashTable, func: GHRFunc, user_data: gpointer) -> guint;
}
extern "C" {
    pub fn g_hash_table_foreach_steal(hash_table: *mut GHashTable, func: GHRFunc, user_data: gpointer) -> guint;
}
extern "C" {
    pub fn g_hash_table_size(hash_table: *mut GHashTable) -> guint;
}
extern "C" {
    pub fn g_hash_table_get_keys(hash_table: *mut GHashTable) -> *mut GList;
}
extern "C" {
    pub fn g_hash_table_get_values(hash_table: *mut GHashTable) -> *mut GList;
}
extern "C" {
    pub fn g_hash_table_get_keys_as_array(hash_table: *mut GHashTable, length: *mut guint) -> *mut gpointer;
}
extern "C" {
    pub fn g_hash_table_iter_init(iter: *mut GHashTableIter, hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_iter_next(iter: *mut GHashTableIter, key: *mut gpointer, value: *mut gpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_iter_get_hash_table(iter: *mut GHashTableIter) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_iter_remove(iter: *mut GHashTableIter);
}
extern "C" {
    pub fn g_hash_table_iter_replace(iter: *mut GHashTableIter, value: gpointer);
}
extern "C" {
    pub fn g_hash_table_iter_steal(iter: *mut GHashTableIter);
}
extern "C" {
    pub fn g_hash_table_ref(hash_table: *mut GHashTable) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_unref(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_str_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_str_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_int_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_int_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_int64_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_int64_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_double_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_double_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_direct_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_direct_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHmac {
    _unused: [u8; 0],
}
/// GHmac:
///
/// An opaque structure representing a HMAC operation.
/// To create a new GHmac, use g_hmac_new(). To free
/// a GHmac, use g_hmac_unref().
///
/// Since: 2.30
pub type GHmac = _GHmac;
extern "C" {
    pub fn g_hmac_new(digest_type: GChecksumType, key: *const guchar, key_len: gsize) -> *mut GHmac;
}
extern "C" {
    pub fn g_hmac_copy(hmac: *const GHmac) -> *mut GHmac;
}
extern "C" {
    pub fn g_hmac_ref(hmac: *mut GHmac) -> *mut GHmac;
}
extern "C" {
    pub fn g_hmac_unref(hmac: *mut GHmac);
}
extern "C" {
    pub fn g_hmac_update(hmac: *mut GHmac, data: *const guchar, length: gssize);
}
extern "C" {
    pub fn g_hmac_get_string(hmac: *mut GHmac) -> *const gchar;
}
extern "C" {
    pub fn g_hmac_get_digest(hmac: *mut GHmac, buffer: *mut guint8, digest_len: *mut gsize);
}
extern "C" {
    pub fn g_compute_hmac_for_data(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_hmac_for_string(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        str: *const gchar,
        length: gssize,
    ) -> *mut gchar;
}
pub type GHook = _GHook;
pub type GHookList = _GHookList;
pub type GHookCompareFunc = ::std::option::Option<unsafe extern "C" fn(new_hook: *mut GHook, sibling: *mut GHook) -> gint>;
pub type GHookFindFunc = ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook, data: gpointer) -> gboolean>;
pub type GHookMarshaller = ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer)>;
pub type GHookCheckMarshaller = ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer) -> gboolean>;
pub type GHookFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GHookCheckFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer) -> gboolean>;
pub type GHookFinalizeFunc = ::std::option::Option<unsafe extern "C" fn(hook_list: *mut GHookList, hook: *mut GHook)>;
pub const GHookFlagMask_G_HOOK_FLAG_ACTIVE: GHookFlagMask = 1;
pub const GHookFlagMask_G_HOOK_FLAG_IN_CALL: GHookFlagMask = 2;
pub const GHookFlagMask_G_HOOK_FLAG_MASK: GHookFlagMask = 15;
pub type GHookFlagMask = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHookList {
    pub seq_id: gulong,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub hooks: *mut GHook,
    pub dummy3: gpointer,
    pub finalize_hook: GHookFinalizeFunc,
    pub dummy: [gpointer; 2usize],
}
#[test]
fn bindgen_test_layout__GHookList() {
    assert_eq!(
        ::std::mem::size_of::<_GHookList>(),
        56usize,
        concat!("Size of: ", stringify!(_GHookList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GHookList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHookList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHookList>())).seq_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(seq_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHookList>())).hooks as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(hooks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHookList>())).dummy3 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(dummy3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHookList>())).finalize_hook as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(finalize_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHookList>())).dummy as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(dummy)
        )
    );
}
impl _GHookList {
    #[inline]
    pub fn hook_size(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_hook_size(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn is_setup(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_setup(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(hook_size: guint, is_setup: guint) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let hook_size: u32 = unsafe { ::std::mem::transmute(hook_size) };
            hook_size as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let is_setup: u32 = unsafe { ::std::mem::transmute(is_setup) };
            is_setup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHook {
    pub data: gpointer,
    pub next: *mut GHook,
    pub prev: *mut GHook,
    pub ref_count: guint,
    pub hook_id: gulong,
    pub flags: guint,
    pub func: gpointer,
    pub destroy: GDestroyNotify,
}
#[test]
fn bindgen_test_layout__GHook() {
    assert_eq!(
        ::std::mem::size_of::<_GHook>(),
        64usize,
        concat!("Size of: ", stringify!(_GHook))
    );
    assert_eq!(
        ::std::mem::align_of::<_GHook>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHook))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).prev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).ref_count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).hook_id as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(hook_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).func as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).destroy as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(destroy)
        )
    );
}
extern "C" {
    pub fn g_hook_list_init(hook_list: *mut GHookList, hook_size: guint);
}
extern "C" {
    pub fn g_hook_list_clear(hook_list: *mut GHookList);
}
extern "C" {
    pub fn g_hook_alloc(hook_list: *mut GHookList) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_free(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_ref(hook_list: *mut GHookList, hook: *mut GHook) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_unref(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_destroy(hook_list: *mut GHookList, hook_id: gulong) -> gboolean;
}
extern "C" {
    pub fn g_hook_destroy_link(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_prepend(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_insert_before(hook_list: *mut GHookList, sibling: *mut GHook, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_insert_sorted(hook_list: *mut GHookList, hook: *mut GHook, func: GHookCompareFunc);
}
extern "C" {
    pub fn g_hook_get(hook_list: *mut GHookList, hook_id: gulong) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find(hook_list: *mut GHookList, need_valids: gboolean, func: GHookFindFunc, data: gpointer) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find_data(hook_list: *mut GHookList, need_valids: gboolean, data: gpointer) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find_func(hook_list: *mut GHookList, need_valids: gboolean, func: gpointer) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find_func_data(hook_list: *mut GHookList, need_valids: gboolean, func: gpointer, data: gpointer) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_first_valid(hook_list: *mut GHookList, may_be_in_call: gboolean) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_next_valid(hook_list: *mut GHookList, hook: *mut GHook, may_be_in_call: gboolean) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_compare_ids(new_hook: *mut GHook, sibling: *mut GHook) -> gint;
}
extern "C" {
    pub fn g_hook_list_invoke(hook_list: *mut GHookList, may_recurse: gboolean);
}
extern "C" {
    pub fn g_hook_list_invoke_check(hook_list: *mut GHookList, may_recurse: gboolean);
}
extern "C" {
    pub fn g_hook_list_marshal(hook_list: *mut GHookList, may_recurse: gboolean, marshaller: GHookMarshaller, marshal_data: gpointer);
}
extern "C" {
    pub fn g_hook_list_marshal_check(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookCheckMarshaller,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_hostname_is_non_ascii(hostname: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_hostname_is_ascii_encoded(hostname: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_hostname_is_ip_address(hostname: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_hostname_to_ascii(hostname: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_hostname_to_unicode(hostname: *const gchar) -> *mut gchar;
}
pub type GPollFD = _GPollFD;
/// GPollFunc:
/// @ufds: an array of #GPollFD elements
/// @nfsd: the number of elements in @ufds
/// @timeout_: the maximum time to wait for an event of the file descriptors.
/// A negative value indicates an infinite timeout.
///
/// Specifies the type of function passed to g_main_context_set_poll_func().
/// The semantics of the function should match those of the poll() system call.
///
/// Returns: the number of #GPollFD elements which have events or errors
/// reported, or -1 if an error occurred.
pub type GPollFunc = ::std::option::Option<unsafe extern "C" fn(ufds: *mut GPollFD, nfsd: guint, timeout_: gint) -> gint>;
/// GPollFD:
/// @fd: the file descriptor to poll (or a HANDLE on Win32)
/// @events: a bitwise combination from #GIOCondition, specifying which
/// events should be polled for. Typically for reading from a file
/// descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and
/// for writing you would use %G_IO_OUT | %G_IO_ERR.
/// @revents: a bitwise combination of flags from #GIOCondition, returned
/// from the poll() function to indicate which events occurred.
///
/// Represents a file descriptor, which events to poll for, and which events
/// occurred.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollFD {
    pub fd: gint,
    pub events: gushort,
    pub revents: gushort,
}
#[test]
fn bindgen_test_layout__GPollFD() {
    assert_eq!(
        ::std::mem::size_of::<_GPollFD>(),
        8usize,
        concat!("Size of: ", stringify!(_GPollFD))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPollFD>(),
        4usize,
        concat!("Alignment of ", stringify!(_GPollFD))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPollFD>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPollFD>())).events as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPollFD>())).revents as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(revents)
        )
    );
}
extern "C" {

    /// G_POLLFD_FORMAT:
    ///
    /// A format specifier that can be used in printf()-style format strings
    /// when printing the @fd member of a #GPollFD.
    pub fn g_poll(fds: *mut GPollFD, nfds: guint, timeout: gint) -> gint;
}
pub type GSList = _GSList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}
#[test]
fn bindgen_test_layout__GSList() {
    assert_eq!(
        ::std::mem::size_of::<_GSList>(),
        16usize,
        concat!("Size of: ", stringify!(_GSList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSList>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSList>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSList),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn g_slist_alloc() -> *mut GSList;
}
extern "C" {
    pub fn g_slist_free(list: *mut GSList);
}
extern "C" {
    pub fn g_slist_free_1(list: *mut GSList);
}
extern "C" {
    pub fn g_slist_free_full(list: *mut GSList, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_slist_append(list: *mut GSList, data: gpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_prepend(list: *mut GSList, data: gpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert(list: *mut GSList, data: gpointer, position: gint) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert_sorted(list: *mut GSList, data: gpointer, func: GCompareFunc) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert_sorted_with_data(list: *mut GSList, data: gpointer, func: GCompareDataFunc, user_data: gpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert_before(slist: *mut GSList, sibling: *mut GSList, data: gpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_concat(list1: *mut GSList, list2: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_remove(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_remove_all(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_remove_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_delete_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_reverse(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_copy(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_copy_deep(list: *mut GSList, func: GCopyFunc, user_data: gpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_nth(list: *mut GSList, n: guint) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_find(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_find_custom(list: *mut GSList, data: gconstpointer, func: GCompareFunc) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_position(list: *mut GSList, llink: *mut GSList) -> gint;
}
extern "C" {
    pub fn g_slist_index(list: *mut GSList, data: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_slist_last(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_length(list: *mut GSList) -> guint;
}
extern "C" {
    pub fn g_slist_foreach(list: *mut GSList, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_slist_sort(list: *mut GSList, compare_func: GCompareFunc) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_sort_with_data(list: *mut GSList, compare_func: GCompareDataFunc, user_data: gpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_nth_data(list: *mut GSList, n: guint) -> gpointer;
}
pub const GIOCondition_G_IO_IN: GIOCondition = 1;
pub const GIOCondition_G_IO_OUT: GIOCondition = 4;
pub const GIOCondition_G_IO_PRI: GIOCondition = 2;
pub const GIOCondition_G_IO_ERR: GIOCondition = 8;
pub const GIOCondition_G_IO_HUP: GIOCondition = 16;
pub const GIOCondition_G_IO_NVAL: GIOCondition = 32;
pub type GIOCondition = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainContext {
    _unused: [u8; 0],
}
/// GMainContext:
///
/// The `GMainContext` struct is an opaque data
/// type representing a set of sources to be handled in a main loop.
pub type GMainContext = _GMainContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainLoop {
    _unused: [u8; 0],
}
/// GMainLoop:
///
/// The `GMainLoop` struct is an opaque data type
/// representing the main event loop of a GLib or GTK+ application.
pub type GMainLoop = _GMainLoop;
/// GSource:
///
/// The `GSource` struct is an opaque data type
/// representing an event source.
pub type GSource = _GSource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourcePrivate {
    _unused: [u8; 0],
}
pub type GSourcePrivate = _GSourcePrivate;
/// GSourceCallbackFuncs:
/// @ref: Called when a reference is added to the callback object
/// @unref: Called when a reference to the callback object is dropped
/// @get: Called to extract the callback function and data from the
/// callback object.
///
/// The `GSourceCallbackFuncs` struct contains
/// functions for managing callback objects.
pub type GSourceCallbackFuncs = _GSourceCallbackFuncs;
/// GSourceFuncs:
/// @prepare: Called before all the file descriptors are polled. If the
/// source can determine that it is ready here (without waiting for the
/// results of the poll() call) it should return %TRUE. It can also return
/// a @timeout_ value which should be the maximum timeout (in milliseconds)
/// which should be passed to the poll() call. The actual timeout used will
/// be -1 if all sources returned -1, or it will be the minimum of all
/// the @timeout_ values returned which were >= 0.  Since 2.36 this may
/// be %NULL, in which case the effect is as if the function always returns
/// %FALSE with a timeout of -1.  If @prepare returns a
/// timeout and the source also has a 'ready time' set then the
/// nearer of the two will be used.
/// @check: Called after all the file descriptors are polled. The source
/// should return %TRUE if it is ready to be dispatched. Note that some
/// time may have passed since the previous prepare function was called,
/// so the source should be checked again here.  Since 2.36 this may
/// be %NULL, in which case the effect is as if the function always returns
/// %FALSE.
/// @dispatch: Called to dispatch the event source, after it has returned
/// %TRUE in either its @prepare or its @check function. The @dispatch
/// function is passed in a callback function and data. The callback
/// function may be %NULL if the source was never connected to a callback
/// using g_source_set_callback(). The @dispatch function should call the
/// callback function with @user_data and whatever additional parameters
/// are needed for this type of event source. The return value of the
/// @dispatch function should be #G_SOURCE_REMOVE if the source should be
/// removed or #G_SOURCE_CONTINUE to keep it.
/// @finalize: Called when the source is finalized.
///
/// The `GSourceFuncs` struct contains a table of
/// functions used to handle event sources in a generic manner.
///
/// For idle sources, the prepare and check functions always return %TRUE
/// to indicate that the source is always ready to be processed. The prepare
/// function also returns a timeout value of 0 to ensure that the poll() call
/// doesn't block (since that would be time wasted which could have been spent
/// running the idle function).
///
/// For timeout sources, the prepare and check functions both return %TRUE
/// if the timeout interval has expired. The prepare function also returns
/// a timeout value to ensure that the poll() call doesn't block too long
/// and miss the next timeout.
///
/// For file descriptor sources, the prepare function typically returns %FALSE,
/// since it must wait until poll() has been called before it knows whether
/// any events need to be processed. It sets the returned timeout to -1 to
/// indicate that it doesn't mind how long the poll() call blocks. In the
/// check function, it tests the results of the poll() call to see if the
/// required condition has been met, and returns %TRUE if so.
pub type GSourceFuncs = _GSourceFuncs;
/// GSourceFunc:
/// @user_data: data passed to the function, set when the source was
/// created with one of the above functions
///
/// Specifies the type of function passed to g_timeout_add(),
/// g_timeout_add_full(), g_idle_add(), and g_idle_add_full().
///
/// Returns: %FALSE if the source should be removed. #G_SOURCE_CONTINUE and
/// #G_SOURCE_REMOVE are more memorable names for the return value.
pub type GSourceFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gpointer) -> gboolean>;
/// GChildWatchFunc:
/// @pid: the process id of the child process
/// @status: Status information about the child process, encoded
/// in a platform-specific manner
/// @user_data: user data passed to g_child_watch_add()
///
/// Prototype of a #GChildWatchSource callback, called when a child
/// process has exited.  To interpret @status, see the documentation
/// for g_spawn_check_exit_status().
pub type GChildWatchFunc = ::std::option::Option<unsafe extern "C" fn(pid: GPid, status: gint, user_data: gpointer)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSource {
    pub callback_data: gpointer,
    pub callback_funcs: *mut GSourceCallbackFuncs,
    pub source_funcs: *const GSourceFuncs,
    pub ref_count: guint,
    pub context: *mut GMainContext,
    pub priority: gint,
    pub flags: guint,
    pub source_id: guint,
    pub poll_fds: *mut GSList,
    pub prev: *mut GSource,
    pub next: *mut GSource,
    pub name: *mut ::std::os::raw::c_char,
    pub priv_: *mut GSourcePrivate,
}
#[test]
fn bindgen_test_layout__GSource() {
    assert_eq!(
        ::std::mem::size_of::<_GSource>(),
        96usize,
        concat!("Size of: ", stringify!(_GSource))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSource>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSource))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).callback_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(callback_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).callback_funcs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(callback_funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).source_funcs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(source_funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).ref_count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).context as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).priority as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).source_id as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(source_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).poll_fds as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(poll_fds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).prev as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).next as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).name as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).priv_ as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourceCallbackFuncs {
    pub ref_: ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub unref: ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub get:
        ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer, source: *mut GSource, func: *mut GSourceFunc, data: *mut gpointer)>,
}
#[test]
fn bindgen_test_layout__GSourceCallbackFuncs() {
    assert_eq!(
        ::std::mem::size_of::<_GSourceCallbackFuncs>(),
        24usize,
        concat!("Size of: ", stringify!(_GSourceCallbackFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSourceCallbackFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSourceCallbackFuncs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceCallbackFuncs>())).ref_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceCallbackFuncs>())).unref as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(unref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceCallbackFuncs>())).get as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(get)
        )
    );
}
/// GSourceDummyMarshal:
///
/// This is just a placeholder for #GClosureMarshal,
/// which cannot be used here for dependency reasons.
pub type GSourceDummyMarshal = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourceFuncs {
    pub prepare: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource, timeout_: *mut gint) -> gboolean>,
    pub check: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource) -> gboolean>,
    pub dispatch: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource, callback: GSourceFunc, user_data: gpointer) -> gboolean>,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource)>,
    pub closure_callback: GSourceFunc,
    pub closure_marshal: GSourceDummyMarshal,
}
#[test]
fn bindgen_test_layout__GSourceFuncs() {
    assert_eq!(
        ::std::mem::size_of::<_GSourceFuncs>(),
        48usize,
        concat!("Size of: ", stringify!(_GSourceFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSourceFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSourceFuncs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceFuncs>())).prepare as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(prepare)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceFuncs>())).check as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceFuncs>())).dispatch as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(dispatch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceFuncs>())).finalize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceFuncs>())).closure_callback as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(closure_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceFuncs>())).closure_marshal as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(closure_marshal)
        )
    );
}
extern "C" {
    pub fn g_main_context_new() -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_ref(context: *mut GMainContext) -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_unref(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_default() -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_iteration(context: *mut GMainContext, may_block: gboolean) -> gboolean;
}
extern "C" {
    pub fn g_main_context_pending(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    pub fn g_main_context_find_source_by_id(context: *mut GMainContext, source_id: guint) -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_find_source_by_user_data(context: *mut GMainContext, user_data: gpointer) -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_find_source_by_funcs_user_data(
        context: *mut GMainContext,
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_wakeup(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_acquire(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    pub fn g_main_context_release(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_is_owner(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    pub fn g_main_context_wait(context: *mut GMainContext, cond: *mut GCond, mutex: *mut GMutex) -> gboolean;
}
extern "C" {
    pub fn g_main_context_prepare(context: *mut GMainContext, priority: *mut gint) -> gboolean;
}
extern "C" {
    pub fn g_main_context_query(
        context: *mut GMainContext,
        max_priority: gint,
        timeout_: *mut gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gint;
}
extern "C" {
    pub fn g_main_context_check(context: *mut GMainContext, max_priority: gint, fds: *mut GPollFD, n_fds: gint) -> gint;
}
extern "C" {
    pub fn g_main_context_dispatch(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_set_poll_func(context: *mut GMainContext, func: GPollFunc);
}
extern "C" {
    pub fn g_main_context_get_poll_func(context: *mut GMainContext) -> GPollFunc;
}
extern "C" {
    pub fn g_main_context_add_poll(context: *mut GMainContext, fd: *mut GPollFD, priority: gint);
}
extern "C" {
    pub fn g_main_context_remove_poll(context: *mut GMainContext, fd: *mut GPollFD);
}
extern "C" {
    pub fn g_main_depth() -> gint;
}
extern "C" {
    pub fn g_main_current_source() -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_push_thread_default(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_pop_thread_default(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_get_thread_default() -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_ref_thread_default() -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_loop_new(context: *mut GMainContext, is_running: gboolean) -> *mut GMainLoop;
}
extern "C" {
    pub fn g_main_loop_run(loop_: *mut GMainLoop);
}
extern "C" {
    pub fn g_main_loop_quit(loop_: *mut GMainLoop);
}
extern "C" {
    pub fn g_main_loop_ref(loop_: *mut GMainLoop) -> *mut GMainLoop;
}
extern "C" {
    pub fn g_main_loop_unref(loop_: *mut GMainLoop);
}
extern "C" {
    pub fn g_main_loop_is_running(loop_: *mut GMainLoop) -> gboolean;
}
extern "C" {
    pub fn g_main_loop_get_context(loop_: *mut GMainLoop) -> *mut GMainContext;
}
extern "C" {
    pub fn g_source_new(source_funcs: *mut GSourceFuncs, struct_size: guint) -> *mut GSource;
}
extern "C" {
    pub fn g_source_ref(source: *mut GSource) -> *mut GSource;
}
extern "C" {
    pub fn g_source_unref(source: *mut GSource);
}
extern "C" {
    pub fn g_source_attach(source: *mut GSource, context: *mut GMainContext) -> guint;
}
extern "C" {
    pub fn g_source_destroy(source: *mut GSource);
}
extern "C" {
    pub fn g_source_set_priority(source: *mut GSource, priority: gint);
}
extern "C" {
    pub fn g_source_get_priority(source: *mut GSource) -> gint;
}
extern "C" {
    pub fn g_source_set_can_recurse(source: *mut GSource, can_recurse: gboolean);
}
extern "C" {
    pub fn g_source_get_can_recurse(source: *mut GSource) -> gboolean;
}
extern "C" {
    pub fn g_source_get_id(source: *mut GSource) -> guint;
}
extern "C" {
    pub fn g_source_get_context(source: *mut GSource) -> *mut GMainContext;
}
extern "C" {
    pub fn g_source_set_callback(source: *mut GSource, func: GSourceFunc, data: gpointer, notify: GDestroyNotify);
}
extern "C" {
    pub fn g_source_set_funcs(source: *mut GSource, funcs: *mut GSourceFuncs);
}
extern "C" {
    pub fn g_source_is_destroyed(source: *mut GSource) -> gboolean;
}
extern "C" {
    pub fn g_source_set_name(source: *mut GSource, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_source_get_name(source: *mut GSource) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_source_set_name_by_id(tag: guint, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_source_set_ready_time(source: *mut GSource, ready_time: gint64);
}
extern "C" {
    pub fn g_source_get_ready_time(source: *mut GSource) -> gint64;
}
extern "C" {
    pub fn g_source_add_unix_fd(source: *mut GSource, fd: gint, events: GIOCondition) -> gpointer;
}
extern "C" {
    pub fn g_source_modify_unix_fd(source: *mut GSource, tag: gpointer, new_events: GIOCondition);
}
extern "C" {
    pub fn g_source_remove_unix_fd(source: *mut GSource, tag: gpointer);
}
extern "C" {
    pub fn g_source_query_unix_fd(source: *mut GSource, tag: gpointer) -> GIOCondition;
}
extern "C" {
    pub fn g_source_set_callback_indirect(source: *mut GSource, callback_data: gpointer, callback_funcs: *mut GSourceCallbackFuncs);
}
extern "C" {
    pub fn g_source_add_poll(source: *mut GSource, fd: *mut GPollFD);
}
extern "C" {
    pub fn g_source_remove_poll(source: *mut GSource, fd: *mut GPollFD);
}
extern "C" {
    pub fn g_source_add_child_source(source: *mut GSource, child_source: *mut GSource);
}
extern "C" {
    pub fn g_source_remove_child_source(source: *mut GSource, child_source: *mut GSource);
}
extern "C" {
    pub fn g_source_get_current_time(source: *mut GSource, timeval: *mut GTimeVal);
}
extern "C" {
    pub fn g_source_get_time(source: *mut GSource) -> gint64;
}
extern "C" {
    pub fn g_idle_source_new() -> *mut GSource;
}
extern "C" {
    pub fn g_child_watch_source_new(pid: GPid) -> *mut GSource;
}
extern "C" {
    pub fn g_timeout_source_new(interval: guint) -> *mut GSource;
}
extern "C" {
    pub fn g_timeout_source_new_seconds(interval: guint) -> *mut GSource;
}
extern "C" {
    pub fn g_get_current_time(result: *mut GTimeVal);
}
extern "C" {
    pub fn g_get_monotonic_time() -> gint64;
}
extern "C" {
    pub fn g_get_real_time() -> gint64;
}
extern "C" {
    pub fn g_source_remove(tag: guint) -> gboolean;
}
extern "C" {
    pub fn g_source_remove_by_user_data(user_data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_source_remove_by_funcs_user_data(funcs: *mut GSourceFuncs, user_data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_timeout_add_full(priority: gint, interval: guint, function: GSourceFunc, data: gpointer, notify: GDestroyNotify) -> guint;
}
extern "C" {
    pub fn g_timeout_add(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_timeout_add_seconds_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_timeout_add_seconds(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_child_watch_add_full(priority: gint, pid: GPid, function: GChildWatchFunc, data: gpointer, notify: GDestroyNotify) -> guint;
}
extern "C" {
    pub fn g_child_watch_add(pid: GPid, function: GChildWatchFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_idle_add(function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_idle_add_full(priority: gint, function: GSourceFunc, data: gpointer, notify: GDestroyNotify) -> guint;
}
extern "C" {
    pub fn g_idle_remove_by_data(data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_main_context_invoke_full(
        context: *mut GMainContext,
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_main_context_invoke(context: *mut GMainContext, function: GSourceFunc, data: gpointer);
}
extern "C" {
    pub static mut g_timeout_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_child_watch_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_idle_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_unix_signal_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_unix_fd_source_funcs: GSourceFuncs;
}
/// gunichar:
///
/// A type which can hold any UTF-32 or UCS-4 character code,
/// also known as a Unicode code point.
///
/// If you want to produce the UTF-8 representation of a #gunichar,
/// use g_ucs4_to_utf8(). See also g_utf8_to_ucs4() for the reverse
/// process.
///
/// To print/scan values of this type as integer, use
/// %G_GINT32_MODIFIER and/or %G_GUINT32_FORMAT.
///
/// The notation to express a Unicode code point in running text is
/// as a hexadecimal number with four to six digits and uppercase
/// letters, prefixed by the string "U+". Leading zeros are omitted,
/// unless the code point would have fewer than four hexadecimal digits.
/// For example, "U+0041 LATIN CAPITAL LETTER A". To print a code point
/// in the U+-notation, use the format string "U+\%04"G_GINT32_FORMAT"X".
/// To scan, use the format string "U+\%06"G_GINT32_FORMAT"X".
///
/// |[
/// gunichar c;
/// sscanf ("U+0041", "U+%06"G_GINT32_FORMAT"X", &amp;c)
/// g_print ("Read U+%04"G_GINT32_FORMAT"X", c);
/// ]|
pub type gunichar = guint32;
/// gunichar2:
///
/// A type which can hold any UTF-16 code
/// point<footnote id="utf16_surrogate_pairs">UTF-16 also has so called
/// <firstterm>surrogate pairs</firstterm> to encode characters beyond
/// the BMP as pairs of 16bit numbers. Surrogate pairs cannot be stored
/// in a single gunichar2 field, but all GLib functions accepting gunichar2
/// arrays will correctly interpret surrogate pairs.</footnote>.
///
/// To print/scan values of this type to/from text you need to convert
/// to/from UTF-8, using g_utf16_to_utf8()/g_utf8_to_utf16().
///
/// To print/scan values of this type as integer, use
/// %G_GINT16_MODIFIER and/or %G_GUINT16_FORMAT.
pub type gunichar2 = guint16;
pub const GUnicodeType_G_UNICODE_CONTROL: GUnicodeType = 0;
pub const GUnicodeType_G_UNICODE_FORMAT: GUnicodeType = 1;
pub const GUnicodeType_G_UNICODE_UNASSIGNED: GUnicodeType = 2;
pub const GUnicodeType_G_UNICODE_PRIVATE_USE: GUnicodeType = 3;
pub const GUnicodeType_G_UNICODE_SURROGATE: GUnicodeType = 4;
pub const GUnicodeType_G_UNICODE_LOWERCASE_LETTER: GUnicodeType = 5;
pub const GUnicodeType_G_UNICODE_MODIFIER_LETTER: GUnicodeType = 6;
pub const GUnicodeType_G_UNICODE_OTHER_LETTER: GUnicodeType = 7;
pub const GUnicodeType_G_UNICODE_TITLECASE_LETTER: GUnicodeType = 8;
pub const GUnicodeType_G_UNICODE_UPPERCASE_LETTER: GUnicodeType = 9;
pub const GUnicodeType_G_UNICODE_SPACING_MARK: GUnicodeType = 10;
pub const GUnicodeType_G_UNICODE_ENCLOSING_MARK: GUnicodeType = 11;
pub const GUnicodeType_G_UNICODE_NON_SPACING_MARK: GUnicodeType = 12;
pub const GUnicodeType_G_UNICODE_DECIMAL_NUMBER: GUnicodeType = 13;
pub const GUnicodeType_G_UNICODE_LETTER_NUMBER: GUnicodeType = 14;
pub const GUnicodeType_G_UNICODE_OTHER_NUMBER: GUnicodeType = 15;
pub const GUnicodeType_G_UNICODE_CONNECT_PUNCTUATION: GUnicodeType = 16;
pub const GUnicodeType_G_UNICODE_DASH_PUNCTUATION: GUnicodeType = 17;
pub const GUnicodeType_G_UNICODE_CLOSE_PUNCTUATION: GUnicodeType = 18;
pub const GUnicodeType_G_UNICODE_FINAL_PUNCTUATION: GUnicodeType = 19;
pub const GUnicodeType_G_UNICODE_INITIAL_PUNCTUATION: GUnicodeType = 20;
pub const GUnicodeType_G_UNICODE_OTHER_PUNCTUATION: GUnicodeType = 21;
pub const GUnicodeType_G_UNICODE_OPEN_PUNCTUATION: GUnicodeType = 22;
pub const GUnicodeType_G_UNICODE_CURRENCY_SYMBOL: GUnicodeType = 23;
pub const GUnicodeType_G_UNICODE_MODIFIER_SYMBOL: GUnicodeType = 24;
pub const GUnicodeType_G_UNICODE_MATH_SYMBOL: GUnicodeType = 25;
pub const GUnicodeType_G_UNICODE_OTHER_SYMBOL: GUnicodeType = 26;
pub const GUnicodeType_G_UNICODE_LINE_SEPARATOR: GUnicodeType = 27;
pub const GUnicodeType_G_UNICODE_PARAGRAPH_SEPARATOR: GUnicodeType = 28;
pub const GUnicodeType_G_UNICODE_SPACE_SEPARATOR: GUnicodeType = 29;
pub type GUnicodeType = ::std::os::raw::c_uint;
pub const GUnicodeBreakType_G_UNICODE_BREAK_MANDATORY: GUnicodeBreakType = 0;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CARRIAGE_RETURN: GUnicodeBreakType = 1;
pub const GUnicodeBreakType_G_UNICODE_BREAK_LINE_FEED: GUnicodeBreakType = 2;
pub const GUnicodeBreakType_G_UNICODE_BREAK_COMBINING_MARK: GUnicodeBreakType = 3;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SURROGATE: GUnicodeBreakType = 4;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ZERO_WIDTH_SPACE: GUnicodeBreakType = 5;
pub const GUnicodeBreakType_G_UNICODE_BREAK_INSEPARABLE: GUnicodeBreakType = 6;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_BREAKING_GLUE: GUnicodeBreakType = 7;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CONTINGENT: GUnicodeBreakType = 8;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SPACE: GUnicodeBreakType = 9;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AFTER: GUnicodeBreakType = 10;
pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE: GUnicodeBreakType = 11;
pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE_AND_AFTER: GUnicodeBreakType = 12;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HYPHEN: GUnicodeBreakType = 13;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_STARTER: GUnicodeBreakType = 14;
pub const GUnicodeBreakType_G_UNICODE_BREAK_OPEN_PUNCTUATION: GUnicodeBreakType = 15;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PUNCTUATION: GUnicodeBreakType = 16;
pub const GUnicodeBreakType_G_UNICODE_BREAK_QUOTATION: GUnicodeBreakType = 17;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EXCLAMATION: GUnicodeBreakType = 18;
pub const GUnicodeBreakType_G_UNICODE_BREAK_IDEOGRAPHIC: GUnicodeBreakType = 19;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NUMERIC: GUnicodeBreakType = 20;
pub const GUnicodeBreakType_G_UNICODE_BREAK_INFIX_SEPARATOR: GUnicodeBreakType = 21;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SYMBOL: GUnicodeBreakType = 22;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ALPHABETIC: GUnicodeBreakType = 23;
pub const GUnicodeBreakType_G_UNICODE_BREAK_PREFIX: GUnicodeBreakType = 24;
pub const GUnicodeBreakType_G_UNICODE_BREAK_POSTFIX: GUnicodeBreakType = 25;
pub const GUnicodeBreakType_G_UNICODE_BREAK_COMPLEX_CONTEXT: GUnicodeBreakType = 26;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AMBIGUOUS: GUnicodeBreakType = 27;
pub const GUnicodeBreakType_G_UNICODE_BREAK_UNKNOWN: GUnicodeBreakType = 28;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NEXT_LINE: GUnicodeBreakType = 29;
pub const GUnicodeBreakType_G_UNICODE_BREAK_WORD_JOINER: GUnicodeBreakType = 30;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_L_JAMO: GUnicodeBreakType = 31;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_V_JAMO: GUnicodeBreakType = 32;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_T_JAMO: GUnicodeBreakType = 33;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: GUnicodeBreakType = 34;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: GUnicodeBreakType = 35;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PARANTHESIS: GUnicodeBreakType = 36;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: GUnicodeBreakType = 37;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HEBREW_LETTER: GUnicodeBreakType = 38;
pub const GUnicodeBreakType_G_UNICODE_BREAK_REGIONAL_INDICATOR: GUnicodeBreakType = 39;
pub type GUnicodeBreakType = ::std::os::raw::c_uint;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INVALID_CODE: GUnicodeScript = -1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COMMON: GUnicodeScript = 0;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INHERITED: GUnicodeScript = 1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARABIC: GUnicodeScript = 2;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARMENIAN: GUnicodeScript = 3;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BENGALI: GUnicodeScript = 4;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BOPOMOFO: GUnicodeScript = 5;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHEROKEE: GUnicodeScript = 6;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COPTIC: GUnicodeScript = 7;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYRILLIC: GUnicodeScript = 8;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DESERET: GUnicodeScript = 9;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DEVANAGARI: GUnicodeScript = 10;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ETHIOPIC: GUnicodeScript = 11;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GEORGIAN: GUnicodeScript = 12;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GOTHIC: GUnicodeScript = 13;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GREEK: GUnicodeScript = 14;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GUJARATI: GUnicodeScript = 15;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GURMUKHI: GUnicodeScript = 16;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HAN: GUnicodeScript = 17;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANGUL: GUnicodeScript = 18;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HEBREW: GUnicodeScript = 19;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HIRAGANA: GUnicodeScript = 20;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KANNADA: GUnicodeScript = 21;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KATAKANA: GUnicodeScript = 22;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHMER: GUnicodeScript = 23;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LAO: GUnicodeScript = 24;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LATIN: GUnicodeScript = 25;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MALAYALAM: GUnicodeScript = 26;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MONGOLIAN: GUnicodeScript = 27;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MYANMAR: GUnicodeScript = 28;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OGHAM: GUnicodeScript = 29;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_ITALIC: GUnicodeScript = 30;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ORIYA: GUnicodeScript = 31;
pub const GUnicodeScript_G_UNICODE_SCRIPT_RUNIC: GUnicodeScript = 32;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SINHALA: GUnicodeScript = 33;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYRIAC: GUnicodeScript = 34;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAMIL: GUnicodeScript = 35;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TELUGU: GUnicodeScript = 36;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAANA: GUnicodeScript = 37;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAI: GUnicodeScript = 38;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIBETAN: GUnicodeScript = 39;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL: GUnicodeScript = 40;
pub const GUnicodeScript_G_UNICODE_SCRIPT_YI: GUnicodeScript = 41;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGALOG: GUnicodeScript = 42;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANUNOO: GUnicodeScript = 43;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUHID: GUnicodeScript = 44;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGBANWA: GUnicodeScript = 45;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAILLE: GUnicodeScript = 46;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYPRIOT: GUnicodeScript = 47;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LIMBU: GUnicodeScript = 48;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OSMANYA: GUnicodeScript = 49;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHAVIAN: GUnicodeScript = 50;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_B: GUnicodeScript = 51;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_LE: GUnicodeScript = 52;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UGARITIC: GUnicodeScript = 53;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NEW_TAI_LUE: GUnicodeScript = 54;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUGINESE: GUnicodeScript = 55;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GLAGOLITIC: GUnicodeScript = 56;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIFINAGH: GUnicodeScript = 57;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYLOTI_NAGRI: GUnicodeScript = 58;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERSIAN: GUnicodeScript = 59;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHAROSHTHI: GUnicodeScript = 60;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UNKNOWN: GUnicodeScript = 61;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BALINESE: GUnicodeScript = 62;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CUNEIFORM: GUnicodeScript = 63;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHOENICIAN: GUnicodeScript = 64;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHAGS_PA: GUnicodeScript = 65;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NKO: GUnicodeScript = 66;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAYAH_LI: GUnicodeScript = 67;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LEPCHA: GUnicodeScript = 68;
pub const GUnicodeScript_G_UNICODE_SCRIPT_REJANG: GUnicodeScript = 69;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SUNDANESE: GUnicodeScript = 70;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAURASHTRA: GUnicodeScript = 71;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAM: GUnicodeScript = 72;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OL_CHIKI: GUnicodeScript = 73;
pub const GUnicodeScript_G_UNICODE_SCRIPT_VAI: GUnicodeScript = 74;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CARIAN: GUnicodeScript = 75;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYCIAN: GUnicodeScript = 76;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYDIAN: GUnicodeScript = 77;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AVESTAN: GUnicodeScript = 78;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BAMUM: GUnicodeScript = 79;
pub const GUnicodeScript_G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS: GUnicodeScript = 80;
pub const GUnicodeScript_G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC: GUnicodeScript = 81;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI: GUnicodeScript = 82;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN: GUnicodeScript = 83;
pub const GUnicodeScript_G_UNICODE_SCRIPT_JAVANESE: GUnicodeScript = 84;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAITHI: GUnicodeScript = 85;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LISU: GUnicodeScript = 86;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEETEI_MAYEK: GUnicodeScript = 87;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN: GUnicodeScript = 88;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_TURKIC: GUnicodeScript = 89;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAMARITAN: GUnicodeScript = 90;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_THAM: GUnicodeScript = 91;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_VIET: GUnicodeScript = 92;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BATAK: GUnicodeScript = 93;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAHMI: GUnicodeScript = 94;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANDAIC: GUnicodeScript = 95;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAKMA: GUnicodeScript = 96;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_CURSIVE: GUnicodeScript = 97;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: GUnicodeScript = 98;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MIAO: GUnicodeScript = 99;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHARADA: GUnicodeScript = 100;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SORA_SOMPENG: GUnicodeScript = 101;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAKRI: GUnicodeScript = 102;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BASSA_VAH: GUnicodeScript = 103;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN: GUnicodeScript = 104;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DUPLOYAN: GUnicodeScript = 105;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ELBASAN: GUnicodeScript = 106;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GRANTHA: GUnicodeScript = 107;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHOJKI: GUnicodeScript = 108;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHUDAWADI: GUnicodeScript = 109;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_A: GUnicodeScript = 110;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MAHAJANI: GUnicodeScript = 111;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANICHAEAN: GUnicodeScript = 112;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MENDE_KIKAKUI: GUnicodeScript = 113;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MODI: GUnicodeScript = 114;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MRO: GUnicodeScript = 115;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NABATAEAN: GUnicodeScript = 116;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN: GUnicodeScript = 117;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERMIC: GUnicodeScript = 118;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAHAWH_HMONG: GUnicodeScript = 119;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PALMYRENE: GUnicodeScript = 120;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAU_CIN_HAU: GUnicodeScript = 121;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PSALTER_PAHLAVI: GUnicodeScript = 122;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIDDHAM: GUnicodeScript = 123;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIRHUTA: GUnicodeScript = 124;
pub const GUnicodeScript_G_UNICODE_SCRIPT_WARANG_CITI: GUnicodeScript = 125;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AHOM: GUnicodeScript = 126;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: GUnicodeScript = 127;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HATRAN: GUnicodeScript = 128;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MULTANI: GUnicodeScript = 129;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_HUNGARIAN: GUnicodeScript = 130;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIGNWRITING: GUnicodeScript = 131;
pub type GUnicodeScript = ::std::os::raw::c_int;
extern "C" {
    pub fn g_unicode_script_to_iso15924(script: GUnicodeScript) -> guint32;
}
extern "C" {
    pub fn g_unicode_script_from_iso15924(iso15924: guint32) -> GUnicodeScript;
}
extern "C" {
    pub fn g_unichar_isalnum(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isalpha(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iscntrl(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isdigit(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isgraph(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_islower(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isprint(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_ispunct(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isspace(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isupper(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isxdigit(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_istitle(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isdefined(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iswide(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iswide_cjk(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iszerowidth(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_ismark(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_toupper(c: gunichar) -> gunichar;
}
extern "C" {
    pub fn g_unichar_tolower(c: gunichar) -> gunichar;
}
extern "C" {
    pub fn g_unichar_totitle(c: gunichar) -> gunichar;
}
extern "C" {
    pub fn g_unichar_digit_value(c: gunichar) -> gint;
}
extern "C" {
    pub fn g_unichar_xdigit_value(c: gunichar) -> gint;
}
extern "C" {
    pub fn g_unichar_type(c: gunichar) -> GUnicodeType;
}
extern "C" {
    pub fn g_unichar_break_type(c: gunichar) -> GUnicodeBreakType;
}
extern "C" {
    pub fn g_unichar_combining_class(uc: gunichar) -> gint;
}
extern "C" {
    pub fn g_unichar_get_mirror_char(ch: gunichar, mirrored_ch: *mut gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_get_script(ch: gunichar) -> GUnicodeScript;
}
extern "C" {
    pub fn g_unichar_validate(ch: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_compose(a: gunichar, b: gunichar, ch: *mut gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_decompose(ch: gunichar, a: *mut gunichar, b: *mut gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_fully_decompose(ch: gunichar, compat: gboolean, result: *mut gunichar, result_len: gsize) -> gsize;
}
extern "C" {
    pub fn g_unicode_canonical_ordering(string: *mut gunichar, len: gsize);
}
extern "C" {
    pub fn g_unicode_canonical_decomposition(ch: gunichar, result_len: *mut gsize) -> *mut gunichar;
}
extern "C" {
    pub static mut g_utf8_skip: *const gchar;
}
extern "C" {
    pub fn g_utf8_get_char(p: *const gchar) -> gunichar;
}
extern "C" {
    pub fn g_utf8_get_char_validated(p: *const gchar, max_len: gssize) -> gunichar;
}
extern "C" {
    pub fn g_utf8_offset_to_pointer(str: *const gchar, offset: glong) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_pointer_to_offset(str: *const gchar, pos: *const gchar) -> glong;
}
extern "C" {
    pub fn g_utf8_prev_char(p: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_find_next_char(p: *const gchar, end: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_find_prev_char(str: *const gchar, p: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strlen(p: *const gchar, max: gssize) -> glong;
}
extern "C" {
    pub fn g_utf8_substring(str: *const gchar, start_pos: glong, end_pos: glong) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strncpy(dest: *mut gchar, src: *const gchar, n: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strrchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strreverse(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_to_utf16(
        str: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
extern "C" {
    pub fn g_utf8_to_ucs4(
        str: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
extern "C" {
    pub fn g_utf8_to_ucs4_fast(str: *const gchar, len: glong, items_written: *mut glong) -> *mut gunichar;
}
extern "C" {
    pub fn g_utf16_to_ucs4(
        str: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
extern "C" {
    pub fn g_utf16_to_utf8(
        str: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_ucs4_to_utf16(
        str: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
extern "C" {
    pub fn g_ucs4_to_utf8(
        str: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_unichar_to_utf8(c: gunichar, outbuf: *mut gchar) -> gint;
}
extern "C" {
    pub fn g_utf8_validate(str: *const gchar, max_len: gssize, end: *mut *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_utf8_strup(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strdown(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_casefold(str: *const gchar, len: gssize) -> *mut gchar;
}
pub const GNormalizeMode_G_NORMALIZE_DEFAULT: GNormalizeMode = 0;
pub const GNormalizeMode_G_NORMALIZE_NFD: GNormalizeMode = 0;
pub const GNormalizeMode_G_NORMALIZE_DEFAULT_COMPOSE: GNormalizeMode = 1;
pub const GNormalizeMode_G_NORMALIZE_NFC: GNormalizeMode = 1;
pub const GNormalizeMode_G_NORMALIZE_ALL: GNormalizeMode = 2;
pub const GNormalizeMode_G_NORMALIZE_NFKD: GNormalizeMode = 2;
pub const GNormalizeMode_G_NORMALIZE_ALL_COMPOSE: GNormalizeMode = 3;
pub const GNormalizeMode_G_NORMALIZE_NFKC: GNormalizeMode = 3;
pub type GNormalizeMode = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_utf8_normalize(str: *const gchar, len: gssize, mode: GNormalizeMode) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_collate(str1: *const gchar, str2: *const gchar) -> gint;
}
extern "C" {
    pub fn g_utf8_collate_key(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_collate_key_for_filename(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn _g_utf8_make_valid(name: *const gchar) -> *mut gchar;
}
pub type GString = _GString;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GString {
    pub str: *mut gchar,
    pub len: gsize,
    pub allocated_len: gsize,
}
#[test]
fn bindgen_test_layout__GString() {
    assert_eq!(
        ::std::mem::size_of::<_GString>(),
        24usize,
        concat!("Size of: ", stringify!(_GString))
    );
    assert_eq!(
        ::std::mem::align_of::<_GString>(),
        8usize,
        concat!("Alignment of ", stringify!(_GString))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GString>())).str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GString>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GString>())).allocated_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(allocated_len)
        )
    );
}
extern "C" {
    pub fn g_string_new(init: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_new_len(init: *const gchar, len: gssize) -> *mut GString;
}
extern "C" {
    pub fn g_string_sized_new(dfl_size: gsize) -> *mut GString;
}
extern "C" {
    pub fn g_string_free(string: *mut GString, free_segment: gboolean) -> *mut gchar;
}
extern "C" {
    pub fn g_string_free_to_bytes(string: *mut GString) -> *mut GBytes;
}
extern "C" {
    pub fn g_string_equal(v: *const GString, v2: *const GString) -> gboolean;
}
extern "C" {
    pub fn g_string_hash(str: *const GString) -> guint;
}
extern "C" {
    pub fn g_string_assign(string: *mut GString, rval: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_truncate(string: *mut GString, len: gsize) -> *mut GString;
}
extern "C" {
    pub fn g_string_set_size(string: *mut GString, len: gsize) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert_len(string: *mut GString, pos: gssize, val: *const gchar, len: gssize) -> *mut GString;
}
extern "C" {
    pub fn g_string_append(string: *mut GString, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_append_len(string: *mut GString, val: *const gchar, len: gssize) -> *mut GString;
}
extern "C" {
    pub fn g_string_append_c(string: *mut GString, c: gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_append_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend(string: *mut GString, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend_c(string: *mut GString, c: gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend_len(string: *mut GString, val: *const gchar, len: gssize) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert(string: *mut GString, pos: gssize, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert_c(string: *mut GString, pos: gssize, c: gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert_unichar(string: *mut GString, pos: gssize, wc: gunichar) -> *mut GString;
}
extern "C" {
    pub fn g_string_overwrite(string: *mut GString, pos: gsize, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_overwrite_len(string: *mut GString, pos: gsize, val: *const gchar, len: gssize) -> *mut GString;
}
extern "C" {
    pub fn g_string_erase(string: *mut GString, pos: gssize, len: gssize) -> *mut GString;
}
extern "C" {
    pub fn g_string_ascii_down(string: *mut GString) -> *mut GString;
}
extern "C" {
    pub fn g_string_ascii_up(string: *mut GString) -> *mut GString;
}
extern "C" {
    pub fn g_string_vprintf(string: *mut GString, format: *const gchar, args: *mut __va_list_tag);
}
extern "C" {
    pub fn g_string_printf(string: *mut GString, format: *const gchar, ...);
}
extern "C" {
    pub fn g_string_append_vprintf(string: *mut GString, format: *const gchar, args: *mut __va_list_tag);
}
extern "C" {
    pub fn g_string_append_printf(string: *mut GString, format: *const gchar, ...);
}
extern "C" {
    pub fn g_string_append_uri_escaped(
        string: *mut GString,
        unescaped: *const gchar,
        reserved_chars_allowed: *const gchar,
        allow_utf8: gboolean,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_down(string: *mut GString) -> *mut GString;
}
extern "C" {
    pub fn g_string_up(string: *mut GString) -> *mut GString;
}
pub type GIOChannel = _GIOChannel;
pub type GIOFuncs = _GIOFuncs;
pub const GIOError_G_IO_ERROR_NONE: GIOError = 0;
pub const GIOError_G_IO_ERROR_AGAIN: GIOError = 1;
pub const GIOError_G_IO_ERROR_INVAL: GIOError = 2;
pub const GIOError_G_IO_ERROR_UNKNOWN: GIOError = 3;
pub type GIOError = ::std::os::raw::c_uint;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_FBIG: GIOChannelError = 0;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_INVAL: GIOChannelError = 1;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_IO: GIOChannelError = 2;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_ISDIR: GIOChannelError = 3;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_NOSPC: GIOChannelError = 4;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_NXIO: GIOChannelError = 5;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_OVERFLOW: GIOChannelError = 6;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_PIPE: GIOChannelError = 7;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_FAILED: GIOChannelError = 8;
pub type GIOChannelError = ::std::os::raw::c_uint;
pub const GIOStatus_G_IO_STATUS_ERROR: GIOStatus = 0;
pub const GIOStatus_G_IO_STATUS_NORMAL: GIOStatus = 1;
pub const GIOStatus_G_IO_STATUS_EOF: GIOStatus = 2;
pub const GIOStatus_G_IO_STATUS_AGAIN: GIOStatus = 3;
pub type GIOStatus = ::std::os::raw::c_uint;
pub const GSeekType_G_SEEK_CUR: GSeekType = 0;
pub const GSeekType_G_SEEK_SET: GSeekType = 1;
pub const GSeekType_G_SEEK_END: GSeekType = 2;
pub type GSeekType = ::std::os::raw::c_uint;
pub const GIOFlags_G_IO_FLAG_APPEND: GIOFlags = 1;
pub const GIOFlags_G_IO_FLAG_NONBLOCK: GIOFlags = 2;
pub const GIOFlags_G_IO_FLAG_IS_READABLE: GIOFlags = 4;
pub const GIOFlags_G_IO_FLAG_IS_WRITABLE: GIOFlags = 8;
pub const GIOFlags_G_IO_FLAG_IS_WRITEABLE: GIOFlags = 8;
pub const GIOFlags_G_IO_FLAG_IS_SEEKABLE: GIOFlags = 16;
pub const GIOFlags_G_IO_FLAG_MASK: GIOFlags = 31;
pub const GIOFlags_G_IO_FLAG_GET_MASK: GIOFlags = 31;
pub const GIOFlags_G_IO_FLAG_SET_MASK: GIOFlags = 3;
pub type GIOFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOChannel {
    pub ref_count: gint,
    pub funcs: *mut GIOFuncs,
    pub encoding: *mut gchar,
    pub read_cd: GIConv,
    pub write_cd: GIConv,
    pub line_term: *mut gchar,
    pub line_term_len: guint,
    pub buf_size: gsize,
    pub read_buf: *mut GString,
    pub encoded_read_buf: *mut GString,
    pub write_buf: *mut GString,
    pub partial_write_buf: [gchar; 6usize],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub reserved1: gpointer,
    pub reserved2: gpointer,
}
#[test]
fn bindgen_test_layout__GIOChannel() {
    assert_eq!(
        ::std::mem::size_of::<_GIOChannel>(),
        112usize,
        concat!("Size of: ", stringify!(_GIOChannel))
    );
    assert_eq!(
        ::std::mem::align_of::<_GIOChannel>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOChannel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).ref_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).funcs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).encoding as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).read_cd as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(read_cd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).write_cd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(write_cd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).line_term as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(line_term)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).line_term_len as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(line_term_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).buf_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(buf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).read_buf as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(read_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).encoded_read_buf as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(encoded_read_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).write_buf as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(write_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).partial_write_buf as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(partial_write_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).reserved1 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).reserved2 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _GIOChannel {
    #[inline]
    pub fn use_buffer(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_buffer(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn do_encode(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_encode(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn close_on_unref(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close_on_unref(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_readable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_readable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_writeable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_writeable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_seekable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_seekable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_buffer: guint,
        do_encode: guint,
        close_on_unref: guint,
        is_readable: guint,
        is_writeable: guint,
        is_seekable: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_buffer: u32 = unsafe { ::std::mem::transmute(use_buffer) };
            use_buffer as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let do_encode: u32 = unsafe { ::std::mem::transmute(do_encode) };
            do_encode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let close_on_unref: u32 = unsafe { ::std::mem::transmute(close_on_unref) };
            close_on_unref as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_readable: u32 = unsafe { ::std::mem::transmute(is_readable) };
            is_readable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_writeable: u32 = unsafe { ::std::mem::transmute(is_writeable) };
            is_writeable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_seekable: u32 = unsafe { ::std::mem::transmute(is_seekable) };
            is_seekable as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type GIOFunc =
    ::std::option::Option<unsafe extern "C" fn(source: *mut GIOChannel, condition: GIOCondition, data: gpointer) -> gboolean>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOFuncs {
    pub io_read: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, buf: *mut gchar, count: gsize, bytes_read: *mut gsize, err: *mut *mut GError)
            -> GIOStatus,
    >,
    pub io_write: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, buf: *const gchar, count: gsize, bytes_written: *mut gsize, err: *mut *mut GError)
            -> GIOStatus,
    >,
    pub io_seek: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, offset: gint64, type_: GSeekType, err: *mut *mut GError) -> GIOStatus,
    >,
    pub io_close: ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel, err: *mut *mut GError) -> GIOStatus>,
    pub io_create_watch: ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource>,
    pub io_free: ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel)>,
    pub io_set_flags:
        ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel, flags: GIOFlags, err: *mut *mut GError) -> GIOStatus>,
    pub io_get_flags: ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel) -> GIOFlags>,
}
#[test]
fn bindgen_test_layout__GIOFuncs() {
    assert_eq!(
        ::std::mem::size_of::<_GIOFuncs>(),
        64usize,
        concat!("Size of: ", stringify!(_GIOFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GIOFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOFuncs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_read as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_write as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_seek as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_close as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_create_watch as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_create_watch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_free as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_set_flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_set_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_get_flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_get_flags)
        )
    );
}
extern "C" {
    pub fn g_io_channel_init(channel: *mut GIOChannel);
}
extern "C" {
    pub fn g_io_channel_ref(channel: *mut GIOChannel) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_unref(channel: *mut GIOChannel);
}
extern "C" {
    pub fn g_io_channel_read(channel: *mut GIOChannel, buf: *mut gchar, count: gsize, bytes_read: *mut gsize) -> GIOError;
}
extern "C" {
    pub fn g_io_channel_write(channel: *mut GIOChannel, buf: *const gchar, count: gsize, bytes_written: *mut gsize) -> GIOError;
}
extern "C" {
    pub fn g_io_channel_seek(channel: *mut GIOChannel, offset: gint64, type_: GSeekType) -> GIOError;
}
extern "C" {
    pub fn g_io_channel_close(channel: *mut GIOChannel);
}
extern "C" {
    pub fn g_io_channel_shutdown(channel: *mut GIOChannel, flush: gboolean, err: *mut *mut GError) -> GIOStatus;
}
extern "C" {
    pub fn g_io_add_watch_full(
        channel: *mut GIOChannel,
        priority: gint,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_io_create_watch(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource;
}
extern "C" {
    pub fn g_io_add_watch(channel: *mut GIOChannel, condition: GIOCondition, func: GIOFunc, user_data: gpointer) -> guint;
}
extern "C" {
    pub fn g_io_channel_set_buffer_size(channel: *mut GIOChannel, size: gsize);
}
extern "C" {
    pub fn g_io_channel_get_buffer_size(channel: *mut GIOChannel) -> gsize;
}
extern "C" {
    pub fn g_io_channel_get_buffer_condition(channel: *mut GIOChannel) -> GIOCondition;
}
extern "C" {
    pub fn g_io_channel_set_flags(channel: *mut GIOChannel, flags: GIOFlags, error: *mut *mut GError) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_get_flags(channel: *mut GIOChannel) -> GIOFlags;
}
extern "C" {
    pub fn g_io_channel_set_line_term(channel: *mut GIOChannel, line_term: *const gchar, length: gint);
}
extern "C" {
    pub fn g_io_channel_get_line_term(channel: *mut GIOChannel, length: *mut gint) -> *const gchar;
}
extern "C" {
    pub fn g_io_channel_set_buffered(channel: *mut GIOChannel, buffered: gboolean);
}
extern "C" {
    pub fn g_io_channel_get_buffered(channel: *mut GIOChannel) -> gboolean;
}
extern "C" {
    pub fn g_io_channel_set_encoding(channel: *mut GIOChannel, encoding: *const gchar, error: *mut *mut GError) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_get_encoding(channel: *mut GIOChannel) -> *const gchar;
}
extern "C" {
    pub fn g_io_channel_set_close_on_unref(channel: *mut GIOChannel, do_close: gboolean);
}
extern "C" {
    pub fn g_io_channel_get_close_on_unref(channel: *mut GIOChannel) -> gboolean;
}
extern "C" {
    pub fn g_io_channel_flush(channel: *mut GIOChannel, error: *mut *mut GError) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_line(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_line_string(
        channel: *mut GIOChannel,
        buffer: *mut GString,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_to_end(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_chars(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_unichar(channel: *mut GIOChannel, thechar: *mut gunichar, error: *mut *mut GError) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_write_chars(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gssize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_write_unichar(channel: *mut GIOChannel, thechar: gunichar, error: *mut *mut GError) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_seek_position(channel: *mut GIOChannel, offset: gint64, type_: GSeekType, error: *mut *mut GError) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_new_file(filename: *const gchar, mode: *const gchar, error: *mut *mut GError) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_io_channel_error_from_errno(en: gint) -> GIOChannelError;
}
extern "C" {
    pub fn g_io_channel_unix_new(fd: ::std::os::raw::c_int) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_unix_get_fd(channel: *mut GIOChannel) -> gint;
}
extern "C" {
    pub static mut g_io_watch_funcs: GSourceFuncs;
}
pub const GKeyFileError_G_KEY_FILE_ERROR_UNKNOWN_ENCODING: GKeyFileError = 0;
pub const GKeyFileError_G_KEY_FILE_ERROR_PARSE: GKeyFileError = 1;
pub const GKeyFileError_G_KEY_FILE_ERROR_NOT_FOUND: GKeyFileError = 2;
pub const GKeyFileError_G_KEY_FILE_ERROR_KEY_NOT_FOUND: GKeyFileError = 3;
pub const GKeyFileError_G_KEY_FILE_ERROR_GROUP_NOT_FOUND: GKeyFileError = 4;
pub const GKeyFileError_G_KEY_FILE_ERROR_INVALID_VALUE: GKeyFileError = 5;
pub type GKeyFileError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_key_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GKeyFile {
    _unused: [u8; 0],
}
pub type GKeyFile = _GKeyFile;
pub const GKeyFileFlags_G_KEY_FILE_NONE: GKeyFileFlags = 0;
pub const GKeyFileFlags_G_KEY_FILE_KEEP_COMMENTS: GKeyFileFlags = 1;
pub const GKeyFileFlags_G_KEY_FILE_KEEP_TRANSLATIONS: GKeyFileFlags = 2;
pub type GKeyFileFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_key_file_new() -> *mut GKeyFile;
}
extern "C" {
    pub fn g_key_file_ref(key_file: *mut GKeyFile) -> *mut GKeyFile;
}
extern "C" {
    pub fn g_key_file_unref(key_file: *mut GKeyFile);
}
extern "C" {
    pub fn g_key_file_free(key_file: *mut GKeyFile);
}
extern "C" {
    pub fn g_key_file_set_list_separator(key_file: *mut GKeyFile, separator: gchar);
}
extern "C" {
    pub fn g_key_file_load_from_file(
        key_file: *mut GKeyFile,
        file: *const gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_data(
        key_file: *mut GKeyFile,
        data: *const gchar,
        length: gsize,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        search_dirs: *mut *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_data_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_to_data(key_file: *mut GKeyFile, length: *mut gsize, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_save_to_file(key_file: *mut GKeyFile, filename: *const gchar, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_key_file_get_start_group(key_file: *mut GKeyFile) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_get_groups(key_file: *mut GKeyFile, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_get_keys(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_has_group(key_file: *mut GKeyFile, group_name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_key_file_has_key(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_key_file_get_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_value(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, value: *const gchar);
}
extern "C" {
    pub fn g_key_file_get_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_string(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, string: *const gchar);
}
extern "C" {
    pub fn g_key_file_get_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        string: *const gchar,
    );
}
extern "C" {
    pub fn g_key_file_get_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_set_boolean(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, value: gboolean);
}
extern "C" {
    pub fn g_key_file_get_integer(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, error: *mut *mut GError) -> gint;
}
extern "C" {
    pub fn g_key_file_set_integer(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, value: gint);
}
extern "C" {
    pub fn g_key_file_get_int64(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, error: *mut *mut GError) -> gint64;
}
extern "C" {
    pub fn g_key_file_set_int64(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, value: gint64);
}
extern "C" {
    pub fn g_key_file_get_uint64(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, error: *mut *mut GError) -> guint64;
}
extern "C" {
    pub fn g_key_file_set_uint64(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, value: guint64);
}
extern "C" {
    pub fn g_key_file_get_double(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, error: *mut *mut GError) -> gdouble;
}
extern "C" {
    pub fn g_key_file_set_double(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, value: gdouble);
}
extern "C" {
    pub fn g_key_file_get_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gboolean;
}
extern "C" {
    pub fn g_key_file_set_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gboolean,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gint;
}
extern "C" {
    pub fn g_key_file_set_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gdouble,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gdouble;
}
extern "C" {
    pub fn g_key_file_set_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gint,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_set_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        comment: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_get_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_remove_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_remove_key(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, error: *mut *mut GError)
        -> gboolean;
}
extern "C" {
    pub fn g_key_file_remove_group(key_file: *mut GKeyFile, group_name: *const gchar, error: *mut *mut GError) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMappedFile {
    _unused: [u8; 0],
}
pub type GMappedFile = _GMappedFile;
extern "C" {
    pub fn g_mapped_file_new(filename: *const gchar, writable: gboolean, error: *mut *mut GError) -> *mut GMappedFile;
}
extern "C" {
    pub fn g_mapped_file_new_from_fd(fd: gint, writable: gboolean, error: *mut *mut GError) -> *mut GMappedFile;
}
extern "C" {
    pub fn g_mapped_file_get_length(file: *mut GMappedFile) -> gsize;
}
extern "C" {
    pub fn g_mapped_file_get_contents(file: *mut GMappedFile) -> *mut gchar;
}
extern "C" {
    pub fn g_mapped_file_get_bytes(file: *mut GMappedFile) -> *mut GBytes;
}
extern "C" {
    pub fn g_mapped_file_ref(file: *mut GMappedFile) -> *mut GMappedFile;
}
extern "C" {
    pub fn g_mapped_file_unref(file: *mut GMappedFile);
}
extern "C" {
    pub fn g_mapped_file_free(file: *mut GMappedFile);
}
pub const GMarkupError_G_MARKUP_ERROR_BAD_UTF8: GMarkupError = 0;
pub const GMarkupError_G_MARKUP_ERROR_EMPTY: GMarkupError = 1;
pub const GMarkupError_G_MARKUP_ERROR_PARSE: GMarkupError = 2;
pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ELEMENT: GMarkupError = 3;
pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: GMarkupError = 4;
pub const GMarkupError_G_MARKUP_ERROR_INVALID_CONTENT: GMarkupError = 5;
pub const GMarkupError_G_MARKUP_ERROR_MISSING_ATTRIBUTE: GMarkupError = 6;
pub type GMarkupError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_markup_error_quark() -> GQuark;
}
pub const GMarkupParseFlags_G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: GMarkupParseFlags = 1;
pub const GMarkupParseFlags_G_MARKUP_TREAT_CDATA_AS_TEXT: GMarkupParseFlags = 2;
pub const GMarkupParseFlags_G_MARKUP_PREFIX_ERROR_POSITION: GMarkupParseFlags = 4;
pub const GMarkupParseFlags_G_MARKUP_IGNORE_QUALIFIED: GMarkupParseFlags = 8;
pub type GMarkupParseFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParseContext {
    _unused: [u8; 0],
}
/// GMarkupParseContext:
///
/// A parse context is used to parse a stream of bytes that
/// you expect to contain marked-up text.
///
/// See g_markup_parse_context_new(), #GMarkupParser, and so
/// on for more details.
pub type GMarkupParseContext = _GMarkupParseContext;
pub type GMarkupParser = _GMarkupParser;
/// GMarkupParser:
/// @start_element: Callback to invoke when the opening tag of an element
/// is seen. The callback's @attribute_names and @attribute_values parameters
/// are %NULL-terminated.
/// @end_element: Callback to invoke when the closing tag of an element
/// is seen. Note that this is also called for empty tags like
/// `<empty/>`.
/// @text: Callback to invoke when some text is seen (text is always
/// inside an element). Note that the text of an element may be spread
/// over multiple calls of this function. If the
/// %G_MARKUP_TREAT_CDATA_AS_TEXT flag is set, this function is also
/// called for the content of CDATA marked sections.
/// @passthrough: Callback to invoke for comments, processing instructions
/// and doctype declarations; if you're re-writing the parsed document,
/// write the passthrough text back out in the same position. If the
/// %G_MARKUP_TREAT_CDATA_AS_TEXT flag is not set, this function is also
/// called for CDATA marked sections.
/// @error: Callback to invoke when an error occurs.
///
/// Any of the fields in #GMarkupParser can be %NULL, in which case they
/// will be ignored. Except for the @error function, any of these callbacks
/// can set an error; in particular the %G_MARKUP_ERROR_UNKNOWN_ELEMENT,
/// %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and %G_MARKUP_ERROR_INVALID_CONTENT
/// errors are intended to be set from these callbacks. If you set an error
/// from a callback, g_markup_parse_context_parse() will report that error
/// back to its caller.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParser {
    pub start_element: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            attribute_names: *mut *const gchar,
            attribute_values: *mut *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub end_element: ::std::option::Option<
        unsafe extern "C" fn(context: *mut GMarkupParseContext, element_name: *const gchar, user_data: gpointer, error: *mut *mut GError),
    >,
    pub text: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub passthrough: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            passthrough_text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub error: ::std::option::Option<unsafe extern "C" fn(context: *mut GMarkupParseContext, error: *mut GError, user_data: gpointer)>,
}
#[test]
fn bindgen_test_layout__GMarkupParser() {
    assert_eq!(
        ::std::mem::size_of::<_GMarkupParser>(),
        40usize,
        concat!("Size of: ", stringify!(_GMarkupParser))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMarkupParser>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMarkupParser))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMarkupParser>())).start_element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(start_element)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMarkupParser>())).end_element as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(end_element)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMarkupParser>())).text as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMarkupParser>())).passthrough as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(passthrough)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMarkupParser>())).error as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(error)
        )
    );
}
extern "C" {
    pub fn g_markup_parse_context_new(
        parser: *const GMarkupParser,
        flags: GMarkupParseFlags,
        user_data: gpointer,
        user_data_dnotify: GDestroyNotify,
    ) -> *mut GMarkupParseContext;
}
extern "C" {
    pub fn g_markup_parse_context_ref(context: *mut GMarkupParseContext) -> *mut GMarkupParseContext;
}
extern "C" {
    pub fn g_markup_parse_context_unref(context: *mut GMarkupParseContext);
}
extern "C" {
    pub fn g_markup_parse_context_free(context: *mut GMarkupParseContext);
}
extern "C" {
    pub fn g_markup_parse_context_parse(
        context: *mut GMarkupParseContext,
        text: *const gchar,
        text_len: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_markup_parse_context_push(context: *mut GMarkupParseContext, parser: *const GMarkupParser, user_data: gpointer);
}
extern "C" {
    pub fn g_markup_parse_context_pop(context: *mut GMarkupParseContext) -> gpointer;
}
extern "C" {
    pub fn g_markup_parse_context_end_parse(context: *mut GMarkupParseContext, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_markup_parse_context_get_element(context: *mut GMarkupParseContext) -> *const gchar;
}
extern "C" {
    pub fn g_markup_parse_context_get_element_stack(context: *mut GMarkupParseContext) -> *const GSList;
}
extern "C" {
    pub fn g_markup_parse_context_get_position(context: *mut GMarkupParseContext, line_number: *mut gint, char_number: *mut gint);
}
extern "C" {
    pub fn g_markup_parse_context_get_user_data(context: *mut GMarkupParseContext) -> gpointer;
}
extern "C" {
    pub fn g_markup_escape_text(text: *const gchar, length: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_markup_printf_escaped(format: *const ::std::os::raw::c_char, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_markup_vprintf_escaped(format: *const ::std::os::raw::c_char, args: *mut __va_list_tag) -> *mut gchar;
}
pub const GMarkupCollectType_G_MARKUP_COLLECT_INVALID: GMarkupCollectType = 0;
pub const GMarkupCollectType_G_MARKUP_COLLECT_STRING: GMarkupCollectType = 1;
pub const GMarkupCollectType_G_MARKUP_COLLECT_STRDUP: GMarkupCollectType = 2;
pub const GMarkupCollectType_G_MARKUP_COLLECT_BOOLEAN: GMarkupCollectType = 3;
pub const GMarkupCollectType_G_MARKUP_COLLECT_TRISTATE: GMarkupCollectType = 4;
pub const GMarkupCollectType_G_MARKUP_COLLECT_OPTIONAL: GMarkupCollectType = 65536;
pub type GMarkupCollectType = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_markup_collect_attributes(
        element_name: *const gchar,
        attribute_names: *mut *const gchar,
        attribute_values: *mut *const gchar,
        error: *mut *mut GError,
        first_type: GMarkupCollectType,
        first_attr: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_printf_string_upper_bound(format: *const gchar, args: *mut __va_list_tag) -> gsize;
}
pub const GLogLevelFlags_G_LOG_FLAG_RECURSION: GLogLevelFlags = 1;
pub const GLogLevelFlags_G_LOG_FLAG_FATAL: GLogLevelFlags = 2;
pub const GLogLevelFlags_G_LOG_LEVEL_ERROR: GLogLevelFlags = 4;
pub const GLogLevelFlags_G_LOG_LEVEL_CRITICAL: GLogLevelFlags = 8;
pub const GLogLevelFlags_G_LOG_LEVEL_WARNING: GLogLevelFlags = 16;
pub const GLogLevelFlags_G_LOG_LEVEL_MESSAGE: GLogLevelFlags = 32;
pub const GLogLevelFlags_G_LOG_LEVEL_INFO: GLogLevelFlags = 64;
pub const GLogLevelFlags_G_LOG_LEVEL_DEBUG: GLogLevelFlags = 128;
pub const GLogLevelFlags_G_LOG_LEVEL_MASK: GLogLevelFlags = -4;
pub type GLogLevelFlags = ::std::os::raw::c_int;
pub type GLogFunc = ::std::option::Option<
    unsafe extern "C" fn(log_domain: *const gchar, log_level: GLogLevelFlags, message: *const gchar, user_data: gpointer),
>;
extern "C" {
    pub fn g_log_set_handler(log_domain: *const gchar, log_levels: GLogLevelFlags, log_func: GLogFunc, user_data: gpointer) -> guint;
}
extern "C" {
    pub fn g_log_set_handler_full(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_log_remove_handler(log_domain: *const gchar, handler_id: guint);
}
extern "C" {
    pub fn g_log_default_handler(log_domain: *const gchar, log_level: GLogLevelFlags, message: *const gchar, unused_data: gpointer);
}
extern "C" {
    pub fn g_log_set_default_handler(log_func: GLogFunc, user_data: gpointer) -> GLogFunc;
}
extern "C" {
    pub fn g_log(log_domain: *const gchar, log_level: GLogLevelFlags, format: *const gchar, ...);
}
extern "C" {
    pub fn g_logv(log_domain: *const gchar, log_level: GLogLevelFlags, format: *const gchar, args: *mut __va_list_tag);
}
extern "C" {
    pub fn g_log_set_fatal_mask(log_domain: *const gchar, fatal_mask: GLogLevelFlags) -> GLogLevelFlags;
}
extern "C" {
    pub fn g_log_set_always_fatal(fatal_mask: GLogLevelFlags) -> GLogLevelFlags;
}
extern "C" {
    pub fn _g_log_fallback_handler(log_domain: *const gchar, log_level: GLogLevelFlags, message: *const gchar, unused_data: gpointer);
}
extern "C" {
    pub fn g_return_if_fail_warning(
        log_domain: *const ::std::os::raw::c_char,
        pretty_function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_warn_message(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        warnexpr: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assert_warning(
        log_domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        pretty_function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    );
}
/// GPrintFunc:
/// @string: the message to output
///
/// Specifies the type of the print handler functions.
/// These are called with the complete formatted string to output.
pub type GPrintFunc = ::std::option::Option<unsafe extern "C" fn(string: *const gchar)>;
extern "C" {
    pub fn g_print(format: *const gchar, ...);
}
extern "C" {
    pub fn g_set_print_handler(func: GPrintFunc) -> GPrintFunc;
}
extern "C" {
    pub fn g_printerr(format: *const gchar, ...);
}
extern "C" {
    pub fn g_set_printerr_handler(func: GPrintFunc) -> GPrintFunc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionContext {
    _unused: [u8; 0],
}
/// GOptionContext:
///
/// A `GOptionContext` struct defines which options
/// are accepted by the commandline option parser. The struct has only private
/// fields and should not be directly accessed.
pub type GOptionContext = _GOptionContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionGroup {
    _unused: [u8; 0],
}
/// GOptionGroup:
///
/// A `GOptionGroup` struct defines the options in a single
/// group. The struct has only private fields and should not be directly accessed.
///
/// All options in a group share the same translation function. Libraries which
/// need to parse commandline options are expected to provide a function for
/// getting a `GOptionGroup` holding their options, which
/// the application can then add to its #GOptionContext.
pub type GOptionGroup = _GOptionGroup;
pub type GOptionEntry = _GOptionEntry;
pub const GOptionFlags_G_OPTION_FLAG_NONE: GOptionFlags = 0;
pub const GOptionFlags_G_OPTION_FLAG_HIDDEN: GOptionFlags = 1;
pub const GOptionFlags_G_OPTION_FLAG_IN_MAIN: GOptionFlags = 2;
pub const GOptionFlags_G_OPTION_FLAG_REVERSE: GOptionFlags = 4;
pub const GOptionFlags_G_OPTION_FLAG_NO_ARG: GOptionFlags = 8;
pub const GOptionFlags_G_OPTION_FLAG_FILENAME: GOptionFlags = 16;
pub const GOptionFlags_G_OPTION_FLAG_OPTIONAL_ARG: GOptionFlags = 32;
pub const GOptionFlags_G_OPTION_FLAG_NOALIAS: GOptionFlags = 64;
pub type GOptionFlags = ::std::os::raw::c_uint;
pub const GOptionArg_G_OPTION_ARG_NONE: GOptionArg = 0;
pub const GOptionArg_G_OPTION_ARG_STRING: GOptionArg = 1;
pub const GOptionArg_G_OPTION_ARG_INT: GOptionArg = 2;
pub const GOptionArg_G_OPTION_ARG_CALLBACK: GOptionArg = 3;
pub const GOptionArg_G_OPTION_ARG_FILENAME: GOptionArg = 4;
pub const GOptionArg_G_OPTION_ARG_STRING_ARRAY: GOptionArg = 5;
pub const GOptionArg_G_OPTION_ARG_FILENAME_ARRAY: GOptionArg = 6;
pub const GOptionArg_G_OPTION_ARG_DOUBLE: GOptionArg = 7;
pub const GOptionArg_G_OPTION_ARG_INT64: GOptionArg = 8;
pub type GOptionArg = ::std::os::raw::c_uint;
/// GOptionArgFunc:
/// @option_name: The name of the option being parsed. This will be either a
/// single dash followed by a single letter (for a short name) or two dashes
/// followed by a long option name.
/// @value: The value to be parsed.
/// @data: User data added to the #GOptionGroup containing the option when it
/// was created with g_option_group_new()
/// @error: A return location for errors. The error code %G_OPTION_ERROR_FAILED
/// is intended to be used for errors in #GOptionArgFunc callbacks.
///
/// The type of function to be passed as callback for %G_OPTION_ARG_CALLBACK
/// options.
///
/// Returns: %TRUE if the option was successfully parsed, %FALSE if an error
/// occurred, in which case @error should be set with g_set_error()
pub type GOptionArgFunc = ::std::option::Option<
    unsafe extern "C" fn(option_name: *const gchar, value: *const gchar, data: gpointer, error: *mut *mut GError) -> gboolean,
>;
/// GOptionParseFunc:
/// @context: The active #GOptionContext
/// @group: The group to which the function belongs
/// @data: User data added to the #GOptionGroup containing the option when it
/// was created with g_option_group_new()
/// @error: A return location for error details
///
/// The type of function that can be called before and after parsing.
///
/// Returns: %TRUE if the function completed successfully, %FALSE if an error
/// occurred, in which case @error should be set with g_set_error()
pub type GOptionParseFunc = ::std::option::Option<
    unsafe extern "C" fn(context: *mut GOptionContext, group: *mut GOptionGroup, data: gpointer, error: *mut *mut GError) -> gboolean,
>;
/// GOptionErrorFunc:
/// @context: The active #GOptionContext
/// @group: The group to which the function belongs
/// @data: User data added to the #GOptionGroup containing the option when it
/// was created with g_option_group_new()
/// @error: The #GError containing details about the parse error
///
/// The type of function to be used as callback when a parse error occurs.
pub type GOptionErrorFunc = ::std::option::Option<
    unsafe extern "C" fn(context: *mut GOptionContext, group: *mut GOptionGroup, data: gpointer, error: *mut *mut GError),
>;
pub const GOptionError_G_OPTION_ERROR_UNKNOWN_OPTION: GOptionError = 0;
pub const GOptionError_G_OPTION_ERROR_BAD_VALUE: GOptionError = 1;
pub const GOptionError_G_OPTION_ERROR_FAILED: GOptionError = 2;
pub type GOptionError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_option_error_quark() -> GQuark;
}
/// GOptionEntry:
/// @long_name: The long name of an option can be used to specify it
/// in a commandline as `--long_name`. Every option must have a
/// long name. To resolve conflicts if multiple option groups contain
/// the same long name, it is also possible to specify the option as
/// `--groupname-long_name`.
/// @short_name: If an option has a short name, it can be specified
/// `-short_name` in a commandline. @short_name must be  a printable
/// ASCII character different from '-', or zero if the option has no
/// short name.
/// @flags: Flags from #GOptionFlags
/// @arg: The type of the option, as a #GOptionArg
/// @arg_data: If the @arg type is %G_OPTION_ARG_CALLBACK, then @arg_data
/// must point to a #GOptionArgFunc callback function, which will be
/// called to handle the extra argument. Otherwise, @arg_data is a
/// pointer to a location to store the value, the required type of
/// the location depends on the @arg type:
/// - %G_OPTION_ARG_NONE: %gboolean
/// - %G_OPTION_ARG_STRING: %gchar*
/// - %G_OPTION_ARG_INT: %gint
/// - %G_OPTION_ARG_FILENAME: %gchar*
/// - %G_OPTION_ARG_STRING_ARRAY: %gchar**
/// - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**
/// - %G_OPTION_ARG_DOUBLE: %gdouble
/// If @arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,
/// the location will contain a newly allocated string if the option
/// was given. That string needs to be freed by the callee using g_free().
/// Likewise if @arg type is %G_OPTION_ARG_STRING_ARRAY or
/// %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev().
/// @description: the description for the option in `--help`
/// output. The @description is translated using the @translate_func
/// of the group, see g_option_group_set_translation_domain().
/// @arg_description: The placeholder to use for the extra argument parsed
/// by the option in `--help` output. The @arg_description is translated
/// using the @translate_func of the group, see
/// g_option_group_set_translation_domain().
///
/// A GOptionEntry struct defines a single option. To have an effect, they
/// must be added to a #GOptionGroup with g_option_context_add_main_entries()
/// or g_option_group_add_entries().
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionEntry {
    pub long_name: *const gchar,
    pub short_name: gchar,
    pub flags: gint,
    pub arg: GOptionArg,
    pub arg_data: gpointer,
    pub description: *const gchar,
    pub arg_description: *const gchar,
}
#[test]
fn bindgen_test_layout__GOptionEntry() {
    assert_eq!(
        ::std::mem::size_of::<_GOptionEntry>(),
        48usize,
        concat!("Size of: ", stringify!(_GOptionEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOptionEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOptionEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOptionEntry>())).long_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOptionEntry>())).short_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(short_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOptionEntry>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOptionEntry>())).arg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOptionEntry>())).arg_data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOptionEntry>())).description as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOptionEntry>())).arg_description as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg_description)
        )
    );
}
extern "C" {
    pub fn g_option_context_new(parameter_string: *const gchar) -> *mut GOptionContext;
}
extern "C" {
    pub fn g_option_context_set_summary(context: *mut GOptionContext, summary: *const gchar);
}
extern "C" {
    pub fn g_option_context_get_summary(context: *mut GOptionContext) -> *const gchar;
}
extern "C" {
    pub fn g_option_context_set_description(context: *mut GOptionContext, description: *const gchar);
}
extern "C" {
    pub fn g_option_context_get_description(context: *mut GOptionContext) -> *const gchar;
}
extern "C" {
    pub fn g_option_context_free(context: *mut GOptionContext);
}
extern "C" {
    pub fn g_option_context_set_help_enabled(context: *mut GOptionContext, help_enabled: gboolean);
}
extern "C" {
    pub fn g_option_context_get_help_enabled(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    pub fn g_option_context_set_ignore_unknown_options(context: *mut GOptionContext, ignore_unknown: gboolean);
}
extern "C" {
    pub fn g_option_context_get_ignore_unknown_options(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    pub fn g_option_context_set_strict_posix(context: *mut GOptionContext, strict_posix: gboolean);
}
extern "C" {
    pub fn g_option_context_get_strict_posix(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    pub fn g_option_context_add_main_entries(context: *mut GOptionContext, entries: *const GOptionEntry, translation_domain: *const gchar);
}
extern "C" {
    pub fn g_option_context_parse(
        context: *mut GOptionContext,
        argc: *mut gint,
        argv: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_option_context_parse_strv(context: *mut GOptionContext, arguments: *mut *mut *mut gchar, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_option_context_set_translate_func(
        context: *mut GOptionContext,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_option_context_set_translation_domain(context: *mut GOptionContext, domain: *const gchar);
}
extern "C" {
    pub fn g_option_context_add_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_context_set_main_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_context_get_main_group(context: *mut GOptionContext) -> *mut GOptionGroup;
}
extern "C" {
    pub fn g_option_context_get_help(context: *mut GOptionContext, main_help: gboolean, group: *mut GOptionGroup) -> *mut gchar;
}
extern "C" {
    pub fn g_option_group_new(
        name: *const gchar,
        description: *const gchar,
        help_description: *const gchar,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> *mut GOptionGroup;
}
extern "C" {
    pub fn g_option_group_set_parse_hooks(group: *mut GOptionGroup, pre_parse_func: GOptionParseFunc, post_parse_func: GOptionParseFunc);
}
extern "C" {
    pub fn g_option_group_set_error_hook(group: *mut GOptionGroup, error_func: GOptionErrorFunc);
}
extern "C" {
    pub fn g_option_group_free(group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_group_ref(group: *mut GOptionGroup) -> *mut GOptionGroup;
}
extern "C" {
    pub fn g_option_group_unref(group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_group_add_entries(group: *mut GOptionGroup, entries: *const GOptionEntry);
}
extern "C" {
    pub fn g_option_group_set_translate_func(
        group: *mut GOptionGroup,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_option_group_set_translation_domain(group: *mut GOptionGroup, domain: *const gchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPatternSpec {
    _unused: [u8; 0],
}
pub type GPatternSpec = _GPatternSpec;
extern "C" {
    pub fn g_pattern_spec_new(pattern: *const gchar) -> *mut GPatternSpec;
}
extern "C" {
    pub fn g_pattern_spec_free(pspec: *mut GPatternSpec);
}
extern "C" {
    pub fn g_pattern_spec_equal(pspec1: *mut GPatternSpec, pspec2: *mut GPatternSpec) -> gboolean;
}
extern "C" {
    pub fn g_pattern_match(pspec: *mut GPatternSpec, string_length: guint, string: *const gchar, string_reversed: *const gchar)
        -> gboolean;
}
extern "C" {
    pub fn g_pattern_match_string(pspec: *mut GPatternSpec, string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_pattern_match_simple(pattern: *const gchar, string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_spaced_primes_closest(num: guint) -> guint;
}
extern "C" {
    pub fn g_qsort_with_data(pbase: gconstpointer, total_elems: gint, size: gsize, compare_func: GCompareDataFunc, user_data: gpointer);
}
pub type GQueue = _GQueue;
/// GQueue:
/// @head: a pointer to the first element of the queue
/// @tail: a pointer to the last element of the queue
/// @length: the number of elements in the queue
///
/// Contains the public fields of a
/// [Queue][glib-Double-ended-Queues].
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GQueue {
    pub head: *mut GList,
    pub tail: *mut GList,
    pub length: guint,
}
#[test]
fn bindgen_test_layout__GQueue() {
    assert_eq!(
        ::std::mem::size_of::<_GQueue>(),
        24usize,
        concat!("Size of: ", stringify!(_GQueue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GQueue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GQueue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GQueue>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GQueue>())).tail as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GQueue>())).length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    pub fn g_queue_new() -> *mut GQueue;
}
extern "C" {
    pub fn g_queue_free(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_free_full(queue: *mut GQueue, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_queue_init(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_clear(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_is_empty(queue: *mut GQueue) -> gboolean;
}
extern "C" {
    pub fn g_queue_get_length(queue: *mut GQueue) -> guint;
}
extern "C" {
    pub fn g_queue_reverse(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_copy(queue: *mut GQueue) -> *mut GQueue;
}
extern "C" {
    pub fn g_queue_foreach(queue: *mut GQueue, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_queue_find(queue: *mut GQueue, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_queue_find_custom(queue: *mut GQueue, data: gconstpointer, func: GCompareFunc) -> *mut GList;
}
extern "C" {
    pub fn g_queue_sort(queue: *mut GQueue, compare_func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_queue_push_head(queue: *mut GQueue, data: gpointer);
}
extern "C" {
    pub fn g_queue_push_tail(queue: *mut GQueue, data: gpointer);
}
extern "C" {
    pub fn g_queue_push_nth(queue: *mut GQueue, data: gpointer, n: gint);
}
extern "C" {
    pub fn g_queue_pop_head(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_pop_tail(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_pop_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_queue_peek_head(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_peek_tail(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_peek_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_queue_index(queue: *mut GQueue, data: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_queue_remove(queue: *mut GQueue, data: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_queue_remove_all(queue: *mut GQueue, data: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_queue_insert_before(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
extern "C" {
    pub fn g_queue_insert_after(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
extern "C" {
    pub fn g_queue_insert_sorted(queue: *mut GQueue, data: gpointer, func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_queue_push_head_link(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_push_tail_link(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_push_nth_link(queue: *mut GQueue, n: gint, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_pop_head_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_pop_tail_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_pop_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_queue_peek_head_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_peek_tail_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_peek_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_queue_link_index(queue: *mut GQueue, link_: *mut GList) -> gint;
}
extern "C" {
    pub fn g_queue_unlink(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_delete_link(queue: *mut GQueue, link_: *mut GList);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRand {
    _unused: [u8; 0],
}
pub type GRand = _GRand;
extern "C" {
    pub fn g_rand_new_with_seed(seed: guint32) -> *mut GRand;
}
extern "C" {
    pub fn g_rand_new_with_seed_array(seed: *const guint32, seed_length: guint) -> *mut GRand;
}
extern "C" {
    pub fn g_rand_new() -> *mut GRand;
}
extern "C" {
    pub fn g_rand_free(rand_: *mut GRand);
}
extern "C" {
    pub fn g_rand_copy(rand_: *mut GRand) -> *mut GRand;
}
extern "C" {
    pub fn g_rand_set_seed(rand_: *mut GRand, seed: guint32);
}
extern "C" {
    pub fn g_rand_set_seed_array(rand_: *mut GRand, seed: *const guint32, seed_length: guint);
}
extern "C" {
    pub fn g_rand_int(rand_: *mut GRand) -> guint32;
}
extern "C" {
    pub fn g_rand_int_range(rand_: *mut GRand, begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    pub fn g_rand_double(rand_: *mut GRand) -> gdouble;
}
extern "C" {
    pub fn g_rand_double_range(rand_: *mut GRand, begin: gdouble, end: gdouble) -> gdouble;
}
extern "C" {
    pub fn g_random_set_seed(seed: guint32);
}
extern "C" {
    pub fn g_random_int() -> guint32;
}
extern "C" {
    pub fn g_random_int_range(begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    pub fn g_random_double() -> gdouble;
}
extern "C" {
    pub fn g_random_double_range(begin: gdouble, end: gdouble) -> gdouble;
}
pub const GRegexError_G_REGEX_ERROR_COMPILE: GRegexError = 0;
pub const GRegexError_G_REGEX_ERROR_OPTIMIZE: GRegexError = 1;
pub const GRegexError_G_REGEX_ERROR_REPLACE: GRegexError = 2;
pub const GRegexError_G_REGEX_ERROR_MATCH: GRegexError = 3;
pub const GRegexError_G_REGEX_ERROR_INTERNAL: GRegexError = 4;
pub const GRegexError_G_REGEX_ERROR_STRAY_BACKSLASH: GRegexError = 101;
pub const GRegexError_G_REGEX_ERROR_MISSING_CONTROL_CHAR: GRegexError = 102;
pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: GRegexError = 103;
pub const GRegexError_G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: GRegexError = 104;
pub const GRegexError_G_REGEX_ERROR_QUANTIFIER_TOO_BIG: GRegexError = 105;
pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: GRegexError = 106;
pub const GRegexError_G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: GRegexError = 107;
pub const GRegexError_G_REGEX_ERROR_RANGE_OUT_OF_ORDER: GRegexError = 108;
pub const GRegexError_G_REGEX_ERROR_NOTHING_TO_REPEAT: GRegexError = 109;
pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: GRegexError = 112;
pub const GRegexError_G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: GRegexError = 113;
pub const GRegexError_G_REGEX_ERROR_UNMATCHED_PARENTHESIS: GRegexError = 114;
pub const GRegexError_G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: GRegexError = 115;
pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_COMMENT: GRegexError = 118;
pub const GRegexError_G_REGEX_ERROR_EXPRESSION_TOO_LARGE: GRegexError = 120;
pub const GRegexError_G_REGEX_ERROR_MEMORY_ERROR: GRegexError = 121;
pub const GRegexError_G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: GRegexError = 125;
pub const GRegexError_G_REGEX_ERROR_MALFORMED_CONDITION: GRegexError = 126;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: GRegexError = 127;
pub const GRegexError_G_REGEX_ERROR_ASSERTION_EXPECTED: GRegexError = 128;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: GRegexError = 130;
pub const GRegexError_G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: GRegexError = 131;
pub const GRegexError_G_REGEX_ERROR_HEX_CODE_TOO_LARGE: GRegexError = 134;
pub const GRegexError_G_REGEX_ERROR_INVALID_CONDITION: GRegexError = 135;
pub const GRegexError_G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: GRegexError = 136;
pub const GRegexError_G_REGEX_ERROR_INFINITE_LOOP: GRegexError = 140;
pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: GRegexError = 142;
pub const GRegexError_G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: GRegexError = 143;
pub const GRegexError_G_REGEX_ERROR_MALFORMED_PROPERTY: GRegexError = 146;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_PROPERTY: GRegexError = 147;
pub const GRegexError_G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: GRegexError = 148;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: GRegexError = 149;
pub const GRegexError_G_REGEX_ERROR_INVALID_OCTAL_VALUE: GRegexError = 151;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: GRegexError = 154;
pub const GRegexError_G_REGEX_ERROR_DEFINE_REPETION: GRegexError = 155;
pub const GRegexError_G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: GRegexError = 156;
pub const GRegexError_G_REGEX_ERROR_MISSING_BACK_REFERENCE: GRegexError = 157;
pub const GRegexError_G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: GRegexError = 158;
pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: GRegexError = 159;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: GRegexError = 160;
pub const GRegexError_G_REGEX_ERROR_NUMBER_TOO_BIG: GRegexError = 161;
pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: GRegexError = 162;
pub const GRegexError_G_REGEX_ERROR_MISSING_DIGIT: GRegexError = 163;
pub const GRegexError_G_REGEX_ERROR_INVALID_DATA_CHARACTER: GRegexError = 164;
pub const GRegexError_G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: GRegexError = 165;
pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: GRegexError = 166;
pub const GRegexError_G_REGEX_ERROR_INVALID_CONTROL_CHAR: GRegexError = 168;
pub const GRegexError_G_REGEX_ERROR_MISSING_NAME: GRegexError = 169;
pub const GRegexError_G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: GRegexError = 171;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: GRegexError = 172;
pub const GRegexError_G_REGEX_ERROR_NAME_TOO_LONG: GRegexError = 175;
pub const GRegexError_G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: GRegexError = 176;
pub type GRegexError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_regex_error_quark() -> GQuark;
}
pub const GRegexCompileFlags_G_REGEX_CASELESS: GRegexCompileFlags = 1;
pub const GRegexCompileFlags_G_REGEX_MULTILINE: GRegexCompileFlags = 2;
pub const GRegexCompileFlags_G_REGEX_DOTALL: GRegexCompileFlags = 4;
pub const GRegexCompileFlags_G_REGEX_EXTENDED: GRegexCompileFlags = 8;
pub const GRegexCompileFlags_G_REGEX_ANCHORED: GRegexCompileFlags = 16;
pub const GRegexCompileFlags_G_REGEX_DOLLAR_ENDONLY: GRegexCompileFlags = 32;
pub const GRegexCompileFlags_G_REGEX_UNGREEDY: GRegexCompileFlags = 512;
pub const GRegexCompileFlags_G_REGEX_RAW: GRegexCompileFlags = 2048;
pub const GRegexCompileFlags_G_REGEX_NO_AUTO_CAPTURE: GRegexCompileFlags = 4096;
pub const GRegexCompileFlags_G_REGEX_OPTIMIZE: GRegexCompileFlags = 8192;
pub const GRegexCompileFlags_G_REGEX_FIRSTLINE: GRegexCompileFlags = 262144;
pub const GRegexCompileFlags_G_REGEX_DUPNAMES: GRegexCompileFlags = 524288;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_CR: GRegexCompileFlags = 1048576;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_LF: GRegexCompileFlags = 2097152;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_CRLF: GRegexCompileFlags = 3145728;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_ANYCRLF: GRegexCompileFlags = 5242880;
pub const GRegexCompileFlags_G_REGEX_BSR_ANYCRLF: GRegexCompileFlags = 8388608;
pub const GRegexCompileFlags_G_REGEX_JAVASCRIPT_COMPAT: GRegexCompileFlags = 33554432;
pub type GRegexCompileFlags = ::std::os::raw::c_uint;
pub const GRegexMatchFlags_G_REGEX_MATCH_ANCHORED: GRegexMatchFlags = 16;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTBOL: GRegexMatchFlags = 128;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEOL: GRegexMatchFlags = 256;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY: GRegexMatchFlags = 1024;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL: GRegexMatchFlags = 32768;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CR: GRegexMatchFlags = 1048576;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_LF: GRegexMatchFlags = 2097152;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CRLF: GRegexMatchFlags = 3145728;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANY: GRegexMatchFlags = 4194304;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANYCRLF: GRegexMatchFlags = 5242880;
pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANYCRLF: GRegexMatchFlags = 8388608;
pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANY: GRegexMatchFlags = 16777216;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_SOFT: GRegexMatchFlags = 32768;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_HARD: GRegexMatchFlags = 134217728;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY_ATSTART: GRegexMatchFlags = 268435456;
pub type GRegexMatchFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRegex {
    _unused: [u8; 0],
}
/// GRegex:
///
/// A GRegex is the "compiled" form of a regular expression pattern.
/// This structure is opaque and its fields cannot be accessed directly.
///
/// Since: 2.14
pub type GRegex = _GRegex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMatchInfo {
    _unused: [u8; 0],
}
/// GMatchInfo:
///
/// A GMatchInfo is an opaque struct used to return information about
/// matches.
pub type GMatchInfo = _GMatchInfo;
/// GRegexEvalCallback:
/// @match_info: the #GMatchInfo generated by the match.
/// Use g_match_info_get_regex() and g_match_info_get_string() if you
/// need the #GRegex or the matched string.
/// @result: a #GString containing the new string
/// @user_data: user data passed to g_regex_replace_eval()
///
/// Specifies the type of the function passed to g_regex_replace_eval().
/// It is called for each occurrence of the pattern in the string passed
/// to g_regex_replace_eval(), and it should append the replacement to
/// @result.
///
/// Returns: %FALSE to continue the replacement process, %TRUE to stop it
///
/// Since: 2.14
pub type GRegexEvalCallback =
    ::std::option::Option<unsafe extern "C" fn(match_info: *const GMatchInfo, result: *mut GString, user_data: gpointer) -> gboolean>;
extern "C" {
    pub fn g_regex_new(
        pattern: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut GRegex;
}
extern "C" {
    pub fn g_regex_ref(regex: *mut GRegex) -> *mut GRegex;
}
extern "C" {
    pub fn g_regex_unref(regex: *mut GRegex);
}
extern "C" {
    pub fn g_regex_get_pattern(regex: *const GRegex) -> *const gchar;
}
extern "C" {
    pub fn g_regex_get_max_backref(regex: *const GRegex) -> gint;
}
extern "C" {
    pub fn g_regex_get_capture_count(regex: *const GRegex) -> gint;
}
extern "C" {
    pub fn g_regex_get_has_cr_or_lf(regex: *const GRegex) -> gboolean;
}
extern "C" {
    pub fn g_regex_get_max_lookbehind(regex: *const GRegex) -> gint;
}
extern "C" {
    pub fn g_regex_get_string_number(regex: *const GRegex, name: *const gchar) -> gint;
}
extern "C" {
    pub fn g_regex_escape_string(string: *const gchar, length: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_escape_nul(string: *const gchar, length: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_get_compile_flags(regex: *const GRegex) -> GRegexCompileFlags;
}
extern "C" {
    pub fn g_regex_get_match_flags(regex: *const GRegex) -> GRegexMatchFlags;
}
extern "C" {
    pub fn g_regex_match_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match_all(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match_all_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_split_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_regex_split(regex: *const GRegex, string: *const gchar, match_options: GRegexMatchFlags) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_regex_split_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        max_tokens: gint,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_regex_replace(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_replace_literal(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_replace_eval(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        eval: GRegexEvalCallback,
        user_data: gpointer,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_check_replacement(replacement: *const gchar, has_references: *mut gboolean, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_match_info_get_regex(match_info: *const GMatchInfo) -> *mut GRegex;
}
extern "C" {
    pub fn g_match_info_get_string(match_info: *const GMatchInfo) -> *const gchar;
}
extern "C" {
    pub fn g_match_info_ref(match_info: *mut GMatchInfo) -> *mut GMatchInfo;
}
extern "C" {
    pub fn g_match_info_unref(match_info: *mut GMatchInfo);
}
extern "C" {
    pub fn g_match_info_free(match_info: *mut GMatchInfo);
}
extern "C" {
    pub fn g_match_info_next(match_info: *mut GMatchInfo, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_match_info_matches(match_info: *const GMatchInfo) -> gboolean;
}
extern "C" {
    pub fn g_match_info_get_match_count(match_info: *const GMatchInfo) -> gint;
}
extern "C" {
    pub fn g_match_info_is_partial_match(match_info: *const GMatchInfo) -> gboolean;
}
extern "C" {
    pub fn g_match_info_expand_references(
        match_info: *const GMatchInfo,
        string_to_expand: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_match_info_fetch(match_info: *const GMatchInfo, match_num: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_match_info_fetch_pos(match_info: *const GMatchInfo, match_num: gint, start_pos: *mut gint, end_pos: *mut gint) -> gboolean;
}
extern "C" {
    pub fn g_match_info_fetch_named(match_info: *const GMatchInfo, name: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_match_info_fetch_named_pos(
        match_info: *const GMatchInfo,
        name: *const gchar,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_match_info_fetch_all(match_info: *const GMatchInfo) -> *mut *mut gchar;
}
pub type GScanner = _GScanner;
pub type GScannerConfig = _GScannerConfig;
pub type GTokenValue = _GTokenValue;
pub type GScannerMsgFunc = ::std::option::Option<unsafe extern "C" fn(scanner: *mut GScanner, message: *mut gchar, error: gboolean)>;
pub const GErrorType_G_ERR_UNKNOWN: GErrorType = 0;
pub const GErrorType_G_ERR_UNEXP_EOF: GErrorType = 1;
pub const GErrorType_G_ERR_UNEXP_EOF_IN_STRING: GErrorType = 2;
pub const GErrorType_G_ERR_UNEXP_EOF_IN_COMMENT: GErrorType = 3;
pub const GErrorType_G_ERR_NON_DIGIT_IN_CONST: GErrorType = 4;
pub const GErrorType_G_ERR_DIGIT_RADIX: GErrorType = 5;
pub const GErrorType_G_ERR_FLOAT_RADIX: GErrorType = 6;
pub const GErrorType_G_ERR_FLOAT_MALFORMED: GErrorType = 7;
pub type GErrorType = ::std::os::raw::c_uint;
pub const GTokenType_G_TOKEN_EOF: GTokenType = 0;
pub const GTokenType_G_TOKEN_LEFT_PAREN: GTokenType = 40;
pub const GTokenType_G_TOKEN_RIGHT_PAREN: GTokenType = 41;
pub const GTokenType_G_TOKEN_LEFT_CURLY: GTokenType = 123;
pub const GTokenType_G_TOKEN_RIGHT_CURLY: GTokenType = 125;
pub const GTokenType_G_TOKEN_LEFT_BRACE: GTokenType = 91;
pub const GTokenType_G_TOKEN_RIGHT_BRACE: GTokenType = 93;
pub const GTokenType_G_TOKEN_EQUAL_SIGN: GTokenType = 61;
pub const GTokenType_G_TOKEN_COMMA: GTokenType = 44;
pub const GTokenType_G_TOKEN_NONE: GTokenType = 256;
pub const GTokenType_G_TOKEN_ERROR: GTokenType = 257;
pub const GTokenType_G_TOKEN_CHAR: GTokenType = 258;
pub const GTokenType_G_TOKEN_BINARY: GTokenType = 259;
pub const GTokenType_G_TOKEN_OCTAL: GTokenType = 260;
pub const GTokenType_G_TOKEN_INT: GTokenType = 261;
pub const GTokenType_G_TOKEN_HEX: GTokenType = 262;
pub const GTokenType_G_TOKEN_FLOAT: GTokenType = 263;
pub const GTokenType_G_TOKEN_STRING: GTokenType = 264;
pub const GTokenType_G_TOKEN_SYMBOL: GTokenType = 265;
pub const GTokenType_G_TOKEN_IDENTIFIER: GTokenType = 266;
pub const GTokenType_G_TOKEN_IDENTIFIER_NULL: GTokenType = 267;
pub const GTokenType_G_TOKEN_COMMENT_SINGLE: GTokenType = 268;
pub const GTokenType_G_TOKEN_COMMENT_MULTI: GTokenType = 269;
pub const GTokenType_G_TOKEN_LAST: GTokenType = 270;
pub type GTokenType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GTokenValue {
    pub v_symbol: gpointer,
    pub v_identifier: *mut gchar,
    pub v_binary: gulong,
    pub v_octal: gulong,
    pub v_int: gulong,
    pub v_int64: guint64,
    pub v_float: gdouble,
    pub v_hex: gulong,
    pub v_string: *mut gchar,
    pub v_comment: *mut gchar,
    pub v_char: guchar,
    pub v_error: guint,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__GTokenValue() {
    assert_eq!(
        ::std::mem::size_of::<_GTokenValue>(),
        8usize,
        concat!("Size of: ", stringify!(_GTokenValue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTokenValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTokenValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_symbol as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_symbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_identifier as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_identifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_binary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_binary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_octal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_octal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_int64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_int64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_float as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_hex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_hex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_string as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_comment as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_comment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_char as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_error as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GScannerConfig {
    pub cset_skip_characters: *mut gchar,
    pub cset_identifier_first: *mut gchar,
    pub cset_identifier_nth: *mut gchar,
    pub cpair_comment_single: *mut gchar,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub padding_dummy: guint,
}
#[test]
fn bindgen_test_layout__GScannerConfig() {
    assert_eq!(
        ::std::mem::size_of::<_GScannerConfig>(),
        40usize,
        concat!("Size of: ", stringify!(_GScannerConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<_GScannerConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(_GScannerConfig))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScannerConfig>())).cset_skip_characters as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_skip_characters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScannerConfig>())).cset_identifier_first as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_identifier_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScannerConfig>())).cset_identifier_nth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_identifier_nth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScannerConfig>())).cpair_comment_single as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cpair_comment_single)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScannerConfig>())).padding_dummy as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(padding_dummy)
        )
    );
}
impl _GScannerConfig {
    #[inline]
    pub fn case_sensitive(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_case_sensitive(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_comment_multi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_comment_single(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_single(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_comment_multi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier_1char(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_1char(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier_NULL(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_NULL(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_symbols(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_symbols(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_binary(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_binary(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_octal(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_octal(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_float(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_hex(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_hex_dollar(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex_dollar(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_string_sq(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_sq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_string_dq(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_dq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn numbers_2_int(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_numbers_2_int(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int_2_float(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_int_2_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn identifier_2_string(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_identifier_2_string(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn char_2_token(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_char_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn symbol_2_token(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_symbol_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scope_0_fallback(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scope_0_fallback(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn store_int64(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_store_int64(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        case_sensitive: guint,
        skip_comment_multi: guint,
        skip_comment_single: guint,
        scan_comment_multi: guint,
        scan_identifier: guint,
        scan_identifier_1char: guint,
        scan_identifier_NULL: guint,
        scan_symbols: guint,
        scan_binary: guint,
        scan_octal: guint,
        scan_float: guint,
        scan_hex: guint,
        scan_hex_dollar: guint,
        scan_string_sq: guint,
        scan_string_dq: guint,
        numbers_2_int: guint,
        int_2_float: guint,
        identifier_2_string: guint,
        char_2_token: guint,
        symbol_2_token: guint,
        scope_0_fallback: guint,
        store_int64: guint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let case_sensitive: u32 = unsafe { ::std::mem::transmute(case_sensitive) };
            case_sensitive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let skip_comment_multi: u32 = unsafe { ::std::mem::transmute(skip_comment_multi) };
            skip_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let skip_comment_single: u32 = unsafe { ::std::mem::transmute(skip_comment_single) };
            skip_comment_single as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let scan_comment_multi: u32 = unsafe { ::std::mem::transmute(scan_comment_multi) };
            scan_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let scan_identifier: u32 = unsafe { ::std::mem::transmute(scan_identifier) };
            scan_identifier as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let scan_identifier_1char: u32 = unsafe { ::std::mem::transmute(scan_identifier_1char) };
            scan_identifier_1char as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let scan_identifier_NULL: u32 = unsafe { ::std::mem::transmute(scan_identifier_NULL) };
            scan_identifier_NULL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let scan_symbols: u32 = unsafe { ::std::mem::transmute(scan_symbols) };
            scan_symbols as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let scan_binary: u32 = unsafe { ::std::mem::transmute(scan_binary) };
            scan_binary as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let scan_octal: u32 = unsafe { ::std::mem::transmute(scan_octal) };
            scan_octal as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let scan_float: u32 = unsafe { ::std::mem::transmute(scan_float) };
            scan_float as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let scan_hex: u32 = unsafe { ::std::mem::transmute(scan_hex) };
            scan_hex as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let scan_hex_dollar: u32 = unsafe { ::std::mem::transmute(scan_hex_dollar) };
            scan_hex_dollar as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let scan_string_sq: u32 = unsafe { ::std::mem::transmute(scan_string_sq) };
            scan_string_sq as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let scan_string_dq: u32 = unsafe { ::std::mem::transmute(scan_string_dq) };
            scan_string_dq as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let numbers_2_int: u32 = unsafe { ::std::mem::transmute(numbers_2_int) };
            numbers_2_int as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let int_2_float: u32 = unsafe { ::std::mem::transmute(int_2_float) };
            int_2_float as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let identifier_2_string: u32 = unsafe { ::std::mem::transmute(identifier_2_string) };
            identifier_2_string as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let char_2_token: u32 = unsafe { ::std::mem::transmute(char_2_token) };
            char_2_token as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let symbol_2_token: u32 = unsafe { ::std::mem::transmute(symbol_2_token) };
            symbol_2_token as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let scope_0_fallback: u32 = unsafe { ::std::mem::transmute(scope_0_fallback) };
            scope_0_fallback as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let store_int64: u32 = unsafe { ::std::mem::transmute(store_int64) };
            store_int64 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GScanner {
    pub user_data: gpointer,
    pub max_parse_errors: guint,
    pub parse_errors: guint,
    pub input_name: *const gchar,
    pub qdata: *mut GData,
    pub config: *mut GScannerConfig,
    pub token: GTokenType,
    pub value: GTokenValue,
    pub line: guint,
    pub position: guint,
    pub next_token: GTokenType,
    pub next_value: GTokenValue,
    pub next_line: guint,
    pub next_position: guint,
    pub symbol_table: *mut GHashTable,
    pub input_fd: gint,
    pub text: *const gchar,
    pub text_end: *const gchar,
    pub buffer: *mut gchar,
    pub scope_id: guint,
    pub msg_handler: GScannerMsgFunc,
}
#[test]
fn bindgen_test_layout__GScanner() {
    assert_eq!(
        ::std::mem::size_of::<_GScanner>(),
        144usize,
        concat!("Size of: ", stringify!(_GScanner))
    );
    assert_eq!(
        ::std::mem::align_of::<_GScanner>(),
        8usize,
        concat!("Alignment of ", stringify!(_GScanner))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).user_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).max_parse_errors as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(max_parse_errors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).parse_errors as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(parse_errors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).input_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(input_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).qdata as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(qdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).config as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).token as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).value as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).line as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).position as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).next_token as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_token)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).next_value as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).next_line as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).next_position as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).symbol_table as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(symbol_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).input_fd as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(input_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).text as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).text_end as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(text_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).buffer as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).scope_id as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(scope_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).msg_handler as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(msg_handler)
        )
    );
}
extern "C" {
    pub fn g_scanner_new(config_templ: *const GScannerConfig) -> *mut GScanner;
}
extern "C" {
    pub fn g_scanner_destroy(scanner: *mut GScanner);
}
extern "C" {
    pub fn g_scanner_input_file(scanner: *mut GScanner, input_fd: gint);
}
extern "C" {
    pub fn g_scanner_sync_file_offset(scanner: *mut GScanner);
}
extern "C" {
    pub fn g_scanner_input_text(scanner: *mut GScanner, text: *const gchar, text_len: guint);
}
extern "C" {
    pub fn g_scanner_get_next_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    pub fn g_scanner_peek_next_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    pub fn g_scanner_cur_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    pub fn g_scanner_cur_value(scanner: *mut GScanner) -> GTokenValue;
}
extern "C" {
    pub fn g_scanner_cur_line(scanner: *mut GScanner) -> guint;
}
extern "C" {
    pub fn g_scanner_cur_position(scanner: *mut GScanner) -> guint;
}
extern "C" {
    pub fn g_scanner_eof(scanner: *mut GScanner) -> gboolean;
}
extern "C" {
    pub fn g_scanner_set_scope(scanner: *mut GScanner, scope_id: guint) -> guint;
}
extern "C" {
    pub fn g_scanner_scope_add_symbol(scanner: *mut GScanner, scope_id: guint, symbol: *const gchar, value: gpointer);
}
extern "C" {
    pub fn g_scanner_scope_remove_symbol(scanner: *mut GScanner, scope_id: guint, symbol: *const gchar);
}
extern "C" {
    pub fn g_scanner_scope_lookup_symbol(scanner: *mut GScanner, scope_id: guint, symbol: *const gchar) -> gpointer;
}
extern "C" {
    pub fn g_scanner_scope_foreach_symbol(scanner: *mut GScanner, scope_id: guint, func: GHFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_scanner_lookup_symbol(scanner: *mut GScanner, symbol: *const gchar) -> gpointer;
}
extern "C" {
    pub fn g_scanner_unexp_token(
        scanner: *mut GScanner,
        expected_token: GTokenType,
        identifier_spec: *const gchar,
        symbol_spec: *const gchar,
        symbol_name: *const gchar,
        message: *const gchar,
        is_error: gint,
    );
}
extern "C" {
    pub fn g_scanner_error(scanner: *mut GScanner, format: *const gchar, ...);
}
extern "C" {
    pub fn g_scanner_warn(scanner: *mut GScanner, format: *const gchar, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequence {
    _unused: [u8; 0],
}
pub type GSequence = _GSequence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequenceNode {
    _unused: [u8; 0],
}
pub type GSequenceIter = _GSequenceNode;
pub type GSequenceIterCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(a: *mut GSequenceIter, b: *mut GSequenceIter, data: gpointer) -> gint>;
extern "C" {
    pub fn g_sequence_new(data_destroy: GDestroyNotify) -> *mut GSequence;
}
extern "C" {
    pub fn g_sequence_free(seq: *mut GSequence);
}
extern "C" {
    pub fn g_sequence_get_length(seq: *mut GSequence) -> gint;
}
extern "C" {
    pub fn g_sequence_foreach(seq: *mut GSequence, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_sequence_foreach_range(begin: *mut GSequenceIter, end: *mut GSequenceIter, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_sequence_sort(seq: *mut GSequence, cmp_func: GCompareDataFunc, cmp_data: gpointer);
}
extern "C" {
    pub fn g_sequence_sort_iter(seq: *mut GSequence, cmp_func: GSequenceIterCompareFunc, cmp_data: gpointer);
}
extern "C" {
    pub fn g_sequence_is_empty(seq: *mut GSequence) -> gboolean;
}
extern "C" {
    pub fn g_sequence_get_begin_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_get_end_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_get_iter_at_pos(seq: *mut GSequence, pos: gint) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_append(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_prepend(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_insert_before(iter: *mut GSequenceIter, data: gpointer) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_move(src: *mut GSequenceIter, dest: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_swap(a: *mut GSequenceIter, b: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_insert_sorted(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_insert_sorted_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_sort_changed(iter: *mut GSequenceIter, cmp_func: GCompareDataFunc, cmp_data: gpointer);
}
extern "C" {
    pub fn g_sequence_sort_changed_iter(iter: *mut GSequenceIter, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer);
}
extern "C" {
    pub fn g_sequence_remove(iter: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_remove_range(begin: *mut GSequenceIter, end: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_move_range(dest: *mut GSequenceIter, begin: *mut GSequenceIter, end: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_search(seq: *mut GSequence, data: gpointer, cmp_func: GCompareDataFunc, cmp_data: gpointer) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_search_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_lookup(seq: *mut GSequence, data: gpointer, cmp_func: GCompareDataFunc, cmp_data: gpointer) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_lookup_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_get(iter: *mut GSequenceIter) -> gpointer;
}
extern "C" {
    pub fn g_sequence_set(iter: *mut GSequenceIter, data: gpointer);
}
extern "C" {
    pub fn g_sequence_iter_is_begin(iter: *mut GSequenceIter) -> gboolean;
}
extern "C" {
    pub fn g_sequence_iter_is_end(iter: *mut GSequenceIter) -> gboolean;
}
extern "C" {
    pub fn g_sequence_iter_next(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_iter_prev(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_iter_get_position(iter: *mut GSequenceIter) -> gint;
}
extern "C" {
    pub fn g_sequence_iter_move(iter: *mut GSequenceIter, delta: gint) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_iter_get_sequence(iter: *mut GSequenceIter) -> *mut GSequence;
}
extern "C" {
    pub fn g_sequence_iter_compare(a: *mut GSequenceIter, b: *mut GSequenceIter) -> gint;
}
extern "C" {
    pub fn g_sequence_range_get_midpoint(begin: *mut GSequenceIter, end: *mut GSequenceIter) -> *mut GSequenceIter;
}
pub const GShellError_G_SHELL_ERROR_BAD_QUOTING: GShellError = 0;
pub const GShellError_G_SHELL_ERROR_EMPTY_STRING: GShellError = 1;
pub const GShellError_G_SHELL_ERROR_FAILED: GShellError = 2;
pub type GShellError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_shell_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_shell_quote(unquoted_string: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_shell_unquote(quoted_string: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_shell_parse_argv(
        command_line: *const gchar,
        argcp: *mut gint,
        argvp: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_slice_alloc(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_slice_alloc0(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_slice_copy(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_slice_free1(block_size: gsize, mem_block: gpointer);
}
extern "C" {
    pub fn g_slice_free_chain_with_offset(block_size: gsize, mem_chain: gpointer, next_offset: gsize);
}
pub const GSliceConfig_G_SLICE_CONFIG_ALWAYS_MALLOC: GSliceConfig = 1;
pub const GSliceConfig_G_SLICE_CONFIG_BYPASS_MAGAZINES: GSliceConfig = 2;
pub const GSliceConfig_G_SLICE_CONFIG_WORKING_SET_MSECS: GSliceConfig = 3;
pub const GSliceConfig_G_SLICE_CONFIG_COLOR_INCREMENT: GSliceConfig = 4;
pub const GSliceConfig_G_SLICE_CONFIG_CHUNK_SIZES: GSliceConfig = 5;
pub const GSliceConfig_G_SLICE_CONFIG_CONTENTION_COUNTER: GSliceConfig = 6;
pub type GSliceConfig = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_slice_set_config(ckey: GSliceConfig, value: gint64);
}
extern "C" {
    pub fn g_slice_get_config(ckey: GSliceConfig) -> gint64;
}
extern "C" {
    pub fn g_slice_get_config_state(ckey: GSliceConfig, address: gint64, n_values: *mut guint) -> *mut gint64;
}
pub const GSpawnError_G_SPAWN_ERROR_FORK: GSpawnError = 0;
pub const GSpawnError_G_SPAWN_ERROR_READ: GSpawnError = 1;
pub const GSpawnError_G_SPAWN_ERROR_CHDIR: GSpawnError = 2;
pub const GSpawnError_G_SPAWN_ERROR_ACCES: GSpawnError = 3;
pub const GSpawnError_G_SPAWN_ERROR_PERM: GSpawnError = 4;
pub const GSpawnError_G_SPAWN_ERROR_TOO_BIG: GSpawnError = 5;
pub const GSpawnError_G_SPAWN_ERROR_2BIG: GSpawnError = 5;
pub const GSpawnError_G_SPAWN_ERROR_NOEXEC: GSpawnError = 6;
pub const GSpawnError_G_SPAWN_ERROR_NAMETOOLONG: GSpawnError = 7;
pub const GSpawnError_G_SPAWN_ERROR_NOENT: GSpawnError = 8;
pub const GSpawnError_G_SPAWN_ERROR_NOMEM: GSpawnError = 9;
pub const GSpawnError_G_SPAWN_ERROR_NOTDIR: GSpawnError = 10;
pub const GSpawnError_G_SPAWN_ERROR_LOOP: GSpawnError = 11;
pub const GSpawnError_G_SPAWN_ERROR_TXTBUSY: GSpawnError = 12;
pub const GSpawnError_G_SPAWN_ERROR_IO: GSpawnError = 13;
pub const GSpawnError_G_SPAWN_ERROR_NFILE: GSpawnError = 14;
pub const GSpawnError_G_SPAWN_ERROR_MFILE: GSpawnError = 15;
pub const GSpawnError_G_SPAWN_ERROR_INVAL: GSpawnError = 16;
pub const GSpawnError_G_SPAWN_ERROR_ISDIR: GSpawnError = 17;
pub const GSpawnError_G_SPAWN_ERROR_LIBBAD: GSpawnError = 18;
pub const GSpawnError_G_SPAWN_ERROR_FAILED: GSpawnError = 19;
pub type GSpawnError = ::std::os::raw::c_uint;
/// GSpawnChildSetupFunc:
/// @user_data: user data to pass to the function.
///
/// Specifies the type of the setup function passed to g_spawn_async(),
/// g_spawn_sync() and g_spawn_async_with_pipes(), which can, in very
/// limited ways, be used to affect the child's execution.
///
/// On POSIX platforms, the function is called in the child after GLib
/// has performed all the setup it plans to perform, but before calling
/// exec(). Actions taken in this function will only affect the child,
/// not the parent.
///
/// On Windows, the function is called in the parent. Its usefulness on
/// Windows is thus questionable. In many cases executing the child setup
/// function in the parent can have ill effects, and you should be very
/// careful when porting software to Windows that uses child setup
/// functions.
///
/// However, even on POSIX, you are extremely limited in what you can
/// safely do from a #GSpawnChildSetupFunc, because any mutexes that were
/// held by other threads in the parent process at the time of the fork()
/// will still be locked in the child process, and they will never be
/// unlocked (since the threads that held them don't exist in the child).
/// POSIX allows only async-signal-safe functions (see signal(7)) to be
/// called in the child between fork() and exec(), which drastically limits
/// the usefulness of child setup functions.
///
/// In particular, it is not safe to call any function which may
/// call malloc(), which includes POSIX functions such as setenv().
/// If you need to set up the child environment differently from
/// the parent, you should use g_get_environ(), g_environ_setenv(),
/// and g_environ_unsetenv(), and then pass the complete environment
/// list to the `g_spawn...` function.
pub type GSpawnChildSetupFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gpointer)>;
pub const GSpawnFlags_G_SPAWN_DEFAULT: GSpawnFlags = 0;
pub const GSpawnFlags_G_SPAWN_LEAVE_DESCRIPTORS_OPEN: GSpawnFlags = 1;
pub const GSpawnFlags_G_SPAWN_DO_NOT_REAP_CHILD: GSpawnFlags = 2;
pub const GSpawnFlags_G_SPAWN_SEARCH_PATH: GSpawnFlags = 4;
pub const GSpawnFlags_G_SPAWN_STDOUT_TO_DEV_NULL: GSpawnFlags = 8;
pub const GSpawnFlags_G_SPAWN_STDERR_TO_DEV_NULL: GSpawnFlags = 16;
pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDIN: GSpawnFlags = 32;
pub const GSpawnFlags_G_SPAWN_FILE_AND_ARGV_ZERO: GSpawnFlags = 64;
pub const GSpawnFlags_G_SPAWN_SEARCH_PATH_FROM_ENVP: GSpawnFlags = 128;
pub const GSpawnFlags_G_SPAWN_CLOEXEC_PIPES: GSpawnFlags = 256;
pub type GSpawnFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_spawn_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_spawn_exit_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_spawn_async(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_async_with_pipes(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        standard_input: *mut gint,
        standard_output: *mut gint,
        standard_error: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_sync(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        exit_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_command_line_sync(
        command_line: *const gchar,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        exit_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_command_line_async(command_line: *const gchar, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_spawn_check_exit_status(exit_status: gint, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_spawn_close_pid(pid: GPid);
}
pub const GAsciiType_G_ASCII_ALNUM: GAsciiType = 1;
pub const GAsciiType_G_ASCII_ALPHA: GAsciiType = 2;
pub const GAsciiType_G_ASCII_CNTRL: GAsciiType = 4;
pub const GAsciiType_G_ASCII_DIGIT: GAsciiType = 8;
pub const GAsciiType_G_ASCII_GRAPH: GAsciiType = 16;
pub const GAsciiType_G_ASCII_LOWER: GAsciiType = 32;
pub const GAsciiType_G_ASCII_PRINT: GAsciiType = 64;
pub const GAsciiType_G_ASCII_PUNCT: GAsciiType = 128;
pub const GAsciiType_G_ASCII_SPACE: GAsciiType = 256;
pub const GAsciiType_G_ASCII_UPPER: GAsciiType = 512;
pub const GAsciiType_G_ASCII_XDIGIT: GAsciiType = 1024;
pub type GAsciiType = ::std::os::raw::c_uint;
extern "C" {
    pub static mut g_ascii_table: *const guint16;
}
extern "C" {
    pub fn g_ascii_tolower(c: gchar) -> gchar;
}
extern "C" {
    pub fn g_ascii_toupper(c: gchar) -> gchar;
}
extern "C" {
    pub fn g_ascii_digit_value(c: gchar) -> gint;
}
extern "C" {
    pub fn g_ascii_xdigit_value(c: gchar) -> gint;
}
extern "C" {
    pub fn g_strdelimit(string: *mut gchar, delimiters: *const gchar, new_delimiter: gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strcanon(string: *mut gchar, valid_chars: *const gchar, substitutor: gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strerror(errnum: gint) -> *const gchar;
}
extern "C" {
    pub fn g_strsignal(signum: gint) -> *const gchar;
}
extern "C" {
    pub fn g_strreverse(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strlcpy(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
extern "C" {
    pub fn g_strlcat(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
extern "C" {
    pub fn g_strstr_len(haystack: *const gchar, haystack_len: gssize, needle: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strrstr(haystack: *const gchar, needle: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strrstr_len(haystack: *const gchar, haystack_len: gssize, needle: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_str_has_suffix(str: *const gchar, suffix: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_str_has_prefix(str: *const gchar, prefix: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
extern "C" {
    pub fn g_ascii_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
extern "C" {
    pub fn g_ascii_strtoull(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> guint64;
}
extern "C" {
    pub fn g_ascii_strtoll(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> gint64;
}
extern "C" {
    pub fn g_ascii_dtostr(buffer: *mut gchar, buf_len: gint, d: gdouble) -> *mut gchar;
}
extern "C" {
    pub fn g_ascii_formatd(buffer: *mut gchar, buf_len: gint, format: *const gchar, d: gdouble) -> *mut gchar;
}
extern "C" {
    pub fn g_strchug(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strchomp(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_ascii_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
extern "C" {
    pub fn g_ascii_strncasecmp(s1: *const gchar, s2: *const gchar, n: gsize) -> gint;
}
extern "C" {
    pub fn g_ascii_strdown(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_ascii_strup(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_str_is_ascii(str: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
extern "C" {
    pub fn g_strncasecmp(s1: *const gchar, s2: *const gchar, n: guint) -> gint;
}
extern "C" {
    pub fn g_strdown(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strup(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strdup(str: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strdup_printf(format: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_strdup_vprintf(format: *const gchar, args: *mut __va_list_tag) -> *mut gchar;
}
extern "C" {
    pub fn g_strndup(str: *const gchar, n: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_strnfill(length: gsize, fill_char: gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strconcat(string1: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_strjoin(separator: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_strcompress(source: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strescape(source: *const gchar, exceptions: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_memdup(mem: gconstpointer, byte_size: guint) -> gpointer;
}
pub type GStrv = *mut *mut gchar;
extern "C" {
    pub fn g_strsplit(string: *const gchar, delimiter: *const gchar, max_tokens: gint) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_strsplit_set(string: *const gchar, delimiters: *const gchar, max_tokens: gint) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_strjoinv(separator: *const gchar, str_array: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strfreev(str_array: *mut *mut gchar);
}
extern "C" {
    pub fn g_strdupv(str_array: *mut *mut gchar) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_strv_length(str_array: *mut *mut gchar) -> guint;
}
extern "C" {
    pub fn g_stpcpy(dest: *mut gchar, src: *const ::std::os::raw::c_char) -> *mut gchar;
}
extern "C" {
    pub fn g_str_to_ascii(str: *const gchar, from_locale: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_str_tokenize_and_fold(
        string: *const gchar,
        translit_locale: *const gchar,
        ascii_alternates: *mut *mut *mut gchar,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_str_match_string(search_term: *const gchar, potential_hit: *const gchar, accept_alternates: gboolean) -> gboolean;
}
extern "C" {
    pub fn g_strv_contains(strv: *const *const gchar, str: *const gchar) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStringChunk {
    _unused: [u8; 0],
}
pub type GStringChunk = _GStringChunk;
extern "C" {
    pub fn g_string_chunk_new(size: gsize) -> *mut GStringChunk;
}
extern "C" {
    pub fn g_string_chunk_free(chunk: *mut GStringChunk);
}
extern "C" {
    pub fn g_string_chunk_clear(chunk: *mut GStringChunk);
}
extern "C" {
    pub fn g_string_chunk_insert(chunk: *mut GStringChunk, string: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_string_chunk_insert_len(chunk: *mut GStringChunk, string: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_string_chunk_insert_const(chunk: *mut GStringChunk, string: *const gchar) -> *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestCase {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestSuite {
    _unused: [u8; 0],
}
pub type GTestFunc = ::std::option::Option<unsafe extern "C" fn()>;
pub type GTestDataFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gconstpointer)>;
pub type GTestFixtureFunc = ::std::option::Option<unsafe extern "C" fn(fixture: gpointer, user_data: gconstpointer)>;
extern "C" {
    pub fn g_strcmp0(str1: *const ::std::os::raw::c_char, str2: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_test_minimized_result(minimized_quantity: f64, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn g_test_maximized_result(maximized_quantity: f64, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn g_test_init(argc: *mut ::std::os::raw::c_int, argv: *mut *mut *mut ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn g_test_subprocess() -> gboolean;
}
extern "C" {
    pub fn g_test_run() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_test_add_func(testpath: *const ::std::os::raw::c_char, test_func: GTestFunc);
}
extern "C" {
    pub fn g_test_add_data_func(testpath: *const ::std::os::raw::c_char, test_data: gconstpointer, test_func: GTestDataFunc);
}
extern "C" {
    pub fn g_test_add_data_func_full(
        testpath: *const ::std::os::raw::c_char,
        test_data: gpointer,
        test_func: GTestDataFunc,
        data_free_func: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_test_fail();
}
extern "C" {
    pub fn g_test_incomplete(msg: *const gchar);
}
extern "C" {
    pub fn g_test_skip(msg: *const gchar);
}
extern "C" {
    pub fn g_test_failed() -> gboolean;
}
extern "C" {
    pub fn g_test_set_nonfatal_assertions();
}
extern "C" {
    pub fn g_test_message(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn g_test_bug_base(uri_pattern: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_test_bug(bug_uri_snippet: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_test_timer_start();
}
extern "C" {
    pub fn g_test_timer_elapsed() -> f64;
}
extern "C" {
    pub fn g_test_timer_last() -> f64;
}
extern "C" {
    pub fn g_test_queue_free(gfree_pointer: gpointer);
}
extern "C" {
    pub fn g_test_queue_destroy(destroy_func: GDestroyNotify, destroy_data: gpointer);
}
pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDOUT: GTestTrapFlags = 128;
pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDERR: GTestTrapFlags = 256;
pub const GTestTrapFlags_G_TEST_TRAP_INHERIT_STDIN: GTestTrapFlags = 512;
pub type GTestTrapFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_test_trap_fork(usec_timeout: guint64, test_trap_flags: GTestTrapFlags) -> gboolean;
}
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDIN: GTestSubprocessFlags = 1;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDOUT: GTestSubprocessFlags = 2;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDERR: GTestSubprocessFlags = 4;
pub type GTestSubprocessFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_test_trap_subprocess(test_path: *const ::std::os::raw::c_char, usec_timeout: guint64, test_flags: GTestSubprocessFlags);
}
extern "C" {
    pub fn g_test_trap_has_passed() -> gboolean;
}
extern "C" {
    pub fn g_test_trap_reached_timeout() -> gboolean;
}
extern "C" {
    pub fn g_test_rand_int() -> gint32;
}
extern "C" {
    pub fn g_test_rand_int_range(begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    pub fn g_test_rand_double() -> f64;
}
extern "C" {
    pub fn g_test_rand_double_range(range_start: f64, range_end: f64) -> f64;
}
extern "C" {
    pub fn g_test_create_case(
        test_name: *const ::std::os::raw::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    ) -> *mut GTestCase;
}
extern "C" {
    pub fn g_test_create_suite(suite_name: *const ::std::os::raw::c_char) -> *mut GTestSuite;
}
extern "C" {
    pub fn g_test_get_root() -> *mut GTestSuite;
}
extern "C" {
    pub fn g_test_suite_add(suite: *mut GTestSuite, test_case: *mut GTestCase);
}
extern "C" {
    pub fn g_test_suite_add_suite(suite: *mut GTestSuite, nestedsuite: *mut GTestSuite);
}
extern "C" {
    pub fn g_test_run_suite(suite: *mut GTestSuite) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_test_trap_assertions(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        assertion_flags: guint64,
        pattern: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_expr(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_cmpstr(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        cmp: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_cmpnum(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: f64,
        cmp: *const ::std::os::raw::c_char,
        arg2: f64,
        numtype: ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_error(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        error: *const GError,
        error_domain: GQuark,
        error_code: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn g_test_add_vtable(
        testpath: *const ::std::os::raw::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestConfig {
    pub test_initialized: gboolean,
    pub test_quick: gboolean,
    pub test_perf: gboolean,
    pub test_verbose: gboolean,
    pub test_quiet: gboolean,
    pub test_undefined: gboolean,
}
#[test]
fn bindgen_test_layout_GTestConfig() {
    assert_eq!(
        ::std::mem::size_of::<GTestConfig>(),
        24usize,
        concat!("Size of: ", stringify!(GTestConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<GTestConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(GTestConfig))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestConfig>())).test_initialized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestConfig>())).test_quick as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_quick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestConfig>())).test_perf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_perf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestConfig>())).test_verbose as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_verbose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestConfig>())).test_quiet as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_quiet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestConfig>())).test_undefined as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_undefined)
        )
    );
}
extern "C" {
    pub static mut g_test_config_vars: *const GTestConfig;
}
pub const GTestLogType_G_TEST_LOG_NONE: GTestLogType = 0;
pub const GTestLogType_G_TEST_LOG_ERROR: GTestLogType = 1;
pub const GTestLogType_G_TEST_LOG_START_BINARY: GTestLogType = 2;
pub const GTestLogType_G_TEST_LOG_LIST_CASE: GTestLogType = 3;
pub const GTestLogType_G_TEST_LOG_SKIP_CASE: GTestLogType = 4;
pub const GTestLogType_G_TEST_LOG_START_CASE: GTestLogType = 5;
pub const GTestLogType_G_TEST_LOG_STOP_CASE: GTestLogType = 6;
pub const GTestLogType_G_TEST_LOG_MIN_RESULT: GTestLogType = 7;
pub const GTestLogType_G_TEST_LOG_MAX_RESULT: GTestLogType = 8;
pub const GTestLogType_G_TEST_LOG_MESSAGE: GTestLogType = 9;
pub const GTestLogType_G_TEST_LOG_START_SUITE: GTestLogType = 10;
pub const GTestLogType_G_TEST_LOG_STOP_SUITE: GTestLogType = 11;
pub type GTestLogType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogMsg {
    pub log_type: GTestLogType,
    pub n_strings: guint,
    pub strings: *mut *mut gchar,
    pub n_nums: guint,
    pub nums: *mut f64,
}
#[test]
fn bindgen_test_layout_GTestLogMsg() {
    assert_eq!(
        ::std::mem::size_of::<GTestLogMsg>(),
        32usize,
        concat!("Size of: ", stringify!(GTestLogMsg))
    );
    assert_eq!(
        ::std::mem::align_of::<GTestLogMsg>(),
        8usize,
        concat!("Alignment of ", stringify!(GTestLogMsg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestLogMsg>())).log_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(log_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestLogMsg>())).n_strings as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(n_strings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestLogMsg>())).strings as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(strings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestLogMsg>())).n_nums as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(n_nums)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestLogMsg>())).nums as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(nums)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogBuffer {
    pub data: *mut GString,
    pub msgs: *mut GSList,
}
#[test]
fn bindgen_test_layout_GTestLogBuffer() {
    assert_eq!(
        ::std::mem::size_of::<GTestLogBuffer>(),
        16usize,
        concat!("Size of: ", stringify!(GTestLogBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<GTestLogBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(GTestLogBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestLogBuffer>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogBuffer),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestLogBuffer>())).msgs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogBuffer),
            "::",
            stringify!(msgs)
        )
    );
}
extern "C" {
    pub fn g_test_log_type_name(log_type: GTestLogType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_test_log_buffer_new() -> *mut GTestLogBuffer;
}
extern "C" {
    pub fn g_test_log_buffer_free(tbuffer: *mut GTestLogBuffer);
}
extern "C" {
    pub fn g_test_log_buffer_push(tbuffer: *mut GTestLogBuffer, n_bytes: guint, bytes: *const guint8);
}
extern "C" {
    pub fn g_test_log_buffer_pop(tbuffer: *mut GTestLogBuffer) -> *mut GTestLogMsg;
}
extern "C" {
    pub fn g_test_log_msg_free(tmsg: *mut GTestLogMsg);
}
/// GTestLogFatalFunc:
/// @log_domain: the log domain of the message
/// @log_level: the log level of the message (including the fatal and recursion flags)
/// @message: the message to process
/// @user_data: user data, set in g_test_log_set_fatal_handler()
///
/// Specifies the prototype of fatal log handler functions.
///
/// Returns: %TRUE if the program should abort, %FALSE otherwise
///
/// Since: 2.22
pub type GTestLogFatalFunc = ::std::option::Option<
    unsafe extern "C" fn(log_domain: *const gchar, log_level: GLogLevelFlags, message: *const gchar, user_data: gpointer) -> gboolean,
>;
extern "C" {
    pub fn g_test_log_set_fatal_handler(log_func: GTestLogFatalFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_test_expect_message(log_domain: *const gchar, log_level: GLogLevelFlags, pattern: *const gchar);
}
extern "C" {
    pub fn g_test_assert_expected_messages_internal(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
    );
}
pub const GTestFileType_G_TEST_DIST: GTestFileType = 0;
pub const GTestFileType_G_TEST_BUILT: GTestFileType = 1;
pub type GTestFileType = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_test_build_filename(file_type: GTestFileType, first_path: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_test_get_dir(file_type: GTestFileType) -> *const gchar;
}
extern "C" {
    pub fn g_test_get_filename(file_type: GTestFileType, first_path: *const gchar, ...) -> *const gchar;
}
pub type GThreadPool = _GThreadPool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadPool {
    pub func: GFunc,
    pub user_data: gpointer,
    pub exclusive: gboolean,
}
#[test]
fn bindgen_test_layout__GThreadPool() {
    assert_eq!(
        ::std::mem::size_of::<_GThreadPool>(),
        24usize,
        concat!("Size of: ", stringify!(_GThreadPool))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThreadPool>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadPool))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadPool>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadPool>())).user_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadPool>())).exclusive as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(exclusive)
        )
    );
}
extern "C" {
    pub fn g_thread_pool_new(
        func: GFunc,
        user_data: gpointer,
        max_threads: gint,
        exclusive: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThreadPool;
}
extern "C" {
    pub fn g_thread_pool_free(pool: *mut GThreadPool, immediate: gboolean, wait_: gboolean);
}
extern "C" {
    pub fn g_thread_pool_push(pool: *mut GThreadPool, data: gpointer, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_thread_pool_unprocessed(pool: *mut GThreadPool) -> guint;
}
extern "C" {
    pub fn g_thread_pool_set_sort_function(pool: *mut GThreadPool, func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_thread_pool_move_to_front(pool: *mut GThreadPool, data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_thread_pool_set_max_threads(pool: *mut GThreadPool, max_threads: gint, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_thread_pool_get_max_threads(pool: *mut GThreadPool) -> gint;
}
extern "C" {
    pub fn g_thread_pool_get_num_threads(pool: *mut GThreadPool) -> guint;
}
extern "C" {
    pub fn g_thread_pool_set_max_unused_threads(max_threads: gint);
}
extern "C" {
    pub fn g_thread_pool_get_max_unused_threads() -> gint;
}
extern "C" {
    pub fn g_thread_pool_get_num_unused_threads() -> guint;
}
extern "C" {
    pub fn g_thread_pool_stop_unused_threads();
}
extern "C" {
    pub fn g_thread_pool_set_max_idle_time(interval: guint);
}
extern "C" {
    pub fn g_thread_pool_get_max_idle_time() -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimer {
    _unused: [u8; 0],
}
pub type GTimer = _GTimer;
extern "C" {
    pub fn g_timer_new() -> *mut GTimer;
}
extern "C" {
    pub fn g_timer_destroy(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_start(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_stop(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_reset(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_continue(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_elapsed(timer: *mut GTimer, microseconds: *mut gulong) -> gdouble;
}
extern "C" {
    pub fn g_usleep(microseconds: gulong);
}
extern "C" {
    pub fn g_time_val_add(time_: *mut GTimeVal, microseconds: glong);
}
extern "C" {
    pub fn g_time_val_from_iso8601(iso_date: *const gchar, time_: *mut GTimeVal) -> gboolean;
}
extern "C" {
    pub fn g_time_val_to_iso8601(time_: *mut GTimeVal) -> *mut gchar;
}
pub type GTrashStack = _GTrashStack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTrashStack {
    pub next: *mut GTrashStack,
}
#[test]
fn bindgen_test_layout__GTrashStack() {
    assert_eq!(
        ::std::mem::size_of::<_GTrashStack>(),
        8usize,
        concat!("Size of: ", stringify!(_GTrashStack))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTrashStack>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTrashStack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTrashStack>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTrashStack),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn g_trash_stack_push(stack_p: *mut *mut GTrashStack, data_p: gpointer);
}
extern "C" {
    pub fn g_trash_stack_pop(stack_p: *mut *mut GTrashStack) -> gpointer;
}
extern "C" {
    pub fn g_trash_stack_peek(stack_p: *mut *mut GTrashStack) -> gpointer;
}
extern "C" {
    pub fn g_trash_stack_height(stack_p: *mut *mut GTrashStack) -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTree {
    _unused: [u8; 0],
}
pub type GTree = _GTree;
pub type GTraverseFunc = ::std::option::Option<unsafe extern "C" fn(key: gpointer, value: gpointer, data: gpointer) -> gboolean>;
extern "C" {
    pub fn g_tree_new(key_compare_func: GCompareFunc) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_new_with_data(key_compare_func: GCompareDataFunc, key_compare_data: gpointer) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_new_full(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_ref(tree: *mut GTree) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_unref(tree: *mut GTree);
}
extern "C" {
    pub fn g_tree_destroy(tree: *mut GTree);
}
extern "C" {
    pub fn g_tree_insert(tree: *mut GTree, key: gpointer, value: gpointer);
}
extern "C" {
    pub fn g_tree_replace(tree: *mut GTree, key: gpointer, value: gpointer);
}
extern "C" {
    pub fn g_tree_remove(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_tree_steal(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_tree_lookup(tree: *mut GTree, key: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_tree_lookup_extended(tree: *mut GTree, lookup_key: gconstpointer, orig_key: *mut gpointer, value: *mut gpointer) -> gboolean;
}
extern "C" {
    pub fn g_tree_foreach(tree: *mut GTree, func: GTraverseFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_tree_traverse(tree: *mut GTree, traverse_func: GTraverseFunc, traverse_type: GTraverseType, user_data: gpointer);
}
extern "C" {
    pub fn g_tree_search(tree: *mut GTree, search_func: GCompareFunc, user_data: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_tree_height(tree: *mut GTree) -> gint;
}
extern "C" {
    pub fn g_tree_nnodes(tree: *mut GTree) -> gint;
}
extern "C" {
    pub fn g_uri_unescape_string(
        escaped_string: *const ::std::os::raw::c_char,
        illegal_characters: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_unescape_segment(
        escaped_string: *const ::std::os::raw::c_char,
        escaped_string_end: *const ::std::os::raw::c_char,
        illegal_characters: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_parse_scheme(uri: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_escape_string(
        unescaped: *const ::std::os::raw::c_char,
        reserved_chars_allowed: *const ::std::os::raw::c_char,
        allow_utf8: gboolean,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantType {
    _unused: [u8; 0],
}
/// GVariantType:
///
/// A type in the GVariant type system.
///
/// Two types may not be compared by value; use g_variant_type_equal() or
/// g_variant_type_is_subtype_of().  May be copied using
/// g_variant_type_copy() and freed using g_variant_type_free().
pub type GVariantType = _GVariantType;
extern "C" {
    pub fn g_variant_type_string_is_valid(type_string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_string_scan(string: *const gchar, limit: *const gchar, endptr: *mut *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_free(type_: *mut GVariantType);
}
extern "C" {
    pub fn g_variant_type_copy(type_: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new(type_string: *const gchar) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_get_string_length(type_: *const GVariantType) -> gsize;
}
extern "C" {
    pub fn g_variant_type_peek_string(type_: *const GVariantType) -> *const gchar;
}
extern "C" {
    pub fn g_variant_type_dup_string(type_: *const GVariantType) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_type_is_definite(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_container(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_basic(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_maybe(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_array(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_tuple(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_dict_entry(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_variant(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_hash(type_: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_variant_type_equal(type1: gconstpointer, type2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_subtype_of(type_: *const GVariantType, supertype: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_element(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_first(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_next(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_n_items(type_: *const GVariantType) -> gsize;
}
extern "C" {
    pub fn g_variant_type_key(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_value(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_array(element: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_maybe(element: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_tuple(items: *const *const GVariantType, length: gint) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_dict_entry(key: *const GVariantType, value: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_checked_(arg1: *const gchar) -> *const GVariantType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariant {
    _unused: [u8; 0],
}
pub type GVariant = _GVariant;
pub const GVariantClass_G_VARIANT_CLASS_BOOLEAN: GVariantClass = 98;
pub const GVariantClass_G_VARIANT_CLASS_BYTE: GVariantClass = 121;
pub const GVariantClass_G_VARIANT_CLASS_INT16: GVariantClass = 110;
pub const GVariantClass_G_VARIANT_CLASS_UINT16: GVariantClass = 113;
pub const GVariantClass_G_VARIANT_CLASS_INT32: GVariantClass = 105;
pub const GVariantClass_G_VARIANT_CLASS_UINT32: GVariantClass = 117;
pub const GVariantClass_G_VARIANT_CLASS_INT64: GVariantClass = 120;
pub const GVariantClass_G_VARIANT_CLASS_UINT64: GVariantClass = 116;
pub const GVariantClass_G_VARIANT_CLASS_HANDLE: GVariantClass = 104;
pub const GVariantClass_G_VARIANT_CLASS_DOUBLE: GVariantClass = 100;
pub const GVariantClass_G_VARIANT_CLASS_STRING: GVariantClass = 115;
pub const GVariantClass_G_VARIANT_CLASS_OBJECT_PATH: GVariantClass = 111;
pub const GVariantClass_G_VARIANT_CLASS_SIGNATURE: GVariantClass = 103;
pub const GVariantClass_G_VARIANT_CLASS_VARIANT: GVariantClass = 118;
pub const GVariantClass_G_VARIANT_CLASS_MAYBE: GVariantClass = 109;
pub const GVariantClass_G_VARIANT_CLASS_ARRAY: GVariantClass = 97;
pub const GVariantClass_G_VARIANT_CLASS_TUPLE: GVariantClass = 40;
pub const GVariantClass_G_VARIANT_CLASS_DICT_ENTRY: GVariantClass = 123;
pub type GVariantClass = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_variant_unref(value: *mut GVariant);
}
extern "C" {
    pub fn g_variant_ref(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_ref_sink(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_floating(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_take_ref(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_type(value: *mut GVariant) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_get_type_string(value: *mut GVariant) -> *const gchar;
}
extern "C" {
    pub fn g_variant_is_of_type(value: *mut GVariant, type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_is_container(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_classify(value: *mut GVariant) -> GVariantClass;
}
extern "C" {
    pub fn g_variant_new_boolean(value: gboolean) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_byte(value: guchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_int16(value: gint16) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_uint16(value: guint16) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_int32(value: gint32) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_uint32(value: guint32) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_int64(value: gint64) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_uint64(value: guint64) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_handle(value: gint32) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_double(value: gdouble) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_string(string: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_take_string(string: *mut gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_printf(format_string: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_object_path(object_path: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_object_path(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_new_signature(signature: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_signature(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_new_variant(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_strv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_objv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_bytestring(string: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_bytestring_array(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_fixed_array(
        element_type: *const GVariantType,
        elements: gconstpointer,
        n_elements: gsize,
        element_size: gsize,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_boolean(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_get_byte(value: *mut GVariant) -> guchar;
}
extern "C" {
    pub fn g_variant_get_int16(value: *mut GVariant) -> gint16;
}
extern "C" {
    pub fn g_variant_get_uint16(value: *mut GVariant) -> guint16;
}
extern "C" {
    pub fn g_variant_get_int32(value: *mut GVariant) -> gint32;
}
extern "C" {
    pub fn g_variant_get_uint32(value: *mut GVariant) -> guint32;
}
extern "C" {
    pub fn g_variant_get_int64(value: *mut GVariant) -> gint64;
}
extern "C" {
    pub fn g_variant_get_uint64(value: *mut GVariant) -> guint64;
}
extern "C" {
    pub fn g_variant_get_handle(value: *mut GVariant) -> gint32;
}
extern "C" {
    pub fn g_variant_get_double(value: *mut GVariant) -> gdouble;
}
extern "C" {
    pub fn g_variant_get_variant(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_string(value: *mut GVariant, length: *mut gsize) -> *const gchar;
}
extern "C" {
    pub fn g_variant_dup_string(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_get_strv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
extern "C" {
    pub fn g_variant_dup_strv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_variant_get_objv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
extern "C" {
    pub fn g_variant_dup_objv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_variant_get_bytestring(value: *mut GVariant) -> *const gchar;
}
extern "C" {
    pub fn g_variant_dup_bytestring(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_get_bytestring_array(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
extern "C" {
    pub fn g_variant_dup_bytestring_array(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_variant_new_maybe(child_type: *const GVariantType, child: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_array(child_type: *const GVariantType, children: *const *const GVariant, n_children: gsize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_tuple(children: *const *const GVariant, n_children: gsize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_dict_entry(key: *mut GVariant, value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_maybe(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_n_children(value: *mut GVariant) -> gsize;
}
extern "C" {
    pub fn g_variant_get_child(value: *mut GVariant, index_: gsize, format_string: *const gchar, ...);
}
extern "C" {
    pub fn g_variant_get_child_value(value: *mut GVariant, index_: gsize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_lookup(dictionary: *mut GVariant, key: *const gchar, format_string: *const gchar, ...) -> gboolean;
}
extern "C" {
    pub fn g_variant_lookup_value(dictionary: *mut GVariant, key: *const gchar, expected_type: *const GVariantType) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_fixed_array(value: *mut GVariant, n_elements: *mut gsize, element_size: gsize) -> gconstpointer;
}
extern "C" {
    pub fn g_variant_get_size(value: *mut GVariant) -> gsize;
}
extern "C" {
    pub fn g_variant_get_data(value: *mut GVariant) -> gconstpointer;
}
extern "C" {
    pub fn g_variant_get_data_as_bytes(value: *mut GVariant) -> *mut GBytes;
}
extern "C" {
    pub fn g_variant_store(value: *mut GVariant, data: gpointer);
}
extern "C" {
    pub fn g_variant_print(value: *mut GVariant, type_annotate: gboolean) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_print_string(value: *mut GVariant, string: *mut GString, type_annotate: gboolean) -> *mut GString;
}
extern "C" {
    pub fn g_variant_hash(value: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_variant_equal(one: gconstpointer, two: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_variant_get_normal_form(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_normal_form(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_byteswap(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_from_bytes(type_: *const GVariantType, bytes: *mut GBytes, trusted: gboolean) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_from_data(
        type_: *const GVariantType,
        data: gconstpointer,
        size: gsize,
        trusted: gboolean,
        notify: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GVariant;
}
pub type GVariantIter = _GVariantIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantIter {
    pub x: [gsize; 16usize],
}
#[test]
fn bindgen_test_layout__GVariantIter() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantIter>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantIter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantIter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVariantIter>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantIter),
            "::",
            stringify!(x)
        )
    );
}
extern "C" {
    pub fn g_variant_iter_new(value: *mut GVariant) -> *mut GVariantIter;
}
extern "C" {
    pub fn g_variant_iter_init(iter: *mut GVariantIter, value: *mut GVariant) -> gsize;
}
extern "C" {
    pub fn g_variant_iter_copy(iter: *mut GVariantIter) -> *mut GVariantIter;
}
extern "C" {
    pub fn g_variant_iter_n_children(iter: *mut GVariantIter) -> gsize;
}
extern "C" {
    pub fn g_variant_iter_free(iter: *mut GVariantIter);
}
extern "C" {
    pub fn g_variant_iter_next_value(iter: *mut GVariantIter) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_iter_next(iter: *mut GVariantIter, format_string: *const gchar, ...) -> gboolean;
}
extern "C" {
    pub fn g_variant_iter_loop(iter: *mut GVariantIter, format_string: *const gchar, ...) -> gboolean;
}
pub type GVariantBuilder = _GVariantBuilder;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantBuilder {
    pub x: [gsize; 16usize],
}
#[test]
fn bindgen_test_layout__GVariantBuilder() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantBuilder>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantBuilder))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantBuilder))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVariantBuilder>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder),
            "::",
            stringify!(x)
        )
    );
}
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_FAILED: GVariantParseError = 0;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED: GVariantParseError = 1;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE: GVariantParseError = 2;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED: GVariantParseError = 3;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END: GVariantParseError = 4;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_CHARACTER: GVariantParseError = 5;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING: GVariantParseError = 6;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH: GVariantParseError = 7;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE: GVariantParseError = 8;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING: GVariantParseError = 9;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE: GVariantParseError = 10;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE: GVariantParseError = 11;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG: GVariantParseError = 12;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_TYPE_ERROR: GVariantParseError = 13;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN: GVariantParseError = 14;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD: GVariantParseError = 15;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT: GVariantParseError = 16;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_VALUE_EXPECTED: GVariantParseError = 17;
pub type GVariantParseError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_variant_parser_get_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_variant_parse_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_variant_builder_new(type_: *const GVariantType) -> *mut GVariantBuilder;
}
extern "C" {
    pub fn g_variant_builder_unref(builder: *mut GVariantBuilder);
}
extern "C" {
    pub fn g_variant_builder_ref(builder: *mut GVariantBuilder) -> *mut GVariantBuilder;
}
extern "C" {
    pub fn g_variant_builder_init(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
extern "C" {
    pub fn g_variant_builder_end(builder: *mut GVariantBuilder) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_builder_clear(builder: *mut GVariantBuilder);
}
extern "C" {
    pub fn g_variant_builder_open(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
extern "C" {
    pub fn g_variant_builder_close(builder: *mut GVariantBuilder);
}
extern "C" {
    pub fn g_variant_builder_add_value(builder: *mut GVariantBuilder, value: *mut GVariant);
}
extern "C" {
    pub fn g_variant_builder_add(builder: *mut GVariantBuilder, format_string: *const gchar, ...);
}
extern "C" {
    pub fn g_variant_builder_add_parsed(builder: *mut GVariantBuilder, format: *const gchar, ...);
}
extern "C" {
    pub fn g_variant_new(format_string: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get(value: *mut GVariant, format_string: *const gchar, ...);
}
extern "C" {
    pub fn g_variant_new_va(format_string: *const gchar, endptr: *mut *const gchar, app: *mut va_list) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_va(value: *mut GVariant, format_string: *const gchar, endptr: *mut *const gchar, app: *mut va_list);
}
extern "C" {
    pub fn g_variant_check_format_string(value: *mut GVariant, format_string: *const gchar, copy_only: gboolean) -> gboolean;
}
extern "C" {
    pub fn g_variant_parse(
        type_: *const GVariantType,
        text: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_parsed(format: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_parsed_va(format: *const gchar, app: *mut va_list) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_parse_error_print_context(error: *mut GError, source_str: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_compare(one: gconstpointer, two: gconstpointer) -> gint;
}
pub type GVariantDict = _GVariantDict;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantDict {
    pub x: [gsize; 16usize],
}
#[test]
fn bindgen_test_layout__GVariantDict() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantDict>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantDict))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantDict>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantDict))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVariantDict>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict),
            "::",
            stringify!(x)
        )
    );
}
extern "C" {
    pub fn g_variant_dict_new(from_asv: *mut GVariant) -> *mut GVariantDict;
}
extern "C" {
    pub fn g_variant_dict_init(dict: *mut GVariantDict, from_asv: *mut GVariant);
}
extern "C" {
    pub fn g_variant_dict_lookup(dict: *mut GVariantDict, key: *const gchar, format_string: *const gchar, ...) -> gboolean;
}
extern "C" {
    pub fn g_variant_dict_lookup_value(dict: *mut GVariantDict, key: *const gchar, expected_type: *const GVariantType) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_dict_contains(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_dict_insert(dict: *mut GVariantDict, key: *const gchar, format_string: *const gchar, ...);
}
extern "C" {
    pub fn g_variant_dict_insert_value(dict: *mut GVariantDict, key: *const gchar, value: *mut GVariant);
}
extern "C" {
    pub fn g_variant_dict_remove(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_dict_clear(dict: *mut GVariantDict);
}
extern "C" {
    pub fn g_variant_dict_end(dict: *mut GVariantDict) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_dict_ref(dict: *mut GVariantDict) -> *mut GVariantDict;
}
extern "C" {
    pub fn g_variant_dict_unref(dict: *mut GVariantDict);
}
extern "C" {
    pub static mut glib_major_version: guint;
}
extern "C" {
    pub static mut glib_minor_version: guint;
}
extern "C" {
    pub static mut glib_micro_version: guint;
}
extern "C" {
    pub static mut glib_interface_age: guint;
}
extern "C" {
    pub static mut glib_binary_age: guint;
}
extern "C" {
    pub fn glib_check_version(required_major: guint, required_minor: guint, required_micro: guint) -> *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAllocator {
    _unused: [u8; 0],
}
pub type GAllocator = _GAllocator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemChunk {
    _unused: [u8; 0],
}
pub type GMemChunk = _GMemChunk;
extern "C" {
    pub fn g_mem_chunk_new(name: *const gchar, atom_size: gint, area_size: gsize, type_: gint) -> *mut GMemChunk;
}
extern "C" {
    pub fn g_mem_chunk_destroy(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_alloc(mem_chunk: *mut GMemChunk) -> gpointer;
}
extern "C" {
    pub fn g_mem_chunk_alloc0(mem_chunk: *mut GMemChunk) -> gpointer;
}
extern "C" {
    pub fn g_mem_chunk_free(mem_chunk: *mut GMemChunk, mem: gpointer);
}
extern "C" {
    pub fn g_mem_chunk_clean(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_reset(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_print(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_info();
}
extern "C" {
    pub fn g_blow_chunks();
}
extern "C" {
    pub fn g_allocator_new(name: *const gchar, n_preallocs: guint) -> *mut GAllocator;
}
extern "C" {
    pub fn g_allocator_free(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_list_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_list_pop_allocator();
}
extern "C" {
    pub fn g_slist_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_slist_pop_allocator();
}
extern "C" {
    pub fn g_node_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_node_pop_allocator();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCache {
    _unused: [u8; 0],
}
pub type GCache = _GCache;
pub type GCacheNewFunc = ::std::option::Option<unsafe extern "C" fn(key: gpointer) -> gpointer>;
pub type GCacheDupFunc = ::std::option::Option<unsafe extern "C" fn(value: gpointer) -> gpointer>;
pub type GCacheDestroyFunc = ::std::option::Option<unsafe extern "C" fn(value: gpointer)>;
extern "C" {
    pub fn g_cache_new(
        value_new_func: GCacheNewFunc,
        value_destroy_func: GCacheDestroyFunc,
        key_dup_func: GCacheDupFunc,
        key_destroy_func: GCacheDestroyFunc,
        hash_key_func: GHashFunc,
        hash_value_func: GHashFunc,
        key_equal_func: GEqualFunc,
    ) -> *mut GCache;
}
extern "C" {
    pub fn g_cache_destroy(cache: *mut GCache);
}
extern "C" {
    pub fn g_cache_insert(cache: *mut GCache, key: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_cache_remove(cache: *mut GCache, value: gconstpointer);
}
extern "C" {
    pub fn g_cache_key_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_cache_value_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
pub type GCompletion = _GCompletion;
pub type GCompletionFunc = ::std::option::Option<unsafe extern "C" fn(arg1: gpointer) -> *mut gchar>;
pub type GCompletionStrncmpFunc = ::std::option::Option<unsafe extern "C" fn(s1: *const gchar, s2: *const gchar, n: gsize) -> gint>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCompletion {
    pub items: *mut GList,
    pub func: GCompletionFunc,
    pub prefix: *mut gchar,
    pub cache: *mut GList,
    pub strncmp_func: GCompletionStrncmpFunc,
}
#[test]
fn bindgen_test_layout__GCompletion() {
    assert_eq!(
        ::std::mem::size_of::<_GCompletion>(),
        40usize,
        concat!("Size of: ", stringify!(_GCompletion))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCompletion>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCompletion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCompletion>())).items as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCompletion>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCompletion>())).prefix as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCompletion>())).cache as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCompletion>())).strncmp_func as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(strncmp_func)
        )
    );
}
extern "C" {
    pub fn g_completion_new(func: GCompletionFunc) -> *mut GCompletion;
}
extern "C" {
    pub fn g_completion_add_items(cmp: *mut GCompletion, items: *mut GList);
}
extern "C" {
    pub fn g_completion_remove_items(cmp: *mut GCompletion, items: *mut GList);
}
extern "C" {
    pub fn g_completion_clear_items(cmp: *mut GCompletion);
}
extern "C" {
    pub fn g_completion_complete(cmp: *mut GCompletion, prefix: *const gchar, new_prefix: *mut *mut gchar) -> *mut GList;
}
extern "C" {
    pub fn g_completion_complete_utf8(cmp: *mut GCompletion, prefix: *const gchar, new_prefix: *mut *mut gchar) -> *mut GList;
}
extern "C" {
    pub fn g_completion_set_compare(cmp: *mut GCompletion, strncmp_func: GCompletionStrncmpFunc);
}
extern "C" {
    pub fn g_completion_free(cmp: *mut GCompletion);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRelation {
    _unused: [u8; 0],
}
pub type GRelation = _GRelation;
pub type GTuples = _GTuples;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTuples {
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GTuples() {
    assert_eq!(
        ::std::mem::size_of::<_GTuples>(),
        4usize,
        concat!("Size of: ", stringify!(_GTuples))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTuples>(),
        4usize,
        concat!("Alignment of ", stringify!(_GTuples))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTuples>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTuples),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    pub fn g_relation_new(fields: gint) -> *mut GRelation;
}
extern "C" {
    pub fn g_relation_destroy(relation: *mut GRelation);
}
extern "C" {
    pub fn g_relation_index(relation: *mut GRelation, field: gint, hash_func: GHashFunc, key_equal_func: GEqualFunc);
}
extern "C" {
    pub fn g_relation_insert(relation: *mut GRelation, ...);
}
extern "C" {
    pub fn g_relation_delete(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
extern "C" {
    pub fn g_relation_select(relation: *mut GRelation, key: gconstpointer, field: gint) -> *mut GTuples;
}
extern "C" {
    pub fn g_relation_count(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
extern "C" {
    pub fn g_relation_exists(relation: *mut GRelation, ...) -> gboolean;
}
extern "C" {
    pub fn g_relation_print(relation: *mut GRelation);
}
extern "C" {
    pub fn g_tuples_destroy(tuples: *mut GTuples);
}
extern "C" {
    pub fn g_tuples_index(tuples: *mut GTuples, index_: gint, field: gint) -> gpointer;
}
pub const GThreadPriority_G_THREAD_PRIORITY_LOW: GThreadPriority = 0;
pub const GThreadPriority_G_THREAD_PRIORITY_NORMAL: GThreadPriority = 1;
pub const GThreadPriority_G_THREAD_PRIORITY_HIGH: GThreadPriority = 2;
pub const GThreadPriority_G_THREAD_PRIORITY_URGENT: GThreadPriority = 3;
pub type GThreadPriority = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThread {
    pub func: GThreadFunc,
    pub data: gpointer,
    pub joinable: gboolean,
    pub priority: GThreadPriority,
}
#[test]
fn bindgen_test_layout__GThread() {
    assert_eq!(
        ::std::mem::size_of::<_GThread>(),
        24usize,
        concat!("Size of: ", stringify!(_GThread))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThread>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThread))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThread>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThread>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThread>())).joinable as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(joinable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThread>())).priority as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(priority)
        )
    );
}
pub type GThreadFunctions = _GThreadFunctions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadFunctions {
    pub mutex_new: ::std::option::Option<unsafe extern "C" fn() -> *mut GMutex>,
    pub mutex_lock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_trylock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex) -> gboolean>,
    pub mutex_unlock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_free: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub cond_new: ::std::option::Option<unsafe extern "C" fn() -> *mut GCond>,
    pub cond_signal: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_broadcast: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_wait: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond, mutex: *mut GMutex)>,
    pub cond_timed_wait:
        ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond, mutex: *mut GMutex, end_time: *mut GTimeVal) -> gboolean>,
    pub cond_free: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub private_new: ::std::option::Option<unsafe extern "C" fn(destructor: GDestroyNotify) -> *mut GPrivate>,
    pub private_get: ::std::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate) -> gpointer>,
    pub private_set: ::std::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate, data: gpointer)>,
    pub thread_create: ::std::option::Option<
        unsafe extern "C" fn(
            func: GThreadFunc,
            data: gpointer,
            stack_size: gulong,
            joinable: gboolean,
            bound: gboolean,
            priority: GThreadPriority,
            thread: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub thread_yield: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_join: ::std::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_exit: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_set_priority: ::std::option::Option<unsafe extern "C" fn(thread: gpointer, priority: GThreadPriority)>,
    pub thread_self: ::std::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_equal: ::std::option::Option<unsafe extern "C" fn(thread1: gpointer, thread2: gpointer) -> gboolean>,
}
#[test]
fn bindgen_test_layout__GThreadFunctions() {
    assert_eq!(
        ::std::mem::size_of::<_GThreadFunctions>(),
        168usize,
        concat!("Size of: ", stringify!(_GThreadFunctions))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThreadFunctions>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadFunctions))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).mutex_new as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_new)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).mutex_lock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).mutex_trylock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_trylock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).mutex_unlock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_unlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).mutex_free as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).cond_new as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_new)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).cond_signal as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).cond_broadcast as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_broadcast)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).cond_wait as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).cond_timed_wait as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_timed_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).cond_free as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).private_new as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_new)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).private_get as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).private_set as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).thread_create as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_create)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).thread_yield as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_yield)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).thread_join as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_join)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).thread_exit as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_exit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).thread_set_priority as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_set_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).thread_self as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_self)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).thread_equal as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_equal)
        )
    );
}
extern "C" {
    pub static mut g_thread_functions_for_glib_use: GThreadFunctions;
}
extern "C" {
    pub static mut g_thread_use_default_impl: gboolean;
}
extern "C" {
    pub static mut g_thread_gettime: ::std::option::Option<unsafe extern "C" fn() -> guint64>;
}
extern "C" {
    pub fn g_thread_create(func: GThreadFunc, data: gpointer, joinable: gboolean, error: *mut *mut GError) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_create_full(
        func: GThreadFunc,
        data: gpointer,
        stack_size: gulong,
        joinable: gboolean,
        bound: gboolean,
        priority: GThreadPriority,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_set_priority(thread: *mut GThread, priority: GThreadPriority);
}
extern "C" {
    pub fn g_thread_foreach(thread_func: GFunc, user_data: gpointer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub __sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).__sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(__sched_priority)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sched_param {
    pub __sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sched_param() {
    assert_eq!(
        ::std::mem::size_of::<__sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(__sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<__sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(__sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sched_param>())).__sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_param),
            "::",
            stringify!(__sched_priority)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_set_t>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(__pid: __pid_t, __policy: ::std::os::raw::c_int, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_11 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_11 = 1;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_12 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_12 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_12 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_12 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_12 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_12 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_12 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_12 = 0;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_13 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_13 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_13 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_13 = 1;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_14 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_14 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_14 = 2;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_15 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_15 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_15 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_15 = 0;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_16 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_16 = 1;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_17 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_17 = 1;
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_18 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_18 = 1;
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__routine as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__canceltype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_19 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_19 = 1;
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_20 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_20 = 1;
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void>,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_join(__th: pthread_t, __thread_return: *mut *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(__attr: *const pthread_attr_t, __detachstate: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(__attr: *mut pthread_attr_t, __detachstate: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(__attr: *const pthread_attr_t, __guardsize: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(__attr: *mut pthread_attr_t, __guardsize: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(__attr: *const pthread_attr_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(__attr: *mut pthread_attr_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(__attr: *const pthread_attr_t, __policy: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(__attr: *mut pthread_attr_t, __policy: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(__attr: *const pthread_attr_t, __inherit: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(__attr: *mut pthread_attr_t, __inherit: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(__attr: *const pthread_attr_t, __scope: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(__attr: *mut pthread_attr_t, __scope: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(__attr: *const pthread_attr_t, __stackaddr: *mut *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(__attr: *mut pthread_attr_t, __stackaddr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(__attr: *const pthread_attr_t, __stacksize: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(__attr: *mut pthread_attr_t, __stacksize: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(__target_thread: pthread_t, __prio: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(__state: ::std::os::raw::c_int, __oldstate: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(__type: ::std::os::raw::c_int, __oldtype: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__cancel_jmp_buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__mask_was_saved as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__cancel_jmp_buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__pad as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_routine as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__do_it as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_type as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __sigsetjmp(__env: *mut __jmp_buf_tag, __savemask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(__mutex: *mut pthread_mutex_t, __mutexattr: *const pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(__mutex: *mut pthread_mutex_t, __abstime: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(__attr: *const pthread_mutexattr_t, __pshared: *mut ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(__attr: *mut pthread_mutexattr_t, __pshared: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(__attr: *const pthread_mutexattr_t, __kind: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(__attr: *mut pthread_mutexattr_t, __kind: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(__attr: *mut pthread_mutexattr_t, __protocol: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(__attr: *mut pthread_mutexattr_t, __robustness: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(__rwlock: *mut pthread_rwlock_t, __attr: *const pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(__rwlock: *mut pthread_rwlock_t, __abstime: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(__rwlock: *mut pthread_rwlock_t, __abstime: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(__attr: *mut pthread_rwlockattr_t, __pshared: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(__attr: *const pthread_rwlockattr_t, __pref: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(__attr: *mut pthread_rwlockattr_t, __pref: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(__cond: *mut pthread_cond_t, __cond_attr: *const pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(__cond: *mut pthread_cond_t, __mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(__attr: *const pthread_condattr_t, __pshared: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(__attr: *mut pthread_condattr_t, __pshared: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(__attr: *const pthread_condattr_t, __clock_id: *mut __clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(__attr: *mut pthread_condattr_t, __clock_id: __clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(__lock: *mut pthread_spinlock_t, __pshared: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(__attr: *mut pthread_barrierattr_t, __pshared: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(__key: pthread_key_t, __pointer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(__thread_id: pthread_t, __clock_id: *mut __clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GStaticMutex {
    pub mutex: *mut GMutex,
    pub unused: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_GStaticMutex() {
    assert_eq!(
        ::std::mem::size_of::<GStaticMutex>(),
        48usize,
        concat!("Size of: ", stringify!(GStaticMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<GStaticMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(GStaticMutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GStaticMutex>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GStaticMutex),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GStaticMutex>())).unused as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GStaticMutex),
            "::",
            stringify!(unused)
        )
    );
}
extern "C" {
    pub fn g_static_mutex_init(mutex: *mut GStaticMutex);
}
extern "C" {
    pub fn g_static_mutex_free(mutex: *mut GStaticMutex);
}
extern "C" {
    pub fn g_static_mutex_get_mutex_impl(mutex: *mut GStaticMutex) -> *mut GMutex;
}
pub type GStaticRecMutex = _GStaticRecMutex;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GStaticRecMutex {
    pub mutex: GStaticMutex,
    pub depth: guint,
    pub unused: _GStaticRecMutex__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GStaticRecMutex__bindgen_ty_1 {
    pub owner: pthread_t,
    pub dummy: gdouble,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__GStaticRecMutex__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GStaticRecMutex__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GStaticRecMutex__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticRecMutex__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRecMutex__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRecMutex__bindgen_ty_1>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex__bindgen_ty_1),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRecMutex__bindgen_ty_1>())).dummy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex__bindgen_ty_1),
            "::",
            stringify!(dummy)
        )
    );
}
#[test]
fn bindgen_test_layout__GStaticRecMutex() {
    assert_eq!(
        ::std::mem::size_of::<_GStaticRecMutex>(),
        64usize,
        concat!("Size of: ", stringify!(_GStaticRecMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticRecMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRecMutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRecMutex>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRecMutex>())).depth as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRecMutex>())).unused as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(unused)
        )
    );
}
extern "C" {
    pub fn g_static_rec_mutex_init(mutex: *mut GStaticRecMutex);
}
extern "C" {
    pub fn g_static_rec_mutex_lock(mutex: *mut GStaticRecMutex);
}
extern "C" {
    pub fn g_static_rec_mutex_trylock(mutex: *mut GStaticRecMutex) -> gboolean;
}
extern "C" {
    pub fn g_static_rec_mutex_unlock(mutex: *mut GStaticRecMutex);
}
extern "C" {
    pub fn g_static_rec_mutex_lock_full(mutex: *mut GStaticRecMutex, depth: guint);
}
extern "C" {
    pub fn g_static_rec_mutex_unlock_full(mutex: *mut GStaticRecMutex) -> guint;
}
extern "C" {
    pub fn g_static_rec_mutex_free(mutex: *mut GStaticRecMutex);
}
pub type GStaticRWLock = _GStaticRWLock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GStaticRWLock {
    pub mutex: GStaticMutex,
    pub read_cond: *mut GCond,
    pub write_cond: *mut GCond,
    pub read_counter: guint,
    pub have_writer: gboolean,
    pub want_to_read: guint,
    pub want_to_write: guint,
}
#[test]
fn bindgen_test_layout__GStaticRWLock() {
    assert_eq!(
        ::std::mem::size_of::<_GStaticRWLock>(),
        80usize,
        concat!("Size of: ", stringify!(_GStaticRWLock))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticRWLock>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRWLock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRWLock>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRWLock>())).read_cond as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(read_cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRWLock>())).write_cond as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(write_cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRWLock>())).read_counter as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(read_counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRWLock>())).have_writer as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(have_writer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRWLock>())).want_to_read as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(want_to_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRWLock>())).want_to_write as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(want_to_write)
        )
    );
}
extern "C" {
    pub fn g_static_rw_lock_init(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_reader_lock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_reader_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
extern "C" {
    pub fn g_static_rw_lock_reader_unlock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_writer_lock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_writer_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
extern "C" {
    pub fn g_static_rw_lock_writer_unlock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_free(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_private_new(notify: GDestroyNotify) -> *mut GPrivate;
}
pub type GStaticPrivate = _GStaticPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStaticPrivate {
    pub index: guint,
}
#[test]
fn bindgen_test_layout__GStaticPrivate() {
    assert_eq!(
        ::std::mem::size_of::<_GStaticPrivate>(),
        4usize,
        concat!("Size of: ", stringify!(_GStaticPrivate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticPrivate>(),
        4usize,
        concat!("Alignment of ", stringify!(_GStaticPrivate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticPrivate>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticPrivate),
            "::",
            stringify!(index)
        )
    );
}
extern "C" {
    pub fn g_static_private_init(private_key: *mut GStaticPrivate);
}
extern "C" {
    pub fn g_static_private_get(private_key: *mut GStaticPrivate) -> gpointer;
}
extern "C" {
    pub fn g_static_private_set(private_key: *mut GStaticPrivate, data: gpointer, notify: GDestroyNotify);
}
extern "C" {
    pub fn g_static_private_free(private_key: *mut GStaticPrivate);
}
extern "C" {
    pub fn g_once_init_enter_impl(location: *mut gsize) -> gboolean;
}
extern "C" {
    pub fn g_thread_init(vtable: gpointer);
}
extern "C" {
    pub fn g_thread_init_with_errorcheck_mutexes(vtable: gpointer);
}
extern "C" {
    pub fn g_thread_get_initialized() -> gboolean;
}
extern "C" {
    pub static mut g_threads_got_initialized: gboolean;
}
extern "C" {
    pub fn g_mutex_new() -> *mut GMutex;
}
extern "C" {
    pub fn g_mutex_free(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_cond_new() -> *mut GCond;
}
extern "C" {
    pub fn g_cond_free(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_timed_wait(cond: *mut GCond, mutex: *mut GMutex, timeval: *mut GTimeVal) -> gboolean;
}
pub type GAsyncQueue_autoptr = *mut GAsyncQueue;
pub type GBookmarkFile_autoptr = *mut GBookmarkFile;
pub type GBytes_autoptr = *mut GBytes;
pub type GChecksum_autoptr = *mut GChecksum;
pub type GDateTime_autoptr = *mut GDateTime;
pub type GDir_autoptr = *mut GDir;
pub type GError_autoptr = *mut GError;
pub type GHashTable_autoptr = *mut GHashTable;
pub type GHmac_autoptr = *mut GHmac;
pub type GIOChannel_autoptr = *mut GIOChannel;
pub type GKeyFile_autoptr = *mut GKeyFile;
pub type GList_autoptr = *mut GList;
pub type GArray_autoptr = *mut GArray;
pub type GPtrArray_autoptr = *mut GPtrArray;
pub type GByteArray_autoptr = *mut GByteArray;
pub type GMainContext_autoptr = *mut GMainContext;
pub type GMainLoop_autoptr = *mut GMainLoop;
pub type GSource_autoptr = *mut GSource;
pub type GMappedFile_autoptr = *mut GMappedFile;
pub type GMarkupParseContext_autoptr = *mut GMarkupParseContext;
pub type GNode_autoptr = *mut GNode;
pub type GOptionContext_autoptr = *mut GOptionContext;
pub type GOptionGroup_autoptr = *mut GOptionGroup;
pub type GPatternSpec_autoptr = *mut GPatternSpec;
pub type GQueue_autoptr = *mut GQueue;
pub type GRand_autoptr = *mut GRand;
pub type GRegex_autoptr = *mut GRegex;
pub type GMatchInfo_autoptr = *mut GMatchInfo;
pub type GScanner_autoptr = *mut GScanner;
pub type GSequence_autoptr = *mut GSequence;
pub type GSList_autoptr = *mut GSList;
pub type GString_autoptr = *mut GString;
pub type GStringChunk_autoptr = *mut GStringChunk;
pub type GThread_autoptr = *mut GThread;
pub type GMutexLocker_autoptr = *mut GMutexLocker;
pub type GTimer_autoptr = *mut GTimer;
pub type GTimeZone_autoptr = *mut GTimeZone;
pub type GTree_autoptr = *mut GTree;
pub type GVariant_autoptr = *mut GVariant;
pub type GVariantBuilder_autoptr = *mut GVariantBuilder;
pub type GVariantIter_autoptr = *mut GVariantIter;
pub type GVariantDict_autoptr = *mut GVariantDict;
pub type GVariantType_autoptr = *mut GVariantType;
pub type GType = gsize;
pub type GValue = _GValue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeCValue {
    _unused: [u8; 0],
}
pub type GTypeCValue = _GTypeCValue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypePlugin {
    _unused: [u8; 0],
}
pub type GTypePlugin = _GTypePlugin;
pub type GTypeClass = _GTypeClass;
pub type GTypeInterface = _GTypeInterface;
pub type GTypeInstance = _GTypeInstance;
pub type GTypeInfo = _GTypeInfo;
pub type GTypeFundamentalInfo = _GTypeFundamentalInfo;
pub type GInterfaceInfo = _GInterfaceInfo;
pub type GTypeValueTable = _GTypeValueTable;
pub type GTypeQuery = _GTypeQuery;
/// GTypeClass:
///
/// An opaque structure used as the base of all classes.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeClass {
    pub g_type: GType,
}
#[test]
fn bindgen_test_layout__GTypeClass() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeClass>(),
        8usize,
        concat!("Size of: ", stringify!(_GTypeClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeClass>())).g_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeClass),
            "::",
            stringify!(g_type)
        )
    );
}
/// GTypeInstance:
///
/// An opaque structure used as the base of all type instances.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeInstance {
    pub g_class: *mut GTypeClass,
}
#[test]
fn bindgen_test_layout__GTypeInstance() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeInstance>(),
        8usize,
        concat!("Size of: ", stringify!(_GTypeInstance))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeInstance>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeInstance))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInstance>())).g_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInstance),
            "::",
            stringify!(g_class)
        )
    );
}
/// GTypeInterface:
///
/// An opaque structure used as the base of all interface types.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeInterface {
    pub g_type: GType,
    pub g_instance_type: GType,
}
#[test]
fn bindgen_test_layout__GTypeInterface() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeInterface>(),
        16usize,
        concat!("Size of: ", stringify!(_GTypeInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeInterface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInterface>())).g_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInterface),
            "::",
            stringify!(g_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInterface>())).g_instance_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInterface),
            "::",
            stringify!(g_instance_type)
        )
    );
}
/// GTypeQuery:
/// @type: the #GType value of the type
/// @type_name: the name of the type
/// @class_size: the size of the class structure
/// @instance_size: the size of the instance structure
///
/// A structure holding information for a specific type.
/// It is filled in by the g_type_query() function.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeQuery {
    pub type_: GType,
    pub type_name: *const gchar,
    pub class_size: guint,
    pub instance_size: guint,
}
#[test]
fn bindgen_test_layout__GTypeQuery() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeQuery>(),
        24usize,
        concat!("Size of: ", stringify!(_GTypeQuery))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeQuery>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeQuery))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeQuery>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeQuery),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeQuery>())).type_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeQuery),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeQuery>())).class_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeQuery),
            "::",
            stringify!(class_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeQuery>())).instance_size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeQuery),
            "::",
            stringify!(instance_size)
        )
    );
}
pub const GTypeDebugFlags_G_TYPE_DEBUG_NONE: GTypeDebugFlags = 0;
pub const GTypeDebugFlags_G_TYPE_DEBUG_OBJECTS: GTypeDebugFlags = 1;
pub const GTypeDebugFlags_G_TYPE_DEBUG_SIGNALS: GTypeDebugFlags = 2;
pub const GTypeDebugFlags_G_TYPE_DEBUG_INSTANCE_COUNT: GTypeDebugFlags = 4;
pub const GTypeDebugFlags_G_TYPE_DEBUG_MASK: GTypeDebugFlags = 7;
pub type GTypeDebugFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_type_init();
}
extern "C" {
    pub fn g_type_init_with_debug_flags(debug_flags: GTypeDebugFlags);
}
extern "C" {
    pub fn g_type_name(type_: GType) -> *const gchar;
}
extern "C" {
    pub fn g_type_qname(type_: GType) -> GQuark;
}
extern "C" {
    pub fn g_type_from_name(name: *const gchar) -> GType;
}
extern "C" {
    pub fn g_type_parent(type_: GType) -> GType;
}
extern "C" {
    pub fn g_type_depth(type_: GType) -> guint;
}
extern "C" {
    pub fn g_type_next_base(leaf_type: GType, root_type: GType) -> GType;
}
extern "C" {
    pub fn g_type_is_a(type_: GType, is_a_type: GType) -> gboolean;
}
extern "C" {
    pub fn g_type_class_ref(type_: GType) -> gpointer;
}
extern "C" {
    pub fn g_type_class_peek(type_: GType) -> gpointer;
}
extern "C" {
    pub fn g_type_class_peek_static(type_: GType) -> gpointer;
}
extern "C" {
    pub fn g_type_class_unref(g_class: gpointer);
}
extern "C" {
    pub fn g_type_class_peek_parent(g_class: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_type_interface_peek(instance_class: gpointer, iface_type: GType) -> gpointer;
}
extern "C" {
    pub fn g_type_interface_peek_parent(g_iface: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_type_default_interface_ref(g_type: GType) -> gpointer;
}
extern "C" {
    pub fn g_type_default_interface_peek(g_type: GType) -> gpointer;
}
extern "C" {
    pub fn g_type_default_interface_unref(g_iface: gpointer);
}
extern "C" {
    pub fn g_type_children(type_: GType, n_children: *mut guint) -> *mut GType;
}
extern "C" {
    pub fn g_type_interfaces(type_: GType, n_interfaces: *mut guint) -> *mut GType;
}
extern "C" {
    pub fn g_type_set_qdata(type_: GType, quark: GQuark, data: gpointer);
}
extern "C" {
    pub fn g_type_get_qdata(type_: GType, quark: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_type_query(type_: GType, query: *mut GTypeQuery);
}
extern "C" {
    pub fn g_type_get_instance_count(type_: GType) -> ::std::os::raw::c_int;
}
/// GBaseInitFunc:
/// @g_class: (type GObject.TypeClass): The #GTypeClass structure to initialize
///
/// A callback function used by the type system to do base initialization
/// of the class structures of derived types. It is called as part of the
/// initialization process of all derived classes and should reallocate
/// or reset all dynamic class members copied over from the parent class.
/// For example, class members (such as strings) that are not sufficiently
/// handled by a plain memory copy of the parent class into the derived class
/// have to be altered. See GClassInitFunc() for a discussion of the class
/// initialization process.
pub type GBaseInitFunc = ::std::option::Option<unsafe extern "C" fn(g_class: gpointer)>;
/// GBaseFinalizeFunc:
/// @g_class: (type GObject.TypeClass): The #GTypeClass structure to finalize
///
/// A callback function used by the type system to finalize those portions
/// of a derived types class structure that were setup from the corresponding
/// GBaseInitFunc() function. Class finalization basically works the inverse
/// way in which class initialization is performed.
/// See GClassInitFunc() for a discussion of the class initialization process.
pub type GBaseFinalizeFunc = ::std::option::Option<unsafe extern "C" fn(g_class: gpointer)>;
/// GClassInitFunc:
/// @g_class: (type GObject.TypeClass): The #GTypeClass structure to initialize.
/// @class_data: The @class_data member supplied via the #GTypeInfo structure.
///
/// A callback function used by the type system to initialize the class
/// of a specific type. This function should initialize all static class
/// members.
///
/// The initialization process of a class involves:
///
/// - Copying common members from the parent class over to the
/// derived class structure.
/// - Zero initialization of the remaining members not copied
/// over from the parent class.
/// - Invocation of the GBaseInitFunc() initializers of all parent
/// types and the class' type.
/// - Invocation of the class' GClassInitFunc() initializer.
///
/// Since derived classes are partially initialized through a memory copy
/// of the parent class, the general rule is that GBaseInitFunc() and
/// GBaseFinalizeFunc() should take care of necessary reinitialization
/// and release of those class members that were introduced by the type
/// that specified these GBaseInitFunc()/GBaseFinalizeFunc().
/// GClassInitFunc() should only care about initializing static
/// class members, while dynamic class members (such as allocated strings
/// or reference counted resources) are better handled by a GBaseInitFunc()
/// for this type, so proper initialization of the dynamic class members
/// is performed for class initialization of derived types as well.
///
/// An example may help to correspond the intend of the different class
/// initializers:
///
/// |[<!-- language="C" -->
/// typedef struct {
/// GObjectClass parent_class;
/// gint         static_integer;
/// gchar       *dynamic_string;
/// } TypeAClass;
/// static void
/// type_a_base_class_init (TypeAClass *class)
/// {
/// class->dynamic_string = g_strdup ("some string");
/// }
/// static void
/// type_a_base_class_finalize (TypeAClass *class)
/// {
/// g_free (class->dynamic_string);
/// }
/// static void
/// type_a_class_init (TypeAClass *class)
/// {
/// class->static_integer = 42;
/// }
///
/// typedef struct {
/// TypeAClass   parent_class;
/// gfloat       static_float;
/// GString     *dynamic_gstring;
/// } TypeBClass;
/// static void
/// type_b_base_class_init (TypeBClass *class)
/// {
/// class->dynamic_gstring = g_string_new ("some other string");
/// }
/// static void
/// type_b_base_class_finalize (TypeBClass *class)
/// {
/// g_string_free (class->dynamic_gstring);
/// }
/// static void
/// type_b_class_init (TypeBClass *class)
/// {
/// class->static_float = 3.14159265358979323846;
/// }
/// ]|
/// Initialization of TypeBClass will first cause initialization of
/// TypeAClass (derived classes reference their parent classes, see
/// g_type_class_ref() on this).
///
/// Initialization of TypeAClass roughly involves zero-initializing its fields,
/// then calling its GBaseInitFunc() type_a_base_class_init() to allocate
/// its dynamic members (dynamic_string), and finally calling its GClassInitFunc()
/// type_a_class_init() to initialize its static members (static_integer).
/// The first step in the initialization process of TypeBClass is then
/// a plain memory copy of the contents of TypeAClass into TypeBClass and
/// zero-initialization of the remaining fields in TypeBClass.
/// The dynamic members of TypeAClass within TypeBClass now need
/// reinitialization which is performed by calling type_a_base_class_init()
/// with an argument of TypeBClass.
///
/// After that, the GBaseInitFunc() of TypeBClass, type_b_base_class_init()
/// is called to allocate the dynamic members of TypeBClass (dynamic_gstring),
/// and finally the GClassInitFunc() of TypeBClass, type_b_class_init(),
/// is called to complete the initialization process with the static members
/// (static_float).
///
/// Corresponding finalization counter parts to the GBaseInitFunc() functions
/// have to be provided to release allocated resources at class finalization
/// time.
pub type GClassInitFunc = ::std::option::Option<unsafe extern "C" fn(g_class: gpointer, class_data: gpointer)>;
/// GClassFinalizeFunc:
/// @g_class: (type GObject.TypeClass): The #GTypeClass structure to finalize
/// @class_data: The @class_data member supplied via the #GTypeInfo structure
///
/// A callback function used by the type system to finalize a class.
/// This function is rarely needed, as dynamically allocated class resources
/// should be handled by GBaseInitFunc() and GBaseFinalizeFunc().
/// Also, specification of a GClassFinalizeFunc() in the #GTypeInfo
/// structure of a static type is invalid, because classes of static types
/// will never be finalized (they are artificially kept alive when their
/// reference count drops to zero).
pub type GClassFinalizeFunc = ::std::option::Option<unsafe extern "C" fn(g_class: gpointer, class_data: gpointer)>;
/// GInstanceInitFunc:
/// @instance: The instance to initialize
/// @g_class: (type GObject.TypeClass): The class of the type the instance is
/// created for
///
/// A callback function used by the type system to initialize a new
/// instance of a type. This function initializes all instance members and
/// allocates any resources required by it.
///
/// Initialization of a derived instance involves calling all its parent
/// types instance initializers, so the class member of the instance
/// is altered during its initialization to always point to the class that
/// belongs to the type the current initializer was introduced for.
///
/// The extended members of @instance are guaranteed to have been filled with
/// zeros before this function is called.
pub type GInstanceInitFunc = ::std::option::Option<unsafe extern "C" fn(instance: *mut GTypeInstance, g_class: gpointer)>;
/// GInterfaceInitFunc:
/// @g_iface: (type GObject.TypeInterface): The interface structure to initialize
/// @iface_data: The @interface_data supplied via the #GInterfaceInfo structure
///
/// A callback function used by the type system to initialize a new
/// interface.  This function should initialize all internal data and
/// allocate any resources required by the interface.
///
/// The members of @iface_data are guaranteed to have been filled with
/// zeros before this function is called.
pub type GInterfaceInitFunc = ::std::option::Option<unsafe extern "C" fn(g_iface: gpointer, iface_data: gpointer)>;
/// GInterfaceFinalizeFunc:
/// @g_iface: (type GObject.TypeInterface): The interface structure to finalize
/// @iface_data: The @interface_data supplied via the #GInterfaceInfo structure
///
/// A callback function used by the type system to finalize an interface.
/// This function should destroy any internal data and release any resources
/// allocated by the corresponding GInterfaceInitFunc() function.
pub type GInterfaceFinalizeFunc = ::std::option::Option<unsafe extern "C" fn(g_iface: gpointer, iface_data: gpointer)>;
/// GTypeClassCacheFunc:
/// @cache_data: data that was given to the g_type_add_class_cache_func() call
/// @g_class: (type GObject.TypeClass): The #GTypeClass structure which is
/// unreferenced
///
/// A callback function which is called when the reference count of a class
/// drops to zero. It may use g_type_class_ref() to prevent the class from
/// being freed. You should not call g_type_class_unref() from a
/// #GTypeClassCacheFunc function to prevent infinite recursion, use
/// g_type_class_unref_uncached() instead.
///
/// The functions have to check the class id passed in to figure
/// whether they actually want to cache the class of this type, since all
/// classes are routed through the same #GTypeClassCacheFunc chain.
///
/// Returns: %TRUE to stop further #GTypeClassCacheFuncs from being
/// called, %FALSE to continue
pub type GTypeClassCacheFunc = ::std::option::Option<unsafe extern "C" fn(cache_data: gpointer, g_class: *mut GTypeClass) -> gboolean>;
/// GTypeInterfaceCheckFunc:
/// @check_data: data passed to g_type_add_interface_check()
/// @g_iface: (type GObject.TypeInterface): the interface that has been
/// initialized
///
/// A callback called after an interface vtable is initialized.
/// See g_type_add_interface_check().
///
/// Since: 2.4
pub type GTypeInterfaceCheckFunc = ::std::option::Option<unsafe extern "C" fn(check_data: gpointer, g_iface: gpointer)>;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_CLASSED: GTypeFundamentalFlags = 1;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_INSTANTIATABLE: GTypeFundamentalFlags = 2;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_DERIVABLE: GTypeFundamentalFlags = 4;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_DEEP_DERIVABLE: GTypeFundamentalFlags = 8;
pub type GTypeFundamentalFlags = ::std::os::raw::c_uint;
pub const GTypeFlags_G_TYPE_FLAG_ABSTRACT: GTypeFlags = 16;
pub const GTypeFlags_G_TYPE_FLAG_VALUE_ABSTRACT: GTypeFlags = 32;
pub type GTypeFlags = ::std::os::raw::c_uint;
/// GTypeInfo:
/// @class_size: Size of the class structure (required for interface, classed and instantiatable types)
/// @base_init: Location of the base initialization function (optional)
/// @base_finalize: Location of the base finalization function (optional)
/// @class_init: Location of the class initialization function for
/// classed and instantiatable types. Location of the default vtable
/// inititalization function for interface types. (optional) This function
/// is used both to fill in virtual functions in the class or default vtable,
/// and to do type-specific setup such as registering signals and object
/// properties.
/// @class_finalize: Location of the class finalization function for
/// classed and instantiatable types. Location of the default vtable
/// finalization function for interface types. (optional)
/// @class_data: User-supplied data passed to the class init/finalize functions
/// @instance_size: Size of the instance (object) structure (required for instantiatable types only)
/// @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now.
/// @instance_init: Location of the instance initialization function (optional, for instantiatable types only)
/// @value_table: A #GTypeValueTable function table for generic handling of GValues
/// of this type (usually only useful for fundamental types)
///
/// This structure is used to provide the type system with the information
/// required to initialize and destruct (finalize) a type's class and
/// its instances.
///
/// The initialized structure is passed to the g_type_register_static() function
/// (or is copied into the provided #GTypeInfo structure in the
/// g_type_plugin_complete_type_info()). The type system will perform a deep
/// copy of this structure, so its memory does not need to be persistent
/// across invocation of g_type_register_static().
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeInfo {
    pub class_size: guint16,
    pub base_init: GBaseInitFunc,
    pub base_finalize: GBaseFinalizeFunc,
    pub class_init: GClassInitFunc,
    pub class_finalize: GClassFinalizeFunc,
    pub class_data: gconstpointer,
    pub instance_size: guint16,
    pub n_preallocs: guint16,
    pub instance_init: GInstanceInitFunc,
    pub value_table: *const GTypeValueTable,
}
#[test]
fn bindgen_test_layout__GTypeInfo() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeInfo>(),
        72usize,
        concat!("Size of: ", stringify!(_GTypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).class_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(class_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).base_init as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(base_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).base_finalize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(base_finalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).class_init as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(class_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).class_finalize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(class_finalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).class_data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(class_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).instance_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(instance_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).n_preallocs as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(n_preallocs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).instance_init as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(instance_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).value_table as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(value_table)
        )
    );
}
/// GTypeFundamentalInfo:
/// @type_flags: #GTypeFundamentalFlags describing the characteristics of the fundamental type
///
/// A structure that provides information to the type system which is
/// used specifically for managing fundamental types.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeFundamentalInfo {
    pub type_flags: GTypeFundamentalFlags,
}
#[test]
fn bindgen_test_layout__GTypeFundamentalInfo() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeFundamentalInfo>(),
        4usize,
        concat!("Size of: ", stringify!(_GTypeFundamentalInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeFundamentalInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(_GTypeFundamentalInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeFundamentalInfo>())).type_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeFundamentalInfo),
            "::",
            stringify!(type_flags)
        )
    );
}
/// GInterfaceInfo:
/// @interface_init: location of the interface initialization function
/// @interface_finalize: location of the interface finalization function
/// @interface_data: user-supplied data passed to the interface init/finalize functions
///
/// A structure that provides information to the type system which is
/// used specifically for managing interface types.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInterfaceInfo {
    pub interface_init: GInterfaceInitFunc,
    pub interface_finalize: GInterfaceFinalizeFunc,
    pub interface_data: gpointer,
}
#[test]
fn bindgen_test_layout__GInterfaceInfo() {
    assert_eq!(
        ::std::mem::size_of::<_GInterfaceInfo>(),
        24usize,
        concat!("Size of: ", stringify!(_GInterfaceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInterfaceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInterfaceInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInterfaceInfo>())).interface_init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInterfaceInfo),
            "::",
            stringify!(interface_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInterfaceInfo>())).interface_finalize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInterfaceInfo),
            "::",
            stringify!(interface_finalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInterfaceInfo>())).interface_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInterfaceInfo),
            "::",
            stringify!(interface_data)
        )
    );
}
/// GTypeValueTable:
/// @value_init: Default initialize @values contents by poking values
/// directly into the value->data array. The data array of
/// the #GValue passed into this function was zero-filled
/// with `memset()`, so no care has to be taken to free any
/// old contents. E.g. for the implementation of a string
/// value that may never be %NULL, the implementation might
/// look like:
/// |[<!-- language="C" -->
/// value->data[0].v_pointer = g_strdup ("");
/// ]|
/// @value_free: Free any old contents that might be left in the
/// data array of the passed in @value. No resources may
/// remain allocated through the #GValue contents after
/// this function returns. E.g. for our above string type:
/// |[<!-- language="C" -->
/// // only free strings without a specific flag for static storage
/// if (!(value->data[1].v_uint & G_VALUE_NOCOPY_CONTENTS))
/// g_free (value->data[0].v_pointer);
/// ]|
/// @value_copy: @dest_value is a #GValue with zero-filled data section
/// and @src_value is a properly setup #GValue of same or
/// derived type.
/// The purpose of this function is to copy the contents of
/// @src_value into @dest_value in a way, that even after
/// @src_value has been freed, the contents of @dest_value
/// remain valid. String type example:
/// |[<!-- language="C" -->
/// dest_value->data[0].v_pointer = g_strdup (src_value->data[0].v_pointer);
/// ]|
/// @value_peek_pointer: If the value contents fit into a pointer, such as objects
/// or strings, return this pointer, so the caller can peek at
/// the current contents. To extend on our above string example:
/// |[<!-- language="C" -->
/// return value->data[0].v_pointer;
/// ]|
/// @collect_format: A string format describing how to collect the contents of
/// this value bit-by-bit. Each character in the format represents
/// an argument to be collected, and the characters themselves indicate
/// the type of the argument. Currently supported arguments are:
/// - 'i' - Integers. passed as collect_values[].v_int.
/// - 'l' - Longs. passed as collect_values[].v_long.
/// - 'd' - Doubles. passed as collect_values[].v_double.
/// - 'p' - Pointers. passed as collect_values[].v_pointer.
/// It should be noted that for variable argument list construction,
/// ANSI C promotes every type smaller than an integer to an int, and
/// floats to doubles. So for collection of short int or char, 'i'
/// needs to be used, and for collection of floats 'd'.
/// @collect_value: The collect_value() function is responsible for converting the
/// values collected from a variable argument list into contents
/// suitable for storage in a GValue. This function should setup
/// @value similar to value_init(); e.g. for a string value that
/// does not allow %NULL pointers, it needs to either spew an error,
/// or do an implicit conversion by storing an empty string.
/// The @value passed in to this function has a zero-filled data
/// array, so just like for value_init() it is guaranteed to not
/// contain any old contents that might need freeing.
/// @n_collect_values is exactly the string length of @collect_format,
/// and @collect_values is an array of unions #GTypeCValue with
/// length @n_collect_values, containing the collected values
/// according to @collect_format.
/// @collect_flags is an argument provided as a hint by the caller.
/// It may contain the flag %G_VALUE_NOCOPY_CONTENTS indicating,
/// that the collected value contents may be considered "static"
/// for the duration of the @value lifetime.
/// Thus an extra copy of the contents stored in @collect_values is
/// not required for assignment to @value.
/// For our above string example, we continue with:
/// |[<!-- language="C" -->
/// if (!collect_values[0].v_pointer)
/// value->data[0].v_pointer = g_strdup ("");
/// else if (collect_flags & G_VALUE_NOCOPY_CONTENTS)
/// {
/// value->data[0].v_pointer = collect_values[0].v_pointer;
/// // keep a flag for the value_free() implementation to not free this string
/// value->data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;
/// }
/// else
/// value->data[0].v_pointer = g_strdup (collect_values[0].v_pointer);
/// return NULL;
/// ]|
/// It should be noted, that it is generally a bad idea to follow the
/// #G_VALUE_NOCOPY_CONTENTS hint for reference counted types. Due to
/// reentrancy requirements and reference count assertions performed
/// by the signal emission code, reference counts should always be
/// incremented for reference counted contents stored in the value->data
/// array.  To deviate from our string example for a moment, and taking
/// a look at an exemplary implementation for collect_value() of
/// #GObject:
/// |[<!-- language="C" -->
/// if (collect_values[0].v_pointer)
/// {
/// GObject *object = G_OBJECT (collect_values[0].v_pointer);
/// // never honour G_VALUE_NOCOPY_CONTENTS for ref-counted types
/// value->data[0].v_pointer = g_object_ref (object);
/// return NULL;
/// }
/// else
/// return g_strdup_printf ("Object passed as invalid NULL pointer");
/// }
/// ]|
/// The reference count for valid objects is always incremented,
/// regardless of @collect_flags. For invalid objects, the example
/// returns a newly allocated string without altering @value.
/// Upon success, collect_value() needs to return %NULL. If, however,
/// an error condition occurred, collect_value() may spew an
/// error by returning a newly allocated non-%NULL string, giving
/// a suitable description of the error condition.
/// The calling code makes no assumptions about the @value
/// contents being valid upon error returns, @value
/// is simply thrown away without further freeing. As such, it is
/// a good idea to not allocate #GValue contents, prior to returning
/// an error, however, collect_values() is not obliged to return
/// a correctly setup @value for error returns, simply because
/// any non-%NULL return is considered a fatal condition so further
/// program behaviour is undefined.
/// @lcopy_format: Format description of the arguments to collect for @lcopy_value,
/// analogous to @collect_format. Usually, @lcopy_format string consists
/// only of 'p's to provide lcopy_value() with pointers to storage locations.
/// @lcopy_value: This function is responsible for storing the @value contents into
/// arguments passed through a variable argument list which got
/// collected into @collect_values according to @lcopy_format.
/// @n_collect_values equals the string length of @lcopy_format,
/// and @collect_flags may contain %G_VALUE_NOCOPY_CONTENTS.
/// In contrast to collect_value(), lcopy_value() is obliged to
/// always properly support %G_VALUE_NOCOPY_CONTENTS.
/// Similar to collect_value() the function may prematurely abort
/// by returning a newly allocated string describing an error condition.
/// To complete the string example:
/// |[<!-- language="C" -->
/// gchar **string_p = collect_values[0].v_pointer;
/// if (!string_p)
/// return g_strdup_printf ("string location passed as NULL");
/// if (collect_flags & G_VALUE_NOCOPY_CONTENTS)
/// *string_p = value->data[0].v_pointer;
/// else
/// *string_p = g_strdup (value->data[0].v_pointer);
/// ]|
/// And an illustrative version of lcopy_value() for
/// reference-counted types:
/// |[<!-- language="C" -->
/// GObject **object_p = collect_values[0].v_pointer;
/// if (!object_p)
/// return g_strdup_printf ("object location passed as NULL");
/// if (!value->data[0].v_pointer)
/// *object_p = NULL;
/// else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) // always honour
/// *object_p = value->data[0].v_pointer;
/// else
/// *object_p = g_object_ref (value->data[0].v_pointer);
/// return NULL;
/// ]|
///
/// The #GTypeValueTable provides the functions required by the #GValue
/// implementation, to serve as a container for values of a type.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeValueTable {
    pub value_init: ::std::option::Option<unsafe extern "C" fn(value: *mut GValue)>,
    pub value_free: ::std::option::Option<unsafe extern "C" fn(value: *mut GValue)>,
    pub value_copy: ::std::option::Option<unsafe extern "C" fn(src_value: *const GValue, dest_value: *mut GValue)>,
    pub value_peek_pointer: ::std::option::Option<unsafe extern "C" fn(value: *const GValue) -> gpointer>,
    pub collect_format: *const gchar,
    pub collect_value: ::std::option::Option<
        unsafe extern "C" fn(value: *mut GValue, n_collect_values: guint, collect_values: *mut GTypeCValue, collect_flags: guint)
            -> *mut gchar,
    >,
    pub lcopy_format: *const gchar,
    pub lcopy_value: ::std::option::Option<
        unsafe extern "C" fn(value: *const GValue, n_collect_values: guint, collect_values: *mut GTypeCValue, collect_flags: guint)
            -> *mut gchar,
    >,
}
#[test]
fn bindgen_test_layout__GTypeValueTable() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeValueTable>(),
        64usize,
        concat!("Size of: ", stringify!(_GTypeValueTable))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeValueTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeValueTable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeValueTable>())).value_init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(value_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeValueTable>())).value_free as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(value_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeValueTable>())).value_copy as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(value_copy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeValueTable>())).value_peek_pointer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(value_peek_pointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeValueTable>())).collect_format as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(collect_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeValueTable>())).collect_value as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(collect_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeValueTable>())).lcopy_format as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(lcopy_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeValueTable>())).lcopy_value as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(lcopy_value)
        )
    );
}
extern "C" {
    pub fn g_type_register_static(parent_type: GType, type_name: *const gchar, info: *const GTypeInfo, flags: GTypeFlags) -> GType;
}
extern "C" {
    pub fn g_type_register_static_simple(
        parent_type: GType,
        type_name: *const gchar,
        class_size: guint,
        class_init: GClassInitFunc,
        instance_size: guint,
        instance_init: GInstanceInitFunc,
        flags: GTypeFlags,
    ) -> GType;
}
extern "C" {
    pub fn g_type_register_dynamic(parent_type: GType, type_name: *const gchar, plugin: *mut GTypePlugin, flags: GTypeFlags) -> GType;
}
extern "C" {
    pub fn g_type_register_fundamental(
        type_id: GType,
        type_name: *const gchar,
        info: *const GTypeInfo,
        finfo: *const GTypeFundamentalInfo,
        flags: GTypeFlags,
    ) -> GType;
}
extern "C" {
    pub fn g_type_add_interface_static(instance_type: GType, interface_type: GType, info: *const GInterfaceInfo);
}
extern "C" {
    pub fn g_type_add_interface_dynamic(instance_type: GType, interface_type: GType, plugin: *mut GTypePlugin);
}
extern "C" {
    pub fn g_type_interface_add_prerequisite(interface_type: GType, prerequisite_type: GType);
}
extern "C" {
    pub fn g_type_interface_prerequisites(interface_type: GType, n_prerequisites: *mut guint) -> *mut GType;
}
extern "C" {
    pub fn g_type_class_add_private(g_class: gpointer, private_size: gsize);
}
extern "C" {
    pub fn g_type_add_instance_private(class_type: GType, private_size: gsize) -> gint;
}
extern "C" {
    pub fn g_type_instance_get_private(instance: *mut GTypeInstance, private_type: GType) -> gpointer;
}
extern "C" {
    pub fn g_type_class_adjust_private_offset(g_class: gpointer, private_size_or_offset: *mut gint);
}
extern "C" {
    pub fn g_type_add_class_private(class_type: GType, private_size: gsize);
}
extern "C" {
    pub fn g_type_class_get_private(klass: *mut GTypeClass, private_type: GType) -> gpointer;
}
extern "C" {
    pub fn g_type_class_get_instance_private_offset(g_class: gpointer) -> gint;
}
extern "C" {
    pub fn g_type_ensure(type_: GType);
}
extern "C" {
    pub fn g_type_get_type_registration_serial() -> guint;
}
extern "C" {
    pub fn g_type_get_plugin(type_: GType) -> *mut GTypePlugin;
}
extern "C" {
    pub fn g_type_interface_get_plugin(instance_type: GType, interface_type: GType) -> *mut GTypePlugin;
}
extern "C" {
    pub fn g_type_fundamental_next() -> GType;
}
extern "C" {
    pub fn g_type_fundamental(type_id: GType) -> GType;
}
extern "C" {
    pub fn g_type_create_instance(type_: GType) -> *mut GTypeInstance;
}
extern "C" {
    pub fn g_type_free_instance(instance: *mut GTypeInstance);
}
extern "C" {
    pub fn g_type_add_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc);
}
extern "C" {
    pub fn g_type_remove_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc);
}
extern "C" {
    pub fn g_type_class_unref_uncached(g_class: gpointer);
}
extern "C" {
    pub fn g_type_add_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc);
}
extern "C" {
    pub fn g_type_remove_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc);
}
extern "C" {
    pub fn g_type_value_table_peek(type_: GType) -> *mut GTypeValueTable;
}
extern "C" {
    pub fn g_type_check_instance(instance: *mut GTypeInstance) -> gboolean;
}
extern "C" {
    pub fn g_type_check_instance_cast(instance: *mut GTypeInstance, iface_type: GType) -> *mut GTypeInstance;
}
extern "C" {
    pub fn g_type_check_instance_is_a(instance: *mut GTypeInstance, iface_type: GType) -> gboolean;
}
extern "C" {
    pub fn g_type_check_instance_is_fundamentally_a(instance: *mut GTypeInstance, fundamental_type: GType) -> gboolean;
}
extern "C" {
    pub fn g_type_check_class_cast(g_class: *mut GTypeClass, is_a_type: GType) -> *mut GTypeClass;
}
extern "C" {
    pub fn g_type_check_class_is_a(g_class: *mut GTypeClass, is_a_type: GType) -> gboolean;
}
extern "C" {
    pub fn g_type_check_is_value_type(type_: GType) -> gboolean;
}
extern "C" {
    pub fn g_type_check_value(value: *mut GValue) -> gboolean;
}
extern "C" {
    pub fn g_type_check_value_holds(value: *mut GValue, type_: GType) -> gboolean;
}
extern "C" {
    pub fn g_type_test_flags(type_: GType, flags: guint) -> gboolean;
}
extern "C" {
    pub fn g_type_name_from_instance(instance: *mut GTypeInstance) -> *const gchar;
}
extern "C" {
    pub fn g_type_name_from_class(g_class: *mut GTypeClass) -> *const gchar;
}
/// GValueTransform:
/// @src_value: Source value.
/// @dest_value: Target value.
///
/// The type of value transformation functions which can be registered with
/// g_value_register_transform_func().
pub type GValueTransform = ::std::option::Option<unsafe extern "C" fn(src_value: *const GValue, dest_value: *mut GValue)>;
/// GValue:
///
/// An opaque structure used to hold different types of values.
/// The data within the structure has protected scope: it is accessible only
/// to functions within a #GTypeValueTable structure, or implementations of
/// the g_value_*() API. That is, code portions which implement new fundamental
/// types.
/// #GValue users cannot make any assumptions about how data is stored
/// within the 2 element @data union, and the @g_type member should
/// only be accessed through the G_VALUE_TYPE() macro.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GValue {
    pub g_type: GType,
    pub data: [_GValue__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GValue__bindgen_ty_1 {
    pub v_int: gint,
    pub v_uint: guint,
    pub v_long: glong,
    pub v_ulong: gulong,
    pub v_int64: gint64,
    pub v_uint64: guint64,
    pub v_float: gfloat,
    pub v_double: gdouble,
    pub v_pointer: gpointer,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__GValue__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GValue__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GValue__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GValue__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GValue__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_uint as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_uint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_long as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_long)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_ulong as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_ulong)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_int64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_int64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_uint64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_uint64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_float as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_double as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_double)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_pointer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_pointer)
        )
    );
}
#[test]
fn bindgen_test_layout__GValue() {
    assert_eq!(
        ::std::mem::size_of::<_GValue>(),
        24usize,
        concat!("Size of: ", stringify!(_GValue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue>())).g_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue),
            "::",
            stringify!(g_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn g_value_init(value: *mut GValue, g_type: GType) -> *mut GValue;
}
extern "C" {
    pub fn g_value_copy(src_value: *const GValue, dest_value: *mut GValue);
}
extern "C" {
    pub fn g_value_reset(value: *mut GValue) -> *mut GValue;
}
extern "C" {
    pub fn g_value_unset(value: *mut GValue);
}
extern "C" {
    pub fn g_value_set_instance(value: *mut GValue, instance: gpointer);
}
extern "C" {
    pub fn g_value_init_from_instance(value: *mut GValue, instance: gpointer);
}
extern "C" {
    pub fn g_value_fits_pointer(value: *const GValue) -> gboolean;
}
extern "C" {
    pub fn g_value_peek_pointer(value: *const GValue) -> gpointer;
}
extern "C" {
    pub fn g_value_type_compatible(src_type: GType, dest_type: GType) -> gboolean;
}
extern "C" {
    pub fn g_value_type_transformable(src_type: GType, dest_type: GType) -> gboolean;
}
extern "C" {
    pub fn g_value_transform(src_value: *const GValue, dest_value: *mut GValue) -> gboolean;
}
extern "C" {
    pub fn g_value_register_transform_func(src_type: GType, dest_type: GType, transform_func: GValueTransform);
}
pub const GParamFlags_G_PARAM_READABLE: GParamFlags = 1;
pub const GParamFlags_G_PARAM_WRITABLE: GParamFlags = 2;
pub const GParamFlags_G_PARAM_READWRITE: GParamFlags = 3;
pub const GParamFlags_G_PARAM_CONSTRUCT: GParamFlags = 4;
pub const GParamFlags_G_PARAM_CONSTRUCT_ONLY: GParamFlags = 8;
pub const GParamFlags_G_PARAM_LAX_VALIDATION: GParamFlags = 16;
pub const GParamFlags_G_PARAM_STATIC_NAME: GParamFlags = 32;
pub const GParamFlags_G_PARAM_PRIVATE: GParamFlags = 32;
pub const GParamFlags_G_PARAM_STATIC_NICK: GParamFlags = 64;
pub const GParamFlags_G_PARAM_STATIC_BLURB: GParamFlags = 128;
pub const GParamFlags_G_PARAM_EXPLICIT_NOTIFY: GParamFlags = 1073741824;
pub const GParamFlags_G_PARAM_DEPRECATED: GParamFlags = -2147483648;
pub type GParamFlags = ::std::os::raw::c_int;
pub type GParamSpec = _GParamSpec;
pub type GParamSpecClass = _GParamSpecClass;
pub type GParameter = _GParameter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecPool {
    _unused: [u8; 0],
}
pub type GParamSpecPool = _GParamSpecPool;
/// GParamSpec: (ref-func g_param_spec_ref_sink) (unref-func g_param_spec_uref) (set-value-func g_value_set_param) (get-value-func g_value_get_param)
/// @g_type_instance: private #GTypeInstance portion
/// @name: name of this parameter: always an interned string
/// @flags: #GParamFlags flags for this parameter
/// @value_type: the #GValue type for this parameter
/// @owner_type: #GType type that uses (introduces) this parameter
///
/// All other fields of the GParamSpec struct are private and
/// should not be used directly.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpec {
    pub g_type_instance: GTypeInstance,
    pub name: *const gchar,
    pub flags: GParamFlags,
    pub value_type: GType,
    pub owner_type: GType,
    pub _nick: *mut gchar,
    pub _blurb: *mut gchar,
    pub qdata: *mut GData,
    pub ref_count: guint,
    pub param_id: guint,
}
#[test]
fn bindgen_test_layout__GParamSpec() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpec>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpec))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpec>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).g_type_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(g_type_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).value_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(value_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).owner_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(owner_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>()))._nick as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(_nick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>()))._blurb as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(_blurb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).qdata as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(qdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).ref_count as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).param_id as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(param_id)
        )
    );
}
/// GParamSpecClass:
/// @g_type_class: the parent class
/// @value_type: the #GValue type for this parameter
/// @finalize: The instance finalization function (optional), should chain
/// up to the finalize method of the parent class.
/// @value_set_default: Resets a @value to the default value for this type
/// (recommended, the default is g_value_reset()), see
/// g_param_value_set_default().
/// @value_validate: Ensures that the contents of @value comply with the
/// specifications set out by this type (optional), see
/// g_param_value_validate().
/// @values_cmp: Compares @value1 with @value2 according to this type
/// (recommended, the default is memcmp()), see g_param_values_cmp().
///
/// The class structure for the GParamSpec type.
/// Normally, GParamSpec classes are filled by
/// g_param_type_register_static().
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecClass {
    pub g_type_class: GTypeClass,
    pub value_type: GType,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec)>,
    pub value_set_default: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue)>,
    pub value_validate: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean>,
    pub values_cmp:
        ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec, value1: *const GValue, value2: *const GValue) -> gint>,
    pub dummy: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout__GParamSpecClass() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecClass>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecClass>())).g_type_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(g_type_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecClass>())).value_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(value_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecClass>())).finalize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecClass>())).value_set_default as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(value_set_default)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecClass>())).value_validate as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(value_validate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecClass>())).values_cmp as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(values_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecClass>())).dummy as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(dummy)
        )
    );
}
/// GParameter:
/// @name: the parameter name
/// @value: the parameter value
///
/// The GParameter struct is an auxiliary structure used
/// to hand parameter name/value pairs to g_object_newv().
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GParameter {
    pub name: *const gchar,
    pub value: GValue,
}
#[test]
fn bindgen_test_layout__GParameter() {
    assert_eq!(
        ::std::mem::size_of::<_GParameter>(),
        32usize,
        concat!("Size of: ", stringify!(_GParameter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParameter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParameter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParameter>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParameter),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParameter>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParameter),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    pub fn g_param_spec_ref(pspec: *mut GParamSpec) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_unref(pspec: *mut GParamSpec);
}
extern "C" {
    pub fn g_param_spec_sink(pspec: *mut GParamSpec);
}
extern "C" {
    pub fn g_param_spec_ref_sink(pspec: *mut GParamSpec) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_get_qdata(pspec: *mut GParamSpec, quark: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_param_spec_set_qdata(pspec: *mut GParamSpec, quark: GQuark, data: gpointer);
}
extern "C" {
    pub fn g_param_spec_set_qdata_full(pspec: *mut GParamSpec, quark: GQuark, data: gpointer, destroy: GDestroyNotify);
}
extern "C" {
    pub fn g_param_spec_steal_qdata(pspec: *mut GParamSpec, quark: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_param_spec_get_redirect_target(pspec: *mut GParamSpec) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_value_set_default(pspec: *mut GParamSpec, value: *mut GValue);
}
extern "C" {
    pub fn g_param_value_defaults(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean;
}
extern "C" {
    pub fn g_param_value_validate(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean;
}
extern "C" {
    pub fn g_param_value_convert(
        pspec: *mut GParamSpec,
        src_value: *const GValue,
        dest_value: *mut GValue,
        strict_validation: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn g_param_values_cmp(pspec: *mut GParamSpec, value1: *const GValue, value2: *const GValue) -> gint;
}
extern "C" {
    pub fn g_param_spec_get_name(pspec: *mut GParamSpec) -> *const gchar;
}
extern "C" {
    pub fn g_param_spec_get_nick(pspec: *mut GParamSpec) -> *const gchar;
}
extern "C" {
    pub fn g_param_spec_get_blurb(pspec: *mut GParamSpec) -> *const gchar;
}
extern "C" {
    pub fn g_value_set_param(value: *mut GValue, param: *mut GParamSpec);
}
extern "C" {
    pub fn g_value_get_param(value: *const GValue) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_value_dup_param(value: *const GValue) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_value_take_param(value: *mut GValue, param: *mut GParamSpec);
}
extern "C" {
    pub fn g_value_set_param_take_ownership(value: *mut GValue, param: *mut GParamSpec);
}
extern "C" {
    pub fn g_param_spec_get_default_value(pspec: *mut GParamSpec) -> *const GValue;
}
extern "C" {
    pub fn g_param_spec_get_name_quark(pspec: *mut GParamSpec) -> GQuark;
}
pub type GParamSpecTypeInfo = _GParamSpecTypeInfo;
/// GParamSpecTypeInfo:
/// @instance_size: Size of the instance (object) structure.
/// @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now.
/// @instance_init: Location of the instance initialization function (optional).
/// @value_type: The #GType of values conforming to this #GParamSpec
/// @finalize: The instance finalization function (optional).
/// @value_set_default: Resets a @value to the default value for @pspec
/// (recommended, the default is g_value_reset()), see
/// g_param_value_set_default().
/// @value_validate: Ensures that the contents of @value comply with the
/// specifications set out by @pspec (optional), see
/// g_param_value_validate().
/// @values_cmp: Compares @value1 with @value2 according to @pspec
/// (recommended, the default is memcmp()), see g_param_values_cmp().
///
/// This structure is used to provide the type system with the information
/// required to initialize and destruct (finalize) a parameter's class and
/// instances thereof.
/// The initialized structure is passed to the g_param_type_register_static()
/// The type system will perform a deep copy of this structure, so its memory
/// does not need to be persistent across invocation of
/// g_param_type_register_static().
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecTypeInfo {
    pub instance_size: guint16,
    pub n_preallocs: guint16,
    pub instance_init: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec)>,
    pub value_type: GType,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec)>,
    pub value_set_default: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue)>,
    pub value_validate: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean>,
    pub values_cmp:
        ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec, value1: *const GValue, value2: *const GValue) -> gint>,
}
#[test]
fn bindgen_test_layout__GParamSpecTypeInfo() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecTypeInfo>(),
        56usize,
        concat!("Size of: ", stringify!(_GParamSpecTypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecTypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecTypeInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).instance_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(instance_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).n_preallocs as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(n_preallocs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).instance_init as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(instance_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).value_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(value_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).finalize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).value_set_default as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(value_set_default)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).value_validate as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(value_validate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).values_cmp as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(values_cmp)
        )
    );
}
extern "C" {
    pub fn g_param_type_register_static(name: *const gchar, pspec_info: *const GParamSpecTypeInfo) -> GType;
}
extern "C" {
    pub fn _g_param_type_register_static_constant(name: *const gchar, pspec_info: *const GParamSpecTypeInfo, opt_type: GType) -> GType;
}
extern "C" {
    pub fn g_param_spec_internal(
        param_type: GType,
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        flags: GParamFlags,
    ) -> gpointer;
}
extern "C" {
    pub fn g_param_spec_pool_new(type_prefixing: gboolean) -> *mut GParamSpecPool;
}
extern "C" {
    pub fn g_param_spec_pool_insert(pool: *mut GParamSpecPool, pspec: *mut GParamSpec, owner_type: GType);
}
extern "C" {
    pub fn g_param_spec_pool_remove(pool: *mut GParamSpecPool, pspec: *mut GParamSpec);
}
extern "C" {
    pub fn g_param_spec_pool_lookup(
        pool: *mut GParamSpecPool,
        param_name: *const gchar,
        owner_type: GType,
        walk_ancestors: gboolean,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_pool_list_owned(pool: *mut GParamSpecPool, owner_type: GType) -> *mut GList;
}
extern "C" {
    pub fn g_param_spec_pool_list(pool: *mut GParamSpecPool, owner_type: GType, n_pspecs_p: *mut guint) -> *mut *mut GParamSpec;
}
pub type GClosure = _GClosure;
pub type GClosureNotifyData = _GClosureNotifyData;
/// GCallback:
///
/// The type used for callback functions in structure definitions and function
/// signatures. This doesn't mean that all callback functions must take no
/// parameters and return void. The required signature of a callback function
/// is determined by the context in which is used (e.g. the signal to which it
/// is connected). Use G_CALLBACK() to cast the callback function to a #GCallback.
pub type GCallback = ::std::option::Option<unsafe extern "C" fn()>;
/// GClosureNotify:
/// @data: data specified when registering the notification callback
/// @closure: the #GClosure on which the notification is emitted
///
/// The type used for the various notification callbacks which can be registered
/// on closures.
pub type GClosureNotify = ::std::option::Option<unsafe extern "C" fn(data: gpointer, closure: *mut GClosure)>;
/// GClosureMarshal:
/// @closure: the #GClosure to which the marshaller belongs
/// @return_value: (allow-none): a #GValue to store the return
/// value. May be %NULL if the callback of @closure doesn't return a
/// value.
/// @n_param_values: the length of the @param_values array
/// @param_values: (array length=n_param_values): an array of
/// #GValues holding the arguments on which to invoke the
/// callback of @closure
/// @invocation_hint: (allow-none): the invocation hint given as the
/// last argument to g_closure_invoke()
/// @marshal_data: (allow-none): additional data specified when
/// registering the marshaller, see g_closure_set_marshal() and
/// g_closure_set_meta_marshal()
///
/// The type used for marshaller functions.
pub type GClosureMarshal = ::std::option::Option<
    unsafe extern "C" fn(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    ),
>;
/// GVaClosureMarshal:
/// @closure: the #GClosure to which the marshaller belongs
/// @return_value: (allow-none): a #GValue to store the return
/// value. May be %NULL if the callback of @closure doesn't return a
/// value.
/// @instance: (type GObject.TypeInstance): the instance on which the closure is
/// invoked.
/// @args: va_list of arguments to be passed to the closure.
/// @marshal_data: (allow-none): additional data specified when
/// registering the marshaller, see g_closure_set_marshal() and
/// g_closure_set_meta_marshal()
/// @n_params: the length of the @param_types array
/// @param_types: (array length=n_params): the #GType of each argument from
/// @args.
///
/// This is the signature of va_list marshaller functions, an optional
/// marshaller that can be used in some situations to avoid
/// marshalling the signal argument into GValues.
pub type GVaClosureMarshal = ::std::option::Option<
    unsafe extern "C" fn(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    ),
>;
/// GCClosure:
/// @closure: the #GClosure
/// @callback: the callback function
///
/// A #GCClosure is a specialization of #GClosure for C function callbacks.
pub type GCClosure = _GCClosure;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GClosureNotifyData {
    pub data: gpointer,
    pub notify: GClosureNotify,
}
#[test]
fn bindgen_test_layout__GClosureNotifyData() {
    assert_eq!(
        ::std::mem::size_of::<_GClosureNotifyData>(),
        16usize,
        concat!("Size of: ", stringify!(_GClosureNotifyData))
    );
    assert_eq!(
        ::std::mem::align_of::<_GClosureNotifyData>(),
        8usize,
        concat!("Alignment of ", stringify!(_GClosureNotifyData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GClosureNotifyData>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosureNotifyData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GClosureNotifyData>())).notify as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosureNotifyData),
            "::",
            stringify!(notify)
        )
    );
}
/// GClosure:
/// @in_marshal: Indicates whether the closure is currently being invoked with
/// g_closure_invoke()
/// @is_invalid: Indicates whether the closure has been invalidated by
/// g_closure_invalidate()
///
/// A #GClosure represents a callback supplied by the programmer.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GClosure {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub marshal: ::std::option::Option<
        unsafe extern "C" fn(
            closure: *mut GClosure,
            return_value: *mut GValue,
            n_param_values: guint,
            param_values: *const GValue,
            invocation_hint: gpointer,
            marshal_data: gpointer,
        ),
    >,
    pub data: gpointer,
    pub notifiers: *mut GClosureNotifyData,
}
#[test]
fn bindgen_test_layout__GClosure() {
    assert_eq!(
        ::std::mem::size_of::<_GClosure>(),
        32usize,
        concat!("Size of: ", stringify!(_GClosure))
    );
    assert_eq!(
        ::std::mem::align_of::<_GClosure>(),
        8usize,
        concat!("Alignment of ", stringify!(_GClosure))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GClosure>())).marshal as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosure),
            "::",
            stringify!(marshal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GClosure>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosure),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GClosure>())).notifiers as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosure),
            "::",
            stringify!(notifiers)
        )
    );
}
impl _GClosure {
    #[inline]
    pub fn ref_count(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_ref_count(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn meta_marshal_nouse(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_meta_marshal_nouse(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn n_guards(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_n_guards(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn n_fnotifiers(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_n_fnotifiers(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn n_inotifiers(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_n_inotifiers(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn in_inotify(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_inotify(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn floating(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_floating(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn derivative_flag(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_derivative_flag(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_marshal(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_marshal(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_invalid(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_invalid(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ref_count: guint,
        meta_marshal_nouse: guint,
        n_guards: guint,
        n_fnotifiers: guint,
        n_inotifiers: guint,
        in_inotify: guint,
        floating: guint,
        derivative_flag: guint,
        in_marshal: guint,
        is_invalid: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let ref_count: u32 = unsafe { ::std::mem::transmute(ref_count) };
            ref_count as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let meta_marshal_nouse: u32 = unsafe { ::std::mem::transmute(meta_marshal_nouse) };
            meta_marshal_nouse as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let n_guards: u32 = unsafe { ::std::mem::transmute(n_guards) };
            n_guards as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let n_fnotifiers: u32 = unsafe { ::std::mem::transmute(n_fnotifiers) };
            n_fnotifiers as u64
        });
        __bindgen_bitfield_unit.set(19usize, 8u8, {
            let n_inotifiers: u32 = unsafe { ::std::mem::transmute(n_inotifiers) };
            n_inotifiers as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let in_inotify: u32 = unsafe { ::std::mem::transmute(in_inotify) };
            in_inotify as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let floating: u32 = unsafe { ::std::mem::transmute(floating) };
            floating as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let derivative_flag: u32 = unsafe { ::std::mem::transmute(derivative_flag) };
            derivative_flag as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let in_marshal: u32 = unsafe { ::std::mem::transmute(in_marshal) };
            in_marshal as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let is_invalid: u32 = unsafe { ::std::mem::transmute(is_invalid) };
            is_invalid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCClosure {
    pub closure: GClosure,
    pub callback: gpointer,
}
#[test]
fn bindgen_test_layout__GCClosure() {
    assert_eq!(
        ::std::mem::size_of::<_GCClosure>(),
        40usize,
        concat!("Size of: ", stringify!(_GCClosure))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCClosure>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCClosure))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCClosure>())).closure as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCClosure),
            "::",
            stringify!(closure)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCClosure>())).callback as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCClosure),
            "::",
            stringify!(callback)
        )
    );
}
extern "C" {
    pub fn g_cclosure_new(callback_func: GCallback, user_data: gpointer, destroy_data: GClosureNotify) -> *mut GClosure;
}
extern "C" {
    pub fn g_cclosure_new_swap(callback_func: GCallback, user_data: gpointer, destroy_data: GClosureNotify) -> *mut GClosure;
}
extern "C" {
    pub fn g_signal_type_cclosure_new(itype: GType, struct_offset: guint) -> *mut GClosure;
}
extern "C" {
    pub fn g_closure_ref(closure: *mut GClosure) -> *mut GClosure;
}
extern "C" {
    pub fn g_closure_sink(closure: *mut GClosure);
}
extern "C" {
    pub fn g_closure_unref(closure: *mut GClosure);
}
extern "C" {
    pub fn g_closure_new_simple(sizeof_closure: guint, data: gpointer) -> *mut GClosure;
}
extern "C" {
    pub fn g_closure_add_finalize_notifier(closure: *mut GClosure, notify_data: gpointer, notify_func: GClosureNotify);
}
extern "C" {
    pub fn g_closure_remove_finalize_notifier(closure: *mut GClosure, notify_data: gpointer, notify_func: GClosureNotify);
}
extern "C" {
    pub fn g_closure_add_invalidate_notifier(closure: *mut GClosure, notify_data: gpointer, notify_func: GClosureNotify);
}
extern "C" {
    pub fn g_closure_remove_invalidate_notifier(closure: *mut GClosure, notify_data: gpointer, notify_func: GClosureNotify);
}
extern "C" {
    pub fn g_closure_add_marshal_guards(
        closure: *mut GClosure,
        pre_marshal_data: gpointer,
        pre_marshal_notify: GClosureNotify,
        post_marshal_data: gpointer,
        post_marshal_notify: GClosureNotify,
    );
}
extern "C" {
    pub fn g_closure_set_marshal(closure: *mut GClosure, marshal: GClosureMarshal);
}
extern "C" {
    pub fn g_closure_set_meta_marshal(closure: *mut GClosure, marshal_data: gpointer, meta_marshal: GClosureMarshal);
}
extern "C" {
    pub fn g_closure_invalidate(closure: *mut GClosure);
}
extern "C" {
    pub fn g_closure_invoke(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_generic(
        closure: *mut GClosure,
        return_gvalue: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_generic_va(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args_list: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__VOID(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__VOIDv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__BOOLEAN(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__BOOLEANv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__CHAR(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__CHARv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__UCHAR(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__UCHARv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__INT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__INTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__UINT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__UINTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__LONG(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__LONGv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__ULONG(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__ULONGv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__ENUM(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__ENUMv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__FLAGS(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__FLAGSv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__FLOAT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__FLOATv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__DOUBLE(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__DOUBLEv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__STRING(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__STRINGv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__PARAM(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__PARAMv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__BOXED(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__BOXEDv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__POINTERv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__OBJECT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__OBJECTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__VARIANT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__VARIANTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__UINT_POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__UINT_POINTERv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_BOOLEAN__FLAGS(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_BOOLEAN__FLAGSv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_STRING__OBJECT_POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_STRING__OBJECT_POINTERv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXED(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
pub type GSignalQuery = _GSignalQuery;
pub type GSignalInvocationHint = _GSignalInvocationHint;
/// GSignalCMarshaller:
///
/// This is the signature of marshaller functions, required to marshall
/// arrays of parameter values to signal emissions into C language callback
/// invocations. It is merely an alias to #GClosureMarshal since the #GClosure
/// mechanism takes over responsibility of actual function invocation for the
/// signal system.
pub type GSignalCMarshaller = GClosureMarshal;
/// GSignalCVaMarshaller:
///
/// This is the signature of va_list marshaller functions, an optional
/// marshaller that can be used in some situations to avoid
/// marshalling the signal argument into GValues.
pub type GSignalCVaMarshaller = GVaClosureMarshal;
/// GSignalEmissionHook:
/// @ihint: Signal invocation hint, see #GSignalInvocationHint.
/// @n_param_values: the number of parameters to the function, including
/// the instance on which the signal was emitted.
/// @param_values: (array length=n_param_values): the instance on which
/// the signal was emitted, followed by the parameters of the emission.
/// @data: user data associated with the hook.
///
/// A simple function pointer to get invoked when the signal is emitted. This
/// allows you to tie a hook to the signal type, so that it will trap all
/// emissions of that signal, from any object.
///
/// You may not attach these to signals created with the #G_SIGNAL_NO_HOOKS flag.
///
/// Returns: whether it wants to stay connected. If it returns %FALSE, the signal
/// hook is disconnected (and destroyed).
pub type GSignalEmissionHook = ::std::option::Option<
    unsafe extern "C" fn(ihint: *mut GSignalInvocationHint, n_param_values: guint, param_values: *const GValue, data: gpointer) -> gboolean,
>;
/// GSignalAccumulator:
/// @ihint: Signal invocation hint, see #GSignalInvocationHint.
/// @return_accu: Accumulator to collect callback return values in, this
/// is the return value of the current signal emission.
/// @handler_return: A #GValue holding the return value of the signal handler.
/// @data: Callback data that was specified when creating the signal.
///
/// The signal accumulator is a special callback function that can be used
/// to collect return values of the various callbacks that are called
/// during a signal emission. The signal accumulator is specified at signal
/// creation time, if it is left %NULL, no accumulation of callback return
/// values is performed. The return value of signal emissions is then the
/// value returned by the last callback.
///
/// Returns: The accumulator function returns whether the signal emission
/// should be aborted. Returning %FALSE means to abort the
/// current emission and %TRUE is returned for continuation.
pub type GSignalAccumulator = ::std::option::Option<
    unsafe extern "C" fn(ihint: *mut GSignalInvocationHint, return_accu: *mut GValue, handler_return: *const GValue, data: gpointer)
        -> gboolean,
>;
pub const GSignalFlags_G_SIGNAL_RUN_FIRST: GSignalFlags = 1;
pub const GSignalFlags_G_SIGNAL_RUN_LAST: GSignalFlags = 2;
pub const GSignalFlags_G_SIGNAL_RUN_CLEANUP: GSignalFlags = 4;
pub const GSignalFlags_G_SIGNAL_NO_RECURSE: GSignalFlags = 8;
pub const GSignalFlags_G_SIGNAL_DETAILED: GSignalFlags = 16;
pub const GSignalFlags_G_SIGNAL_ACTION: GSignalFlags = 32;
pub const GSignalFlags_G_SIGNAL_NO_HOOKS: GSignalFlags = 64;
pub const GSignalFlags_G_SIGNAL_MUST_COLLECT: GSignalFlags = 128;
pub const GSignalFlags_G_SIGNAL_DEPRECATED: GSignalFlags = 256;
pub type GSignalFlags = ::std::os::raw::c_uint;
pub const GConnectFlags_G_CONNECT_AFTER: GConnectFlags = 1;
pub const GConnectFlags_G_CONNECT_SWAPPED: GConnectFlags = 2;
pub type GConnectFlags = ::std::os::raw::c_uint;
pub const GSignalMatchType_G_SIGNAL_MATCH_ID: GSignalMatchType = 1;
pub const GSignalMatchType_G_SIGNAL_MATCH_DETAIL: GSignalMatchType = 2;
pub const GSignalMatchType_G_SIGNAL_MATCH_CLOSURE: GSignalMatchType = 4;
pub const GSignalMatchType_G_SIGNAL_MATCH_FUNC: GSignalMatchType = 8;
pub const GSignalMatchType_G_SIGNAL_MATCH_DATA: GSignalMatchType = 16;
pub const GSignalMatchType_G_SIGNAL_MATCH_UNBLOCKED: GSignalMatchType = 32;
pub type GSignalMatchType = ::std::os::raw::c_uint;
/// GSignalInvocationHint:
/// @signal_id: The signal id of the signal invoking the callback
/// @detail: The detail passed on for this emission
/// @run_type: The stage the signal emission is currently in, this
/// field will contain one of %G_SIGNAL_RUN_FIRST,
/// %G_SIGNAL_RUN_LAST or %G_SIGNAL_RUN_CLEANUP.
///
/// The #GSignalInvocationHint structure is used to pass on additional information
/// to callbacks during a signal emission.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSignalInvocationHint {
    pub signal_id: guint,
    pub detail: GQuark,
    pub run_type: GSignalFlags,
}
#[test]
fn bindgen_test_layout__GSignalInvocationHint() {
    assert_eq!(
        ::std::mem::size_of::<_GSignalInvocationHint>(),
        12usize,
        concat!("Size of: ", stringify!(_GSignalInvocationHint))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSignalInvocationHint>(),
        4usize,
        concat!("Alignment of ", stringify!(_GSignalInvocationHint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalInvocationHint>())).signal_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalInvocationHint),
            "::",
            stringify!(signal_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalInvocationHint>())).detail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalInvocationHint),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalInvocationHint>())).run_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalInvocationHint),
            "::",
            stringify!(run_type)
        )
    );
}
/// GSignalQuery:
/// @signal_id: The signal id of the signal being queried, or 0 if the
/// signal to be queried was unknown.
/// @signal_name: The signal name.
/// @itype: The interface/instance type that this signal can be emitted for.
/// @signal_flags: The signal flags as passed in to g_signal_new().
/// @return_type: The return type for user callbacks.
/// @n_params: The number of parameters that user callbacks take.
/// @param_types: (array length=n_params): The individual parameter types for
/// user callbacks, note that the effective callback signature is:
/// |[<!-- language="C" -->
/// @return_type callback (#gpointer     data1,
/// [param_types param_names,]
/// gpointer     data2);
/// ]|
///
/// A structure holding in-depth information for a specific signal. It is
/// filled in by the g_signal_query() function.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSignalQuery {
    pub signal_id: guint,
    pub signal_name: *const gchar,
    pub itype: GType,
    pub signal_flags: GSignalFlags,
    pub return_type: GType,
    pub n_params: guint,
    pub param_types: *const GType,
}
#[test]
fn bindgen_test_layout__GSignalQuery() {
    assert_eq!(
        ::std::mem::size_of::<_GSignalQuery>(),
        56usize,
        concat!("Size of: ", stringify!(_GSignalQuery))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSignalQuery>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSignalQuery))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalQuery>())).signal_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(signal_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalQuery>())).signal_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(signal_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalQuery>())).itype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(itype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalQuery>())).signal_flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(signal_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalQuery>())).return_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(return_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalQuery>())).n_params as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(n_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalQuery>())).param_types as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(param_types)
        )
    );
}
extern "C" {
    pub fn g_signal_newv(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_closure: *mut GClosure,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        param_types: *mut GType,
    ) -> guint;
}
extern "C" {
    pub fn g_signal_new_valist(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_closure: *mut GClosure,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        args: *mut __va_list_tag,
    ) -> guint;
}
extern "C" {
    pub fn g_signal_new(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_offset: guint,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        ...
    ) -> guint;
}
extern "C" {
    pub fn g_signal_new_class_handler(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_handler: GCallback,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        ...
    ) -> guint;
}
extern "C" {
    pub fn g_signal_set_va_marshaller(signal_id: guint, instance_type: GType, va_marshaller: GSignalCVaMarshaller);
}
extern "C" {
    pub fn g_signal_emitv(instance_and_params: *const GValue, signal_id: guint, detail: GQuark, return_value: *mut GValue);
}
extern "C" {
    pub fn g_signal_emit_valist(instance: gpointer, signal_id: guint, detail: GQuark, var_args: *mut __va_list_tag);
}
extern "C" {
    pub fn g_signal_emit(instance: gpointer, signal_id: guint, detail: GQuark, ...);
}
extern "C" {
    pub fn g_signal_emit_by_name(instance: gpointer, detailed_signal: *const gchar, ...);
}
extern "C" {
    pub fn g_signal_lookup(name: *const gchar, itype: GType) -> guint;
}
extern "C" {
    pub fn g_signal_name(signal_id: guint) -> *const gchar;
}
extern "C" {
    pub fn g_signal_query(signal_id: guint, query: *mut GSignalQuery);
}
extern "C" {
    pub fn g_signal_list_ids(itype: GType, n_ids: *mut guint) -> *mut guint;
}
extern "C" {
    pub fn g_signal_parse_name(
        detailed_signal: *const gchar,
        itype: GType,
        signal_id_p: *mut guint,
        detail_p: *mut GQuark,
        force_detail_quark: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn g_signal_get_invocation_hint(instance: gpointer) -> *mut GSignalInvocationHint;
}
extern "C" {
    pub fn g_signal_stop_emission(instance: gpointer, signal_id: guint, detail: GQuark);
}
extern "C" {
    pub fn g_signal_stop_emission_by_name(instance: gpointer, detailed_signal: *const gchar);
}
extern "C" {
    pub fn g_signal_add_emission_hook(
        signal_id: guint,
        detail: GQuark,
        hook_func: GSignalEmissionHook,
        hook_data: gpointer,
        data_destroy: GDestroyNotify,
    ) -> gulong;
}
extern "C" {
    pub fn g_signal_remove_emission_hook(signal_id: guint, hook_id: gulong);
}
extern "C" {
    pub fn g_signal_has_handler_pending(instance: gpointer, signal_id: guint, detail: GQuark, may_be_blocked: gboolean) -> gboolean;
}
extern "C" {
    pub fn g_signal_connect_closure_by_id(
        instance: gpointer,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        after: gboolean,
    ) -> gulong;
}
extern "C" {
    pub fn g_signal_connect_closure(instance: gpointer, detailed_signal: *const gchar, closure: *mut GClosure, after: gboolean) -> gulong;
}
extern "C" {
    pub fn g_signal_connect_data(
        instance: gpointer,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        data: gpointer,
        destroy_data: GClosureNotify,
        connect_flags: GConnectFlags,
    ) -> gulong;
}
extern "C" {
    pub fn g_signal_handler_block(instance: gpointer, handler_id: gulong);
}
extern "C" {
    pub fn g_signal_handler_unblock(instance: gpointer, handler_id: gulong);
}
extern "C" {
    pub fn g_signal_handler_disconnect(instance: gpointer, handler_id: gulong);
}
extern "C" {
    pub fn g_signal_handler_is_connected(instance: gpointer, handler_id: gulong) -> gboolean;
}
extern "C" {
    pub fn g_signal_handler_find(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> gulong;
}
extern "C" {
    pub fn g_signal_handlers_block_matched(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_signal_handlers_unblock_matched(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_signal_handlers_disconnect_matched(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_signal_override_class_closure(signal_id: guint, instance_type: GType, class_closure: *mut GClosure);
}
extern "C" {
    pub fn g_signal_override_class_handler(signal_name: *const gchar, instance_type: GType, class_handler: GCallback);
}
extern "C" {
    pub fn g_signal_chain_from_overridden(instance_and_params: *const GValue, return_value: *mut GValue);
}
extern "C" {
    pub fn g_signal_chain_from_overridden_handler(instance: gpointer, ...);
}
extern "C" {
    pub fn g_signal_accumulator_true_handled(
        ihint: *mut GSignalInvocationHint,
        return_accu: *mut GValue,
        handler_return: *const GValue,
        dummy: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_signal_accumulator_first_wins(
        ihint: *mut GSignalInvocationHint,
        return_accu: *mut GValue,
        handler_return: *const GValue,
        dummy: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_signal_handlers_destroy(instance: gpointer);
}
extern "C" {
    pub fn _g_signals_destroy(itype: GType);
}
extern "C" {
    pub fn g_date_get_type() -> GType;
}
extern "C" {
    pub fn g_strv_get_type() -> GType;
}
extern "C" {
    pub fn g_gstring_get_type() -> GType;
}
extern "C" {
    pub fn g_hash_table_get_type() -> GType;
}
extern "C" {
    pub fn g_array_get_type() -> GType;
}
extern "C" {
    pub fn g_byte_array_get_type() -> GType;
}
extern "C" {
    pub fn g_ptr_array_get_type() -> GType;
}
extern "C" {
    pub fn g_bytes_get_type() -> GType;
}
extern "C" {
    pub fn g_variant_type_get_gtype() -> GType;
}
extern "C" {
    pub fn g_regex_get_type() -> GType;
}
extern "C" {
    pub fn g_match_info_get_type() -> GType;
}
extern "C" {
    pub fn g_error_get_type() -> GType;
}
extern "C" {
    pub fn g_date_time_get_type() -> GType;
}
extern "C" {
    pub fn g_time_zone_get_type() -> GType;
}
extern "C" {
    pub fn g_io_channel_get_type() -> GType;
}
extern "C" {
    pub fn g_io_condition_get_type() -> GType;
}
extern "C" {
    pub fn g_variant_builder_get_type() -> GType;
}
extern "C" {
    pub fn g_variant_dict_get_type() -> GType;
}
extern "C" {
    pub fn g_key_file_get_type() -> GType;
}
extern "C" {
    pub fn g_main_loop_get_type() -> GType;
}
extern "C" {
    pub fn g_main_context_get_type() -> GType;
}
extern "C" {
    pub fn g_source_get_type() -> GType;
}
extern "C" {
    pub fn g_pollfd_get_type() -> GType;
}
extern "C" {
    pub fn g_thread_get_type() -> GType;
}
extern "C" {
    pub fn g_checksum_get_type() -> GType;
}
extern "C" {
    pub fn g_markup_parse_context_get_type() -> GType;
}
extern "C" {
    pub fn g_mapped_file_get_type() -> GType;
}
extern "C" {
    pub fn g_option_group_get_type() -> GType;
}
extern "C" {
    pub fn g_variant_get_gtype() -> GType;
}
/// GBoxedCopyFunc:
/// @boxed: (not nullable): The boxed structure to be copied.
///
/// This function is provided by the user and should produce a copy
/// of the passed in boxed structure.
///
/// Returns: (not nullable): The newly created copy of the boxed structure.
pub type GBoxedCopyFunc = ::std::option::Option<unsafe extern "C" fn(boxed: gpointer) -> gpointer>;
/// GBoxedFreeFunc:
/// @boxed: (not nullable): The boxed structure to be freed.
///
/// This function is provided by the user and should free the boxed
/// structure passed.
pub type GBoxedFreeFunc = ::std::option::Option<unsafe extern "C" fn(boxed: gpointer)>;
extern "C" {
    pub fn g_boxed_copy(boxed_type: GType, src_boxed: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_boxed_free(boxed_type: GType, boxed: gpointer);
}
extern "C" {
    pub fn g_value_set_boxed(value: *mut GValue, v_boxed: gconstpointer);
}
extern "C" {
    pub fn g_value_set_static_boxed(value: *mut GValue, v_boxed: gconstpointer);
}
extern "C" {
    pub fn g_value_take_boxed(value: *mut GValue, v_boxed: gconstpointer);
}
extern "C" {
    pub fn g_value_set_boxed_take_ownership(value: *mut GValue, v_boxed: gconstpointer);
}
extern "C" {
    pub fn g_value_get_boxed(value: *const GValue) -> gpointer;
}
extern "C" {
    pub fn g_value_dup_boxed(value: *const GValue) -> gpointer;
}
extern "C" {
    pub fn g_boxed_type_register_static(name: *const gchar, boxed_copy: GBoxedCopyFunc, boxed_free: GBoxedFreeFunc) -> GType;
}
extern "C" {
    pub fn g_closure_get_type() -> GType;
}
extern "C" {
    pub fn g_value_get_type() -> GType;
}
pub type GObject = _GObject;
pub type GObjectClass = _GObjectClass;
pub type GInitiallyUnowned = _GObject;
pub type GInitiallyUnownedClass = _GObjectClass;
pub type GObjectConstructParam = _GObjectConstructParam;
/// GObjectGetPropertyFunc:
/// @object: a #GObject
/// @property_id: the numeric id under which the property was registered with
/// g_object_class_install_property().
/// @value: a #GValue to return the property value in
/// @pspec: the #GParamSpec describing the property
///
/// The type of the @get_property function of #GObjectClass.
pub type GObjectGetPropertyFunc =
    ::std::option::Option<unsafe extern "C" fn(object: *mut GObject, property_id: guint, value: *mut GValue, pspec: *mut GParamSpec)>;
/// GObjectSetPropertyFunc:
/// @object: a #GObject
/// @property_id: the numeric id under which the property was registered with
/// g_object_class_install_property().
/// @value: the new value for the property
/// @pspec: the #GParamSpec describing the property
///
/// The type of the @set_property function of #GObjectClass.
pub type GObjectSetPropertyFunc =
    ::std::option::Option<unsafe extern "C" fn(object: *mut GObject, property_id: guint, value: *const GValue, pspec: *mut GParamSpec)>;
/// GObjectFinalizeFunc:
/// @object: the #GObject being finalized
///
/// The type of the @finalize function of #GObjectClass.
pub type GObjectFinalizeFunc = ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>;
/// GWeakNotify:
/// @data: data that was provided when the weak reference was established
/// @where_the_object_was: the object being finalized
///
/// A #GWeakNotify function can be added to an object as a callback that gets
/// triggered when the object is finalized. Since the object is already being
/// finalized when the #GWeakNotify is called, there's not much you could do
/// with the object, apart from e.g. using its address as hash-index or the like.
pub type GWeakNotify = ::std::option::Option<unsafe extern "C" fn(data: gpointer, where_the_object_was: *mut GObject)>;
/// GObject:
///
/// All the fields in the GObject structure are private
/// to the #GObject implementation and should never be accessed directly.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObject {
    pub g_type_instance: GTypeInstance,
    pub ref_count: guint,
    pub qdata: *mut GData,
}
#[test]
fn bindgen_test_layout__GObject() {
    assert_eq!(
        ::std::mem::size_of::<_GObject>(),
        24usize,
        concat!("Size of: ", stringify!(_GObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_GObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_GObject))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObject>())).g_type_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(g_type_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObject>())).ref_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObject>())).qdata as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(qdata)
        )
    );
}
/// GObjectClass:
/// @g_type_class: the parent class
/// @constructor: the @constructor function is called by g_object_new () to
/// complete the object initialization after all the construction properties are
/// set. The first thing a @constructor implementation must do is chain up to the
/// @constructor of the parent class. Overriding @constructor should be rarely
/// needed, e.g. to handle construct properties, or to implement singletons.
/// @set_property: the generic setter for all properties of this type. Should be
/// overridden for every type with properties. If implementations of
/// @set_property don't emit property change notification explicitly, this will
/// be done implicitly by the type system. However, if the notify signal is
/// emitted explicitly, the type system will not emit it a second time.
/// @get_property: the generic getter for all properties of this type. Should be
/// overridden for every type with properties.
/// @dispose: the @dispose function is supposed to drop all references to other
/// objects, but keep the instance otherwise intact, so that client method
/// invocations still work. It may be run multiple times (due to reference
/// loops). Before returning, @dispose should chain up to the @dispose method
/// of the parent class.
/// @finalize: instance finalization function, should finish the finalization of
/// the instance begun in @dispose and chain up to the @finalize method of the
/// parent class.
/// @dispatch_properties_changed: emits property change notification for a bunch
/// of properties. Overriding @dispatch_properties_changed should be rarely
/// needed.
/// @notify: the class closure for the notify signal
/// @constructed: the @constructed function is called by g_object_new() as the
/// final step of the object creation process.  At the point of the call, all
/// construction properties have been set on the object.  The purpose of this
/// call is to allow for object initialisation steps that can only be performed
/// after construction properties have been set.  @constructed implementors
/// should chain up to the @constructed call of their parent class to allow it
/// to complete its initialisation.
///
/// The class structure for the GObject type.
///
/// <example>
/// <title>Implementing singletons using a constructor</title>
/// <programlisting>
/// static MySingleton *the_singleton = NULL;
///
/// static GObject*
/// my_singleton_constructor (GType                  type,
/// guint                  n_construct_params,
/// GObjectConstructParam *construct_params)
/// {
/// GObject *object;
///
/// if (!the_singleton)
/// {
/// object = G_OBJECT_CLASS (parent_class)->constructor (type,
/// n_construct_params,
/// construct_params);
/// the_singleton = MY_SINGLETON (object);
/// }
/// else
/// object = g_object_ref (G_OBJECT (the_singleton));
///
/// return object;
/// }
/// </programlisting></example>
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObjectClass {
    pub g_type_class: GTypeClass,
    pub construct_properties: *mut GSList,
    pub constructor: ::std::option::Option<
        unsafe extern "C" fn(type_: GType, n_construct_properties: guint, construct_properties: *mut GObjectConstructParam) -> *mut GObject,
    >,
    pub set_property:
        ::std::option::Option<unsafe extern "C" fn(object: *mut GObject, property_id: guint, value: *const GValue, pspec: *mut GParamSpec)>,
    pub get_property:
        ::std::option::Option<unsafe extern "C" fn(object: *mut GObject, property_id: guint, value: *mut GValue, pspec: *mut GParamSpec)>,
    pub dispose: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub dispatch_properties_changed:
        ::std::option::Option<unsafe extern "C" fn(object: *mut GObject, n_pspecs: guint, pspecs: *mut *mut GParamSpec)>,
    pub notify: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject, pspec: *mut GParamSpec)>,
    pub constructed: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub flags: gsize,
    pub pdummy: [gpointer; 6usize],
}
#[test]
fn bindgen_test_layout__GObjectClass() {
    assert_eq!(
        ::std::mem::size_of::<_GObjectClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GObjectClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GObjectClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GObjectClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).g_type_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(g_type_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).construct_properties as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(construct_properties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).constructor as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(constructor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).set_property as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(set_property)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).get_property as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(get_property)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).dispose as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(dispose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).finalize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).dispatch_properties_changed as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(dispatch_properties_changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).notify as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).constructed as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(constructed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).pdummy as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(pdummy)
        )
    );
}
/// GObjectConstructParam:
/// @pspec: the #GParamSpec of the construct parameter
/// @value: the value to set the parameter to
///
/// The GObjectConstructParam struct is an auxiliary
/// structure used to hand #GParamSpec/#GValue pairs to the @constructor of
/// a #GObjectClass.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObjectConstructParam {
    pub pspec: *mut GParamSpec,
    pub value: *mut GValue,
}
#[test]
fn bindgen_test_layout__GObjectConstructParam() {
    assert_eq!(
        ::std::mem::size_of::<_GObjectConstructParam>(),
        16usize,
        concat!("Size of: ", stringify!(_GObjectConstructParam))
    );
    assert_eq!(
        ::std::mem::align_of::<_GObjectConstructParam>(),
        8usize,
        concat!("Alignment of ", stringify!(_GObjectConstructParam))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectConstructParam>())).pspec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectConstructParam),
            "::",
            stringify!(pspec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectConstructParam>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectConstructParam),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {

    /// GInitiallyUnowned:
    ///
    /// All the fields in the GInitiallyUnowned structure
    /// are private to the #GInitiallyUnowned implementation and should never be
    /// accessed directly.
    /// /
    /// /**
    /// GInitiallyUnownedClass:
    ///
    /// The class structure for the GInitiallyUnowned type.
    pub fn g_initially_unowned_get_type() -> GType;
}
extern "C" {
    pub fn g_object_class_install_property(oclass: *mut GObjectClass, property_id: guint, pspec: *mut GParamSpec);
}
extern "C" {
    pub fn g_object_class_find_property(oclass: *mut GObjectClass, property_name: *const gchar) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_object_class_list_properties(oclass: *mut GObjectClass, n_properties: *mut guint) -> *mut *mut GParamSpec;
}
extern "C" {
    pub fn g_object_class_override_property(oclass: *mut GObjectClass, property_id: guint, name: *const gchar);
}
extern "C" {
    pub fn g_object_class_install_properties(oclass: *mut GObjectClass, n_pspecs: guint, pspecs: *mut *mut GParamSpec);
}
extern "C" {
    pub fn g_object_interface_install_property(g_iface: gpointer, pspec: *mut GParamSpec);
}
extern "C" {
    pub fn g_object_interface_find_property(g_iface: gpointer, property_name: *const gchar) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_object_interface_list_properties(g_iface: gpointer, n_properties_p: *mut guint) -> *mut *mut GParamSpec;
}
extern "C" {
    pub fn g_object_get_type() -> GType;
}
extern "C" {
    pub fn g_object_new(object_type: GType, first_property_name: *const gchar, ...) -> gpointer;
}
extern "C" {
    pub fn g_object_newv(object_type: GType, n_parameters: guint, parameters: *mut GParameter) -> gpointer;
}
extern "C" {
    pub fn g_object_new_valist(object_type: GType, first_property_name: *const gchar, var_args: *mut __va_list_tag) -> *mut GObject;
}
extern "C" {
    pub fn g_object_set(object: gpointer, first_property_name: *const gchar, ...);
}
extern "C" {
    pub fn g_object_get(object: gpointer, first_property_name: *const gchar, ...);
}
extern "C" {
    pub fn g_object_connect(object: gpointer, signal_spec: *const gchar, ...) -> gpointer;
}
extern "C" {
    pub fn g_object_disconnect(object: gpointer, signal_spec: *const gchar, ...);
}
extern "C" {
    pub fn g_object_set_valist(object: *mut GObject, first_property_name: *const gchar, var_args: *mut __va_list_tag);
}
extern "C" {
    pub fn g_object_get_valist(object: *mut GObject, first_property_name: *const gchar, var_args: *mut __va_list_tag);
}
extern "C" {
    pub fn g_object_set_property(object: *mut GObject, property_name: *const gchar, value: *const GValue);
}
extern "C" {
    pub fn g_object_get_property(object: *mut GObject, property_name: *const gchar, value: *mut GValue);
}
extern "C" {
    pub fn g_object_freeze_notify(object: *mut GObject);
}
extern "C" {
    pub fn g_object_notify(object: *mut GObject, property_name: *const gchar);
}
extern "C" {
    pub fn g_object_notify_by_pspec(object: *mut GObject, pspec: *mut GParamSpec);
}
extern "C" {
    pub fn g_object_thaw_notify(object: *mut GObject);
}
extern "C" {
    pub fn g_object_is_floating(object: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_object_ref_sink(object: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_object_ref(object: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_object_unref(object: gpointer);
}
extern "C" {
    pub fn g_object_weak_ref(object: *mut GObject, notify: GWeakNotify, data: gpointer);
}
extern "C" {
    pub fn g_object_weak_unref(object: *mut GObject, notify: GWeakNotify, data: gpointer);
}
extern "C" {
    pub fn g_object_add_weak_pointer(object: *mut GObject, weak_pointer_location: *mut gpointer);
}
extern "C" {
    pub fn g_object_remove_weak_pointer(object: *mut GObject, weak_pointer_location: *mut gpointer);
}
/// GToggleNotify:
/// @data: Callback data passed to g_object_add_toggle_ref()
/// @object: The object on which g_object_add_toggle_ref() was called.
/// @is_last_ref: %TRUE if the toggle reference is now the
/// last reference to the object. %FALSE if the toggle
/// reference was the last reference and there are now other
/// references.
///
/// A callback function used for notification when the state
/// of a toggle reference changes. See g_object_add_toggle_ref().
pub type GToggleNotify = ::std::option::Option<unsafe extern "C" fn(data: gpointer, object: *mut GObject, is_last_ref: gboolean)>;
extern "C" {
    pub fn g_object_add_toggle_ref(object: *mut GObject, notify: GToggleNotify, data: gpointer);
}
extern "C" {
    pub fn g_object_remove_toggle_ref(object: *mut GObject, notify: GToggleNotify, data: gpointer);
}
extern "C" {
    pub fn g_object_get_qdata(object: *mut GObject, quark: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_object_set_qdata(object: *mut GObject, quark: GQuark, data: gpointer);
}
extern "C" {
    pub fn g_object_set_qdata_full(object: *mut GObject, quark: GQuark, data: gpointer, destroy: GDestroyNotify);
}
extern "C" {
    pub fn g_object_steal_qdata(object: *mut GObject, quark: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_object_dup_qdata(object: *mut GObject, quark: GQuark, dup_func: GDuplicateFunc, user_data: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_object_replace_qdata(
        object: *mut GObject,
        quark: GQuark,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    pub fn g_object_get_data(object: *mut GObject, key: *const gchar) -> gpointer;
}
extern "C" {
    pub fn g_object_set_data(object: *mut GObject, key: *const gchar, data: gpointer);
}
extern "C" {
    pub fn g_object_set_data_full(object: *mut GObject, key: *const gchar, data: gpointer, destroy: GDestroyNotify);
}
extern "C" {
    pub fn g_object_steal_data(object: *mut GObject, key: *const gchar) -> gpointer;
}
extern "C" {
    pub fn g_object_dup_data(object: *mut GObject, key: *const gchar, dup_func: GDuplicateFunc, user_data: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_object_replace_data(
        object: *mut GObject,
        key: *const gchar,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    pub fn g_object_watch_closure(object: *mut GObject, closure: *mut GClosure);
}
extern "C" {
    pub fn g_cclosure_new_object(callback_func: GCallback, object: *mut GObject) -> *mut GClosure;
}
extern "C" {
    pub fn g_cclosure_new_object_swap(callback_func: GCallback, object: *mut GObject) -> *mut GClosure;
}
extern "C" {
    pub fn g_closure_new_object(sizeof_closure: guint, object: *mut GObject) -> *mut GClosure;
}
extern "C" {
    pub fn g_value_set_object(value: *mut GValue, v_object: gpointer);
}
extern "C" {
    pub fn g_value_get_object(value: *const GValue) -> gpointer;
}
extern "C" {
    pub fn g_value_dup_object(value: *const GValue) -> gpointer;
}
extern "C" {
    pub fn g_signal_connect_object(
        instance: gpointer,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        gobject: gpointer,
        connect_flags: GConnectFlags,
    ) -> gulong;
}
extern "C" {
    pub fn g_object_force_floating(object: *mut GObject);
}
extern "C" {
    pub fn g_object_run_dispose(object: *mut GObject);
}
extern "C" {
    pub fn g_value_take_object(value: *mut GValue, v_object: gpointer);
}
extern "C" {
    pub fn g_value_set_object_take_ownership(value: *mut GValue, v_object: gpointer);
}
extern "C" {
    pub fn g_object_compat_control(what: gsize, data: gpointer) -> gsize;
}
extern "C" {
    pub fn g_clear_object(object_ptr: *mut *mut GObject);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GWeakRef {
    pub priv_: GWeakRef__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GWeakRef__bindgen_ty_1 {
    pub p: gpointer,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_GWeakRef__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<GWeakRef__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(GWeakRef__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<GWeakRef__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(GWeakRef__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GWeakRef__bindgen_ty_1>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GWeakRef__bindgen_ty_1),
            "::",
            stringify!(p)
        )
    );
}
#[test]
fn bindgen_test_layout_GWeakRef() {
    assert_eq!(
        ::std::mem::size_of::<GWeakRef>(),
        8usize,
        concat!("Size of: ", stringify!(GWeakRef))
    );
    assert_eq!(
        ::std::mem::align_of::<GWeakRef>(),
        8usize,
        concat!("Alignment of ", stringify!(GWeakRef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GWeakRef>())).priv_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GWeakRef),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_weak_ref_init(weak_ref: *mut GWeakRef, object: gpointer);
}
extern "C" {
    pub fn g_weak_ref_clear(weak_ref: *mut GWeakRef);
}
extern "C" {
    pub fn g_weak_ref_get(weak_ref: *mut GWeakRef) -> gpointer;
}
extern "C" {
    pub fn g_weak_ref_set(weak_ref: *mut GWeakRef, object: gpointer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBinding {
    _unused: [u8; 0],
}
/// GBinding:
///
/// GBinding is an opaque structure whose members
/// cannot be accessed directly.
///
/// Since: 2.26
pub type GBinding = _GBinding;
/// GBindingTransformFunc:
/// @binding: a #GBinding
/// @from_value: the #GValue containing the value to transform
/// @to_value: the #GValue in which to store the transformed value
/// @user_data: data passed to the transform function
///
/// A function to be called to transform @from_value to @to_value. If
/// this is the @transform_to function of a binding, then @from_value
/// is the @source_property on the @source object, and @to_value is the
/// @target_property on the @target object. If this is the
/// @transform_from function of a %G_BINDING_BIDIRECTIONAL binding,
/// then those roles are reversed.
///
/// Returns: %TRUE if the transformation was successful, and %FALSE
/// otherwise
///
/// Since: 2.26
pub type GBindingTransformFunc = ::std::option::Option<
    unsafe extern "C" fn(binding: *mut GBinding, from_value: *const GValue, to_value: *mut GValue, user_data: gpointer) -> gboolean,
>;
pub const GBindingFlags_G_BINDING_DEFAULT: GBindingFlags = 0;
pub const GBindingFlags_G_BINDING_BIDIRECTIONAL: GBindingFlags = 1;
pub const GBindingFlags_G_BINDING_SYNC_CREATE: GBindingFlags = 2;
pub const GBindingFlags_G_BINDING_INVERT_BOOLEAN: GBindingFlags = 4;
pub type GBindingFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_binding_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_binding_get_type() -> GType;
}
extern "C" {
    pub fn g_binding_get_flags(binding: *mut GBinding) -> GBindingFlags;
}
extern "C" {
    pub fn g_binding_get_source(binding: *mut GBinding) -> *mut GObject;
}
extern "C" {
    pub fn g_binding_get_target(binding: *mut GBinding) -> *mut GObject;
}
extern "C" {
    pub fn g_binding_get_source_property(binding: *mut GBinding) -> *const gchar;
}
extern "C" {
    pub fn g_binding_get_target_property(binding: *mut GBinding) -> *const gchar;
}
extern "C" {
    pub fn g_binding_unbind(binding: *mut GBinding);
}
extern "C" {
    pub fn g_object_bind_property(
        source: gpointer,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
    ) -> *mut GBinding;
}
extern "C" {
    pub fn g_object_bind_property_full(
        source: gpointer,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
        transform_to: GBindingTransformFunc,
        transform_from: GBindingTransformFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> *mut GBinding;
}
extern "C" {
    pub fn g_object_bind_property_with_closures(
        source: gpointer,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
        transform_to: *mut GClosure,
        transform_from: *mut GClosure,
    ) -> *mut GBinding;
}
pub type GEnumClass = _GEnumClass;
pub type GFlagsClass = _GFlagsClass;
pub type GEnumValue = _GEnumValue;
pub type GFlagsValue = _GFlagsValue;
/// GEnumClass:
/// @g_type_class: the parent class
/// @minimum: the smallest possible value.
/// @maximum: the largest possible value.
/// @n_values: the number of possible values.
/// @values: an array of #GEnumValue structs describing the
/// individual values.
///
/// The class of an enumeration type holds information about its
/// possible values.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEnumClass {
    pub g_type_class: GTypeClass,
    pub minimum: gint,
    pub maximum: gint,
    pub n_values: guint,
    pub values: *mut GEnumValue,
}
#[test]
fn bindgen_test_layout__GEnumClass() {
    assert_eq!(
        ::std::mem::size_of::<_GEnumClass>(),
        32usize,
        concat!("Size of: ", stringify!(_GEnumClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GEnumClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GEnumClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumClass>())).g_type_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(g_type_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumClass>())).minimum as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumClass>())).maximum as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumClass>())).n_values as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(n_values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumClass>())).values as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(values)
        )
    );
}
/// GFlagsClass:
/// @g_type_class: the parent class
/// @mask: a mask covering all possible values.
/// @n_values: the number of possible values.
/// @values: an array of #GFlagsValue structs describing the
/// individual values.
///
/// The class of a flags type holds information about its
/// possible values.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFlagsClass {
    pub g_type_class: GTypeClass,
    pub mask: guint,
    pub n_values: guint,
    pub values: *mut GFlagsValue,
}
#[test]
fn bindgen_test_layout__GFlagsClass() {
    assert_eq!(
        ::std::mem::size_of::<_GFlagsClass>(),
        24usize,
        concat!("Size of: ", stringify!(_GFlagsClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFlagsClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFlagsClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFlagsClass>())).g_type_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsClass),
            "::",
            stringify!(g_type_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFlagsClass>())).mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsClass),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFlagsClass>())).n_values as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsClass),
            "::",
            stringify!(n_values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFlagsClass>())).values as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsClass),
            "::",
            stringify!(values)
        )
    );
}
/// GEnumValue:
/// @value: the enum value
/// @value_name: the name of the value
/// @value_nick: the nickname of the value
///
/// A structure which contains a single enum value, its name, and its
/// nickname.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEnumValue {
    pub value: gint,
    pub value_name: *const gchar,
    pub value_nick: *const gchar,
}
#[test]
fn bindgen_test_layout__GEnumValue() {
    assert_eq!(
        ::std::mem::size_of::<_GEnumValue>(),
        24usize,
        concat!("Size of: ", stringify!(_GEnumValue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GEnumValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GEnumValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumValue>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumValue),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumValue>())).value_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumValue),
            "::",
            stringify!(value_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumValue>())).value_nick as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumValue),
            "::",
            stringify!(value_nick)
        )
    );
}
/// GFlagsValue:
/// @value: the flags value
/// @value_name: the name of the value
/// @value_nick: the nickname of the value
///
/// A structure which contains a single flags value, its name, and its
/// nickname.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFlagsValue {
    pub value: guint,
    pub value_name: *const gchar,
    pub value_nick: *const gchar,
}
#[test]
fn bindgen_test_layout__GFlagsValue() {
    assert_eq!(
        ::std::mem::size_of::<_GFlagsValue>(),
        24usize,
        concat!("Size of: ", stringify!(_GFlagsValue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFlagsValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFlagsValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFlagsValue>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsValue),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFlagsValue>())).value_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsValue),
            "::",
            stringify!(value_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFlagsValue>())).value_nick as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsValue),
            "::",
            stringify!(value_nick)
        )
    );
}
extern "C" {
    pub fn g_enum_get_value(enum_class: *mut GEnumClass, value: gint) -> *mut GEnumValue;
}
extern "C" {
    pub fn g_enum_get_value_by_name(enum_class: *mut GEnumClass, name: *const gchar) -> *mut GEnumValue;
}
extern "C" {
    pub fn g_enum_get_value_by_nick(enum_class: *mut GEnumClass, nick: *const gchar) -> *mut GEnumValue;
}
extern "C" {
    pub fn g_flags_get_first_value(flags_class: *mut GFlagsClass, value: guint) -> *mut GFlagsValue;
}
extern "C" {
    pub fn g_flags_get_value_by_name(flags_class: *mut GFlagsClass, name: *const gchar) -> *mut GFlagsValue;
}
extern "C" {
    pub fn g_flags_get_value_by_nick(flags_class: *mut GFlagsClass, nick: *const gchar) -> *mut GFlagsValue;
}
extern "C" {
    pub fn g_value_set_enum(value: *mut GValue, v_enum: gint);
}
extern "C" {
    pub fn g_value_get_enum(value: *const GValue) -> gint;
}
extern "C" {
    pub fn g_value_set_flags(value: *mut GValue, v_flags: guint);
}
extern "C" {
    pub fn g_value_get_flags(value: *const GValue) -> guint;
}
extern "C" {
    pub fn g_enum_register_static(name: *const gchar, const_static_values: *const GEnumValue) -> GType;
}
extern "C" {
    pub fn g_flags_register_static(name: *const gchar, const_static_values: *const GFlagsValue) -> GType;
}
extern "C" {
    pub fn g_enum_complete_type_info(g_enum_type: GType, info: *mut GTypeInfo, const_values: *const GEnumValue);
}
extern "C" {
    pub fn g_flags_complete_type_info(g_flags_type: GType, info: *mut GTypeInfo, const_values: *const GFlagsValue);
}
pub type GParamSpecChar = _GParamSpecChar;
pub type GParamSpecUChar = _GParamSpecUChar;
pub type GParamSpecBoolean = _GParamSpecBoolean;
pub type GParamSpecInt = _GParamSpecInt;
pub type GParamSpecUInt = _GParamSpecUInt;
pub type GParamSpecLong = _GParamSpecLong;
pub type GParamSpecULong = _GParamSpecULong;
pub type GParamSpecInt64 = _GParamSpecInt64;
pub type GParamSpecUInt64 = _GParamSpecUInt64;
pub type GParamSpecUnichar = _GParamSpecUnichar;
pub type GParamSpecEnum = _GParamSpecEnum;
pub type GParamSpecFlags = _GParamSpecFlags;
pub type GParamSpecFloat = _GParamSpecFloat;
pub type GParamSpecDouble = _GParamSpecDouble;
pub type GParamSpecString = _GParamSpecString;
pub type GParamSpecParam = _GParamSpecParam;
pub type GParamSpecBoxed = _GParamSpecBoxed;
pub type GParamSpecPointer = _GParamSpecPointer;
pub type GParamSpecValueArray = _GParamSpecValueArray;
pub type GParamSpecObject = _GParamSpecObject;
pub type GParamSpecOverride = _GParamSpecOverride;
pub type GParamSpecGType = _GParamSpecGType;
pub type GParamSpecVariant = _GParamSpecVariant;
/// GParamSpecChar:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for character properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecChar {
    pub parent_instance: GParamSpec,
    pub minimum: gint8,
    pub maximum: gint8,
    pub default_value: gint8,
}
#[test]
fn bindgen_test_layout__GParamSpecChar() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecChar>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecChar))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecChar>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecChar))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecChar>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecChar),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecChar>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecChar),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecChar>())).maximum as *const _ as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecChar),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecChar>())).default_value as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecChar),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecUChar:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for unsigned character properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUChar {
    pub parent_instance: GParamSpec,
    pub minimum: guint8,
    pub maximum: guint8,
    pub default_value: guint8,
}
#[test]
fn bindgen_test_layout__GParamSpecUChar() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecUChar>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecUChar))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecUChar>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecUChar))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUChar>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUChar),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUChar>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUChar),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUChar>())).maximum as *const _ as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUChar),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUChar>())).default_value as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUChar),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecBoolean:
/// @parent_instance: private #GParamSpec portion
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for boolean properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecBoolean {
    pub parent_instance: GParamSpec,
    pub default_value: gboolean,
}
#[test]
fn bindgen_test_layout__GParamSpecBoolean() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecBoolean>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecBoolean))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecBoolean>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecBoolean))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecBoolean>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecBoolean),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecBoolean>())).default_value as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecBoolean),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecInt:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for integer properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecInt {
    pub parent_instance: GParamSpec,
    pub minimum: gint,
    pub maximum: gint,
    pub default_value: gint,
}
#[test]
fn bindgen_test_layout__GParamSpecInt() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecInt>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecInt))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecInt>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecInt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecInt>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecInt>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecInt>())).maximum as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecInt>())).default_value as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecUInt:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for unsigned integer properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUInt {
    pub parent_instance: GParamSpec,
    pub minimum: guint,
    pub maximum: guint,
    pub default_value: guint,
}
#[test]
fn bindgen_test_layout__GParamSpecUInt() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecUInt>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecUInt))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecUInt>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecUInt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUInt>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUInt>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUInt>())).maximum as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUInt>())).default_value as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecLong:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for long integer properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecLong {
    pub parent_instance: GParamSpec,
    pub minimum: glong,
    pub maximum: glong,
    pub default_value: glong,
}
#[test]
fn bindgen_test_layout__GParamSpecLong() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecLong>(),
        96usize,
        concat!("Size of: ", stringify!(_GParamSpecLong))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecLong>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecLong))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecLong>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecLong),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecLong>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecLong),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecLong>())).maximum as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecLong),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecLong>())).default_value as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecLong),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecULong:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for unsigned long integer properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecULong {
    pub parent_instance: GParamSpec,
    pub minimum: gulong,
    pub maximum: gulong,
    pub default_value: gulong,
}
#[test]
fn bindgen_test_layout__GParamSpecULong() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecULong>(),
        96usize,
        concat!("Size of: ", stringify!(_GParamSpecULong))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecULong>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecULong))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecULong>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecULong),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecULong>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecULong),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecULong>())).maximum as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecULong),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecULong>())).default_value as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecULong),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecInt64:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for 64bit integer properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: gint64,
    pub maximum: gint64,
    pub default_value: gint64,
}
#[test]
fn bindgen_test_layout__GParamSpecInt64() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecInt64>(),
        96usize,
        concat!("Size of: ", stringify!(_GParamSpecInt64))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecInt64>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecInt64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecInt64>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt64),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecInt64>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt64),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecInt64>())).maximum as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt64),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecInt64>())).default_value as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt64),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecUInt64:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for unsigned 64bit integer properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: guint64,
    pub maximum: guint64,
    pub default_value: guint64,
}
#[test]
fn bindgen_test_layout__GParamSpecUInt64() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecUInt64>(),
        96usize,
        concat!("Size of: ", stringify!(_GParamSpecUInt64))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecUInt64>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecUInt64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUInt64>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt64),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUInt64>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt64),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUInt64>())).maximum as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt64),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUInt64>())).default_value as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt64),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecUnichar:
/// @parent_instance: private #GParamSpec portion
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for unichar (unsigned integer) properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUnichar {
    pub parent_instance: GParamSpec,
    pub default_value: gunichar,
}
#[test]
fn bindgen_test_layout__GParamSpecUnichar() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecUnichar>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecUnichar))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecUnichar>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecUnichar))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUnichar>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUnichar),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUnichar>())).default_value as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUnichar),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecEnum:
/// @parent_instance: private #GParamSpec portion
/// @enum_class: the #GEnumClass for the enum
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for enum
/// properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecEnum {
    pub parent_instance: GParamSpec,
    pub enum_class: *mut GEnumClass,
    pub default_value: gint,
}
#[test]
fn bindgen_test_layout__GParamSpecEnum() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecEnum>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecEnum))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecEnum>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecEnum))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecEnum>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecEnum),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecEnum>())).enum_class as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecEnum),
            "::",
            stringify!(enum_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecEnum>())).default_value as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecEnum),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecFlags:
/// @parent_instance: private #GParamSpec portion
/// @flags_class: the #GFlagsClass for the flags
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for flags
/// properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecFlags {
    pub parent_instance: GParamSpec,
    pub flags_class: *mut GFlagsClass,
    pub default_value: guint,
}
#[test]
fn bindgen_test_layout__GParamSpecFlags() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecFlags>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecFlags))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecFlags>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecFlags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecFlags>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFlags),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecFlags>())).flags_class as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFlags),
            "::",
            stringify!(flags_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecFlags>())).default_value as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFlags),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecFloat:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
/// @epsilon: values closer than @epsilon will be considered identical
/// by g_param_values_cmp(); the default value is 1e-30.
///
/// A #GParamSpec derived structure that contains the meta data for float properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecFloat {
    pub parent_instance: GParamSpec,
    pub minimum: gfloat,
    pub maximum: gfloat,
    pub default_value: gfloat,
    pub epsilon: gfloat,
}
#[test]
fn bindgen_test_layout__GParamSpecFloat() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecFloat>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecFloat))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecFloat>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecFloat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecFloat>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecFloat>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecFloat>())).maximum as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecFloat>())).default_value as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecFloat>())).epsilon as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(epsilon)
        )
    );
}
/// GParamSpecDouble:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
/// @epsilon: values closer than @epsilon will be considered identical
/// by g_param_values_cmp(); the default value is 1e-90.
///
/// A #GParamSpec derived structure that contains the meta data for double properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecDouble {
    pub parent_instance: GParamSpec,
    pub minimum: gdouble,
    pub maximum: gdouble,
    pub default_value: gdouble,
    pub epsilon: gdouble,
}
#[test]
fn bindgen_test_layout__GParamSpecDouble() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecDouble>(),
        104usize,
        concat!("Size of: ", stringify!(_GParamSpecDouble))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecDouble>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecDouble))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecDouble>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecDouble>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecDouble>())).maximum as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecDouble>())).default_value as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecDouble>())).epsilon as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(epsilon)
        )
    );
}
/// GParamSpecString:
/// @parent_instance: private #GParamSpec portion
/// @default_value: default value for the property specified
/// @cset_first: a string containing the allowed values for the first byte
/// @cset_nth: a string containing the allowed values for the subsequent bytes
/// @substitutor: the replacement byte for bytes which don't match @cset_first or @cset_nth.
/// @null_fold_if_empty: replace empty string by %NULL
/// @ensure_non_null: replace %NULL strings by an empty string
///
/// A #GParamSpec derived structure that contains the meta data for string
/// properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecString {
    pub parent_instance: GParamSpec,
    pub default_value: *mut gchar,
    pub cset_first: *mut gchar,
    pub cset_nth: *mut gchar,
    pub substitutor: gchar,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u16; 3usize],
}
#[test]
fn bindgen_test_layout__GParamSpecString() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecString>(),
        104usize,
        concat!("Size of: ", stringify!(_GParamSpecString))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecString>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecString))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecString>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecString>())).default_value as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecString>())).cset_first as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(cset_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecString>())).cset_nth as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(cset_nth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecString>())).substitutor as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(substitutor)
        )
    );
}
impl _GParamSpecString {
    #[inline]
    pub fn null_fold_if_empty(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_null_fold_if_empty(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ensure_non_null(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ensure_non_null(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(null_fold_if_empty: guint, ensure_non_null: guint) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let null_fold_if_empty: u32 = unsafe { ::std::mem::transmute(null_fold_if_empty) };
            null_fold_if_empty as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ensure_non_null: u32 = unsafe { ::std::mem::transmute(ensure_non_null) };
            ensure_non_null as u64
        });
        __bindgen_bitfield_unit
    }
}
/// GParamSpecParam:
/// @parent_instance: private #GParamSpec portion
///
/// A #GParamSpec derived structure that contains the meta data for %G_TYPE_PARAM
/// properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecParam {
    pub parent_instance: GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecParam() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecParam>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpecParam))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecParam>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecParam))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecParam>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecParam),
            "::",
            stringify!(parent_instance)
        )
    );
}
/// GParamSpecBoxed:
/// @parent_instance: private #GParamSpec portion
///
/// A #GParamSpec derived structure that contains the meta data for boxed properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecBoxed {
    pub parent_instance: GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecBoxed() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecBoxed>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpecBoxed))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecBoxed>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecBoxed))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecBoxed>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecBoxed),
            "::",
            stringify!(parent_instance)
        )
    );
}
/// GParamSpecPointer:
/// @parent_instance: private #GParamSpec portion
///
/// A #GParamSpec derived structure that contains the meta data for pointer properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecPointer {
    pub parent_instance: GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecPointer() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecPointer>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpecPointer))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecPointer>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecPointer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecPointer>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecPointer),
            "::",
            stringify!(parent_instance)
        )
    );
}
/// GParamSpecValueArray:
/// @parent_instance: private #GParamSpec portion
/// @element_spec: a #GParamSpec describing the elements contained in arrays of this property, may be %NULL
/// @fixed_n_elements: if greater than 0, arrays of this property will always have this many elements
///
/// A #GParamSpec derived structure that contains the meta data for #GValueArray properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecValueArray {
    pub parent_instance: GParamSpec,
    pub element_spec: *mut GParamSpec,
    pub fixed_n_elements: guint,
}
#[test]
fn bindgen_test_layout__GParamSpecValueArray() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecValueArray>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecValueArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecValueArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecValueArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecValueArray>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecValueArray),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecValueArray>())).element_spec as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecValueArray),
            "::",
            stringify!(element_spec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecValueArray>())).fixed_n_elements as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecValueArray),
            "::",
            stringify!(fixed_n_elements)
        )
    );
}
/// GParamSpecObject:
/// @parent_instance: private #GParamSpec portion
///
/// A #GParamSpec derived structure that contains the meta data for object properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecObject {
    pub parent_instance: GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecObject() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecObject>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpecObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecObject))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecObject>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecObject),
            "::",
            stringify!(parent_instance)
        )
    );
}
/// GParamSpecOverride:
///
/// This is a type of #GParamSpec type that simply redirects operations to
/// another paramspec.  All operations other than getting or
/// setting the value are redirected, including accessing the nick and
/// blurb, validating a value, and so forth. See
/// g_param_spec_get_redirect_target() for retrieving the overidden
/// property. #GParamSpecOverride is used in implementing
/// g_object_class_override_property(), and will not be directly useful
/// unless you are implementing a new base type similar to GObject.
///
/// Since: 2.4
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecOverride {
    pub parent_instance: GParamSpec,
    pub overridden: *mut GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecOverride() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecOverride>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecOverride))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecOverride>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecOverride))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecOverride>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecOverride),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecOverride>())).overridden as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecOverride),
            "::",
            stringify!(overridden)
        )
    );
}
/// GParamSpecGType:
/// @parent_instance: private #GParamSpec portion
/// @is_a_type: a #GType whose subtypes can occur as values
///
/// A #GParamSpec derived structure that contains the meta data for #GType properties.
///
/// Since: 2.10
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecGType {
    pub parent_instance: GParamSpec,
    pub is_a_type: GType,
}
#[test]
fn bindgen_test_layout__GParamSpecGType() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecGType>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecGType))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecGType>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecGType))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecGType>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecGType),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecGType>())).is_a_type as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecGType),
            "::",
            stringify!(is_a_type)
        )
    );
}
/// GParamSpecVariant:
/// @parent_instance: private #GParamSpec portion
/// @type: a #GVariantType, or %NULL
/// @default_value: a #GVariant, or %NULL
///
/// A #GParamSpec derived structure that contains the meta data for #GVariant properties.
///
/// Since: 2.26
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecVariant {
    pub parent_instance: GParamSpec,
    pub type_: *mut GVariantType,
    pub default_value: *mut GVariant,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout__GParamSpecVariant() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecVariant>(),
        120usize,
        concat!("Size of: ", stringify!(_GParamSpecVariant))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecVariant>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecVariant))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecVariant>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecVariant),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecVariant>())).type_ as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecVariant),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecVariant>())).default_value as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecVariant),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecVariant>())).padding as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecVariant),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_param_spec_char(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gint8,
        maximum: gint8,
        default_value: gint8,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_uchar(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: guint8,
        maximum: guint8,
        default_value: guint8,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_boolean(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        default_value: gboolean,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_int(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gint,
        maximum: gint,
        default_value: gint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_uint(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: guint,
        maximum: guint,
        default_value: guint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_long(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: glong,
        maximum: glong,
        default_value: glong,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_ulong(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gulong,
        maximum: gulong,
        default_value: gulong,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_int64(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gint64,
        maximum: gint64,
        default_value: gint64,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_uint64(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: guint64,
        maximum: guint64,
        default_value: guint64,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_unichar(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        default_value: gunichar,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_enum(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        enum_type: GType,
        default_value: gint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_flags(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        flags_type: GType,
        default_value: guint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_float(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gfloat,
        maximum: gfloat,
        default_value: gfloat,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_double(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gdouble,
        maximum: gdouble,
        default_value: gdouble,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_string(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        default_value: *const gchar,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_param(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        param_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_boxed(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        boxed_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_pointer(name: *const gchar, nick: *const gchar, blurb: *const gchar, flags: GParamFlags) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_value_array(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        element_spec: *mut GParamSpec,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_object(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        object_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_override(name: *const gchar, overridden: *mut GParamSpec) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_gtype(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        is_a_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_variant(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        type_: *const GVariantType,
        default_value: *mut GVariant,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub static mut g_param_spec_types: *mut GType;
}
extern "C" {
    pub fn g_source_set_closure(source: *mut GSource, closure: *mut GClosure);
}
extern "C" {
    pub fn g_source_set_dummy_callback(source: *mut GSource);
}
pub type GTypeModule = _GTypeModule;
pub type GTypeModuleClass = _GTypeModuleClass;
/// GTypeModule:
/// @name: the name of the module
///
/// The members of the GTypeModule structure should not
/// be accessed directly, except for the @name field.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeModule {
    pub parent_instance: GObject,
    pub use_count: guint,
    pub type_infos: *mut GSList,
    pub interface_infos: *mut GSList,
    pub name: *mut gchar,
}
#[test]
fn bindgen_test_layout__GTypeModule() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeModule>(),
        56usize,
        concat!("Size of: ", stringify!(_GTypeModule))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeModule>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeModule))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModule>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModule>())).use_count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(use_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModule>())).type_infos as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(type_infos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModule>())).interface_infos as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(interface_infos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModule>())).name as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(name)
        )
    );
}
/// GTypeModuleClass:
/// @parent_class: the parent class
/// @load: loads the module and registers one or more types using
/// g_type_module_register_type().
/// @unload: unloads the module
///
/// In order to implement dynamic loading of types based on #GTypeModule,
/// the @load and @unload functions in #GTypeModuleClass must be implemented.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeModuleClass {
    pub parent_class: GObjectClass,
    pub load: ::std::option::Option<unsafe extern "C" fn(module: *mut GTypeModule) -> gboolean>,
    pub unload: ::std::option::Option<unsafe extern "C" fn(module: *mut GTypeModule)>,
    pub reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GTypeModuleClass() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeModuleClass>(),
        184usize,
        concat!("Size of: ", stringify!(_GTypeModuleClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeModuleClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeModuleClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModuleClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModuleClass>())).load as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModuleClass>())).unload as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(unload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModuleClass>())).reserved1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModuleClass>())).reserved2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModuleClass>())).reserved3 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModuleClass>())).reserved4 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(reserved4)
        )
    );
}
extern "C" {
    pub fn g_type_module_get_type() -> GType;
}
extern "C" {
    pub fn g_type_module_use(module: *mut GTypeModule) -> gboolean;
}
extern "C" {
    pub fn g_type_module_unuse(module: *mut GTypeModule);
}
extern "C" {
    pub fn g_type_module_set_name(module: *mut GTypeModule, name: *const gchar);
}
extern "C" {
    pub fn g_type_module_register_type(
        module: *mut GTypeModule,
        parent_type: GType,
        type_name: *const gchar,
        type_info: *const GTypeInfo,
        flags: GTypeFlags,
    ) -> GType;
}
extern "C" {
    pub fn g_type_module_add_interface(
        module: *mut GTypeModule,
        instance_type: GType,
        interface_type: GType,
        interface_info: *const GInterfaceInfo,
    );
}
extern "C" {
    pub fn g_type_module_register_enum(module: *mut GTypeModule, name: *const gchar, const_static_values: *const GEnumValue) -> GType;
}
extern "C" {
    pub fn g_type_module_register_flags(module: *mut GTypeModule, name: *const gchar, const_static_values: *const GFlagsValue) -> GType;
}
pub type GTypePluginClass = _GTypePluginClass;
/// GTypePluginUse:
/// @plugin: the #GTypePlugin whose use count should be increased
///
/// The type of the @use_plugin function of #GTypePluginClass, which gets called
/// to increase the use count of @plugin.
pub type GTypePluginUse = ::std::option::Option<unsafe extern "C" fn(plugin: *mut GTypePlugin)>;
/// GTypePluginUnuse:
/// @plugin: the #GTypePlugin whose use count should be decreased
///
/// The type of the @unuse_plugin function of #GTypePluginClass.
pub type GTypePluginUnuse = ::std::option::Option<unsafe extern "C" fn(plugin: *mut GTypePlugin)>;
/// GTypePluginCompleteTypeInfo:
/// @plugin: the #GTypePlugin
/// @g_type: the #GType whose info is completed
/// @info: the #GTypeInfo struct to fill in
/// @value_table: the #GTypeValueTable to fill in
///
/// The type of the @complete_type_info function of #GTypePluginClass.
pub type GTypePluginCompleteTypeInfo = ::std::option::Option<
    unsafe extern "C" fn(plugin: *mut GTypePlugin, g_type: GType, info: *mut GTypeInfo, value_table: *mut GTypeValueTable),
>;
/// GTypePluginCompleteInterfaceInfo:
/// @plugin: the #GTypePlugin
/// @instance_type: the #GType of an instantiable type to which the interface
/// is added
/// @interface_type: the #GType of the interface whose info is completed
/// @info: the #GInterfaceInfo to fill in
///
/// The type of the @complete_interface_info function of #GTypePluginClass.
pub type GTypePluginCompleteInterfaceInfo = ::std::option::Option<
    unsafe extern "C" fn(plugin: *mut GTypePlugin, instance_type: GType, interface_type: GType, info: *mut GInterfaceInfo),
>;
/// GTypePlugin:
///
/// The GTypePlugin typedef is used as a placeholder
/// for objects that implement the GTypePlugin interface.
/// /
/// /**
/// GTypePluginClass:
/// @use_plugin: Increases the use count of the plugin.
/// @unuse_plugin: Decreases the use count of the plugin.
/// @complete_type_info: Fills in the #GTypeInfo and
/// #GTypeValueTable structs for the type. The structs are initialized
/// with `memset(s, 0, sizeof (s))` before calling this function.
/// @complete_interface_info: Fills in missing parts of the #GInterfaceInfo
/// for the interface. The structs is initialized with
/// `memset(s, 0, sizeof (s))` before calling this function.
///
/// The #GTypePlugin interface is used by the type system in order to handle
/// the lifecycle of dynamically loaded types.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypePluginClass {
    pub base_iface: GTypeInterface,
    pub use_plugin: GTypePluginUse,
    pub unuse_plugin: GTypePluginUnuse,
    pub complete_type_info: GTypePluginCompleteTypeInfo,
    pub complete_interface_info: GTypePluginCompleteInterfaceInfo,
}
#[test]
fn bindgen_test_layout__GTypePluginClass() {
    assert_eq!(
        ::std::mem::size_of::<_GTypePluginClass>(),
        48usize,
        concat!("Size of: ", stringify!(_GTypePluginClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypePluginClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypePluginClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypePluginClass>())).base_iface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(base_iface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypePluginClass>())).use_plugin as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(use_plugin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypePluginClass>())).unuse_plugin as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(unuse_plugin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypePluginClass>())).complete_type_info as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(complete_type_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypePluginClass>())).complete_interface_info as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(complete_interface_info)
        )
    );
}
extern "C" {
    pub fn g_type_plugin_get_type() -> GType;
}
extern "C" {
    pub fn g_type_plugin_use(plugin: *mut GTypePlugin);
}
extern "C" {
    pub fn g_type_plugin_unuse(plugin: *mut GTypePlugin);
}
extern "C" {
    pub fn g_type_plugin_complete_type_info(
        plugin: *mut GTypePlugin,
        g_type: GType,
        info: *mut GTypeInfo,
        value_table: *mut GTypeValueTable,
    );
}
extern "C" {
    pub fn g_type_plugin_complete_interface_info(
        plugin: *mut GTypePlugin,
        instance_type: GType,
        interface_type: GType,
        info: *mut GInterfaceInfo,
    );
}
pub type GValueArray = _GValueArray;
/// GValueArray:
/// @n_values: number of values contained in the array
/// @values: array of values
///
/// A #GValueArray contains an array of #GValue elements.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GValueArray {
    pub n_values: guint,
    pub values: *mut GValue,
    pub n_prealloced: guint,
}
#[test]
fn bindgen_test_layout__GValueArray() {
    assert_eq!(
        ::std::mem::size_of::<_GValueArray>(),
        24usize,
        concat!("Size of: ", stringify!(_GValueArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GValueArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GValueArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValueArray>())).n_values as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValueArray),
            "::",
            stringify!(n_values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValueArray>())).values as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValueArray),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValueArray>())).n_prealloced as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValueArray),
            "::",
            stringify!(n_prealloced)
        )
    );
}
extern "C" {
    pub fn g_value_array_get_type() -> GType;
}
extern "C" {
    pub fn g_value_array_get_nth(value_array: *mut GValueArray, index_: guint) -> *mut GValue;
}
extern "C" {
    pub fn g_value_array_new(n_prealloced: guint) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_array_free(value_array: *mut GValueArray);
}
extern "C" {
    pub fn g_value_array_copy(value_array: *const GValueArray) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_array_prepend(value_array: *mut GValueArray, value: *const GValue) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_array_append(value_array: *mut GValueArray, value: *const GValue) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_array_insert(value_array: *mut GValueArray, index_: guint, value: *const GValue) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_array_remove(value_array: *mut GValueArray, index_: guint) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_array_sort(value_array: *mut GValueArray, compare_func: GCompareFunc) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_array_sort_with_data(
        value_array: *mut GValueArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_set_char(value: *mut GValue, v_char: gchar);
}
extern "C" {
    pub fn g_value_get_char(value: *const GValue) -> gchar;
}
extern "C" {
    pub fn g_value_set_schar(value: *mut GValue, v_char: gint8);
}
extern "C" {
    pub fn g_value_get_schar(value: *const GValue) -> gint8;
}
extern "C" {
    pub fn g_value_set_uchar(value: *mut GValue, v_uchar: guchar);
}
extern "C" {
    pub fn g_value_get_uchar(value: *const GValue) -> guchar;
}
extern "C" {
    pub fn g_value_set_boolean(value: *mut GValue, v_boolean: gboolean);
}
extern "C" {
    pub fn g_value_get_boolean(value: *const GValue) -> gboolean;
}
extern "C" {
    pub fn g_value_set_int(value: *mut GValue, v_int: gint);
}
extern "C" {
    pub fn g_value_get_int(value: *const GValue) -> gint;
}
extern "C" {
    pub fn g_value_set_uint(value: *mut GValue, v_uint: guint);
}
extern "C" {
    pub fn g_value_get_uint(value: *const GValue) -> guint;
}
extern "C" {
    pub fn g_value_set_long(value: *mut GValue, v_long: glong);
}
extern "C" {
    pub fn g_value_get_long(value: *const GValue) -> glong;
}
extern "C" {
    pub fn g_value_set_ulong(value: *mut GValue, v_ulong: gulong);
}
extern "C" {
    pub fn g_value_get_ulong(value: *const GValue) -> gulong;
}
extern "C" {
    pub fn g_value_set_int64(value: *mut GValue, v_int64: gint64);
}
extern "C" {
    pub fn g_value_get_int64(value: *const GValue) -> gint64;
}
extern "C" {
    pub fn g_value_set_uint64(value: *mut GValue, v_uint64: guint64);
}
extern "C" {
    pub fn g_value_get_uint64(value: *const GValue) -> guint64;
}
extern "C" {
    pub fn g_value_set_float(value: *mut GValue, v_float: gfloat);
}
extern "C" {
    pub fn g_value_get_float(value: *const GValue) -> gfloat;
}
extern "C" {
    pub fn g_value_set_double(value: *mut GValue, v_double: gdouble);
}
extern "C" {
    pub fn g_value_get_double(value: *const GValue) -> gdouble;
}
extern "C" {
    pub fn g_value_set_string(value: *mut GValue, v_string: *const gchar);
}
extern "C" {
    pub fn g_value_set_static_string(value: *mut GValue, v_string: *const gchar);
}
extern "C" {
    pub fn g_value_get_string(value: *const GValue) -> *const gchar;
}
extern "C" {
    pub fn g_value_dup_string(value: *const GValue) -> *mut gchar;
}
extern "C" {
    pub fn g_value_set_pointer(value: *mut GValue, v_pointer: gpointer);
}
extern "C" {
    pub fn g_value_get_pointer(value: *const GValue) -> gpointer;
}
extern "C" {
    pub fn g_gtype_get_type() -> GType;
}
extern "C" {
    pub fn g_value_set_gtype(value: *mut GValue, v_gtype: GType);
}
extern "C" {
    pub fn g_value_get_gtype(value: *const GValue) -> GType;
}
extern "C" {
    pub fn g_value_set_variant(value: *mut GValue, variant: *mut GVariant);
}
extern "C" {
    pub fn g_value_take_variant(value: *mut GValue, variant: *mut GVariant);
}
extern "C" {
    pub fn g_value_get_variant(value: *const GValue) -> *mut GVariant;
}
extern "C" {
    pub fn g_value_dup_variant(value: *const GValue) -> *mut GVariant;
}
extern "C" {
    pub fn g_pointer_type_register_static(name: *const gchar) -> GType;
}
extern "C" {
    pub fn g_strdup_value_contents(value: *const GValue) -> *mut gchar;
}
extern "C" {
    pub fn g_value_take_string(value: *mut GValue, v_string: *mut gchar);
}
extern "C" {
    pub fn g_value_set_string_take_ownership(value: *mut GValue, v_string: *mut gchar);
}
/// gchararray:
///
/// A C representable type name for #G_TYPE_STRING.
pub type gchararray = *mut gchar;
pub type GObject_autoptr = *mut GObject;
pub type GInitiallyUnowned_autoptr = *mut GInitiallyUnowned;
pub type glibtop = _glibtop;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glibtop_machine {
    _unused: [u8; 0],
}
pub type glibtop_machine = _glibtop_machine;
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::std::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
pub const __codecvt_result___codecvt_ok: __codecvt_result = 0;
pub const __codecvt_result___codecvt_partial: __codecvt_result = 1;
pub const __codecvt_result___codecvt_error: __codecvt_result = 2;
pub const __codecvt_result___codecvt_noconv: __codecvt_result = 3;
pub type __codecvt_result = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void, __buf: *mut ::std::os::raw::c_char, __nbytes: usize) -> __ssize_t,
>;
pub type __io_write_fn = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void, __buf: *const ::std::os::raw::c_char, __n: usize) -> __ssize_t,
>;
pub type __io_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void, __pos: *mut __off64_t, __w: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
>;
pub type __io_close_fn = ::std::option::Option<unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(arg1: *mut _IO_FILE, arg2: *const ::std::os::raw::c_char, arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int, arg3: __ssize_t) -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void, arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(arg1: *mut _IO_FILE, arg2: __off64_t, arg3: ::std::os::raw::c_int, arg4: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t, arg3: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type fpos_t = _G_fpos_t;
extern "C" {
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::std::os::raw::c_char, __new: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const ::std::os::raw::c_char, __pfx: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const ::std::os::raw::c_char, __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(__filename: *const ::std::os::raw::c_char, __modes: *const ::std::os::raw::c_char, __stream: *mut FILE) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(__s: *mut ::std::os::raw::c_void, __len: usize, __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut ::std::os::raw::c_char, __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE, __format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut ::std::os::raw::c_char, __format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(__s: *mut FILE, __format: *const ::std::os::raw::c_char, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const ::std::os::raw::c_char, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(__fd: ::std::os::raw::c_int, __fmt: *const ::std::os::raw::c_char, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(__fd: ::std::os::raw::c_int, __fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE, __format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const ::std::os::raw::c_char, __format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(__s: *mut FILE, __format: *const ::std::os::raw::c_char, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(__s: *mut ::std::os::raw::c_char, __n: ::std::os::raw::c_int, __stream: *mut FILE) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(__lineptr: *mut *mut ::std::os::raw::c_char, __n: *mut usize, __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: usize, __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: usize, __n: usize, __s: *mut FILE) -> usize;
}
extern "C" {
    pub fn fread_unlocked(__ptr: *mut ::std::os::raw::c_void, __size: usize, __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(__ptr: *const ::std::os::raw::c_void, __size: usize, __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: ::std::os::raw::c_long, __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(__command: *const ::std::os::raw::c_char, __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub __wait_terminated: wait__bindgen_ty_1,
    pub __wait_stopped: wait__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn __w_termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set___w_termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn __w_coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___w_coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __w_retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___w_retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __w_termsig: ::std::os::raw::c_uint,
        __w_coredump: ::std::os::raw::c_uint,
        __w_retcode: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let __w_termsig: u32 = unsafe { ::std::mem::transmute(__w_termsig) };
            __w_termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let __w_coredump: u32 = unsafe { ::std::mem::transmute(__w_coredump) };
            __w_coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let __w_retcode: u32 = unsafe { ::std::mem::transmute(__w_retcode) };
            __w_retcode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn __w_stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___w_stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __w_stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___w_stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __w_stopval: ::std::os::raw::c_uint,
        __w_stopsig: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let __w_stopval: u32 = unsafe { ::std::mem::transmute(__w_stopval) };
            __w_stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let __w_stopsig: u32 = unsafe { ::std::mem::transmute(__w_stopsig) };
            __w_stopsig as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(w_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).__wait_terminated as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(__wait_terminated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).__wait_stopped as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(__wait_stopped)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __WAIT_STATUS {
    pub __uptr: *mut wait,
    pub __iptr: *mut ::std::os::raw::c_int,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout___WAIT_STATUS() {
    assert_eq!(
        ::std::mem::size_of::<__WAIT_STATUS>(),
        8usize,
        concat!("Size of: ", stringify!(__WAIT_STATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<__WAIT_STATUS>(),
        8usize,
        concat!("Alignment of ", stringify!(__WAIT_STATUS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__WAIT_STATUS>())).__uptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__WAIT_STATUS),
            "::",
            stringify!(__uptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__WAIT_STATUS>())).__iptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__WAIT_STATUS),
            "::",
            stringify!(__iptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const ::std::os::raw::c_char, __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const ::std::os::raw::c_char, __endptr: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const ::std::os::raw::c_char, __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: ::std::os::raw::c_uint, __buf: *mut random_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut ::std::os::raw::c_char, __buf: *mut random_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(__xsubi: *mut ::std::os::raw::c_ushort, __buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data, __result: *mut ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data, __result: *mut ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: ::std::os::raw::c_long, __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut ::std::os::raw::c_ushort, __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut ::std::os::raw::c_ushort, __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(__memptr: *mut *mut ::std::os::raw::c_void, __alignment: usize, __size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<unsafe extern "C" fn(__status: ::std::os::raw::c_int, __arg: *mut ::std::os::raw::c_void)>,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut ::std::os::raw::c_char, __suffixlen: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(__name: *const ::std::os::raw::c_char, __resolved: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void, arg2: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nmemb: usize, __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: ::std::os::raw::c_longlong, __denom: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: ::std::os::raw::c_int, __buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(__value: f64, __ndigit: ::std::os::raw::c_int, __buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *const ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(__dest: *mut ::std::os::raw::c_void, __src: *const ::std::os::raw::c_void, __n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(__dest: *mut ::std::os::raw::c_void, __src: *const ::std::os::raw::c_void, __n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(__s: *mut ::std::os::raw::c_void, __c: ::std::os::raw::c_int, __n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(__s1: *const ::std::os::raw::c_void, __s2: *const ::std::os::raw::c_void, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(__s: *const ::std::os::raw::c_void, __c: ::std::os::raw::c_int, __n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut ::std::os::raw::c_char, __src: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(__dest: *mut ::std::os::raw::c_char, __src: *const ::std::os::raw::c_char, __n: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut ::std::os::raw::c_char, __src: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(__dest: *mut ::std::os::raw::c_char, __src: *const ::std::os::raw::c_char, __n: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const ::std::os::raw::c_char, __s2: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(__s1: *const ::std::os::raw::c_char, __s2: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const ::std::os::raw::c_char, __s2: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(__dest: *mut ::std::os::raw::c_char, __src: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn strcoll_l(__s1: *const ::std::os::raw::c_char, __s2: *const ::std::os::raw::c_char, __l: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(__dest: *mut ::std::os::raw::c_char, __src: *const ::std::os::raw::c_char, __n: usize, __l: __locale_t) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(__string: *const ::std::os::raw::c_char, __n: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(__s: *const ::std::os::raw::c_char, __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const ::std::os::raw::c_char, __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const ::std::os::raw::c_char, __reject: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn strspn(__s: *const ::std::os::raw::c_char, __accept: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn strpbrk(__s: *const ::std::os::raw::c_char, __accept: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(__haystack: *const ::std::os::raw::c_char, __needle: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut ::std::os::raw::c_char, __delim: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(__errnum: ::std::os::raw::c_int, __buf: *mut ::std::os::raw::c_char, __buflen: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: ::std::os::raw::c_int, __l: __locale_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcopy(__src: *const ::std::os::raw::c_void, __dest: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcmp(__s1: *const ::std::os::raw::c_void, __s2: *const ::std::os::raw::c_void, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn index(__s: *const ::std::os::raw::c_char, __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(__s: *const ::std::os::raw::c_char, __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const ::std::os::raw::c_char, __s2: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(__s1: *const ::std::os::raw::c_char, __s2: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsep(__stringp: *mut *mut ::std::os::raw::c_char, __delim: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(__dest: *mut ::std::os::raw::c_char, __src: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut ::std::os::raw::c_char, __src: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(__dest: *mut ::std::os::raw::c_char, __src: *const ::std::os::raw::c_char, __n: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(__dest: *mut ::std::os::raw::c_char, __src: *const ::std::os::raw::c_char, __n: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
pub type _GStaticAssertCompileTimeAssertion_1 = [::std::os::raw::c_char; 1usize];
pub type glibtop_sysdeps = _glibtop_sysdeps;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glibtop_sysdeps {
    pub flags: guint64,
    pub features: guint64,
    pub cpu: guint64,
    pub mem: guint64,
    pub swap: guint64,
    pub uptime: guint64,
    pub loadavg: guint64,
    pub shm_limits: guint64,
    pub msg_limits: guint64,
    pub sem_limits: guint64,
    pub proclist: guint64,
    pub proc_state: guint64,
    pub proc_uid: guint64,
    pub proc_mem: guint64,
    pub proc_time: guint64,
    pub proc_signal: guint64,
    pub proc_kernel: guint64,
    pub proc_segment: guint64,
    pub proc_args: guint64,
    pub proc_map: guint64,
    pub proc_open_files: guint64,
    pub mountlist: guint64,
    pub fsusage: guint64,
    pub netlist: guint64,
    pub netload: guint64,
    pub ppp: guint64,
    pub proc_wd: guint64,
    pub proc_affinity: guint64,
}
#[test]
fn bindgen_test_layout__glibtop_sysdeps() {
    assert_eq!(
        ::std::mem::size_of::<_glibtop_sysdeps>(),
        224usize,
        concat!("Size of: ", stringify!(_glibtop_sysdeps))
    );
    assert_eq!(
        ::std::mem::align_of::<_glibtop_sysdeps>(),
        8usize,
        concat!("Alignment of ", stringify!(_glibtop_sysdeps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).features as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(features)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).cpu as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).mem as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).swap as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(swap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).uptime as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(uptime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).loadavg as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(loadavg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).shm_limits as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(shm_limits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).msg_limits as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(msg_limits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).sem_limits as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(sem_limits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).proclist as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(proclist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).proc_state as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(proc_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).proc_uid as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(proc_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).proc_mem as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(proc_mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).proc_time as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(proc_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).proc_signal as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(proc_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).proc_kernel as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(proc_kernel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).proc_segment as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(proc_segment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).proc_args as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(proc_args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).proc_map as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(proc_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).proc_open_files as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(proc_open_files)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).mountlist as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(mountlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).fsusage as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(fsusage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).netlist as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(netlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).netload as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(netload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).ppp as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(ppp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).proc_wd as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(proc_wd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_sysdeps>())).proc_affinity as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_sysdeps),
            "::",
            stringify!(proc_affinity)
        )
    );
}
extern "C" {
    pub fn glibtop_get_sysdeps(buf: *mut glibtop_sysdeps);
}
extern "C" {
    pub fn glibtop_get_sysdeps_r(server: *mut glibtop, buf: *mut glibtop_sysdeps);
}
extern "C" {
    pub fn glibtop_close();
}
extern "C" {
    pub fn glibtop_close_r(server: *mut glibtop);
}
extern "C" {
    pub fn glibtop_close_s(server: *mut glibtop);
}
extern "C" {
    pub fn glibtop_close_p(server: *mut glibtop);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glibtop {
    pub flags: ::std::os::raw::c_uint,
    pub method: ::std::os::raw::c_uint,
    pub error_method: ::std::os::raw::c_uint,
    pub input: [::std::os::raw::c_int; 2usize],
    pub output: [::std::os::raw::c_int; 2usize],
    pub socket: ::std::os::raw::c_int,
    pub ncpu: ::std::os::raw::c_int,
    pub real_ncpu: ::std::os::raw::c_int,
    pub os_version_code: ::std::os::raw::c_ulong,
    pub name: *const ::std::os::raw::c_char,
    pub server_command: *const ::std::os::raw::c_char,
    pub server_host: *const ::std::os::raw::c_char,
    pub server_user: *const ::std::os::raw::c_char,
    pub server_rsh: *const ::std::os::raw::c_char,
    pub features: ::std::os::raw::c_ulong,
    pub server_port: ::std::os::raw::c_ulong,
    pub sysdeps: glibtop_sysdeps,
    pub required: glibtop_sysdeps,
    pub pid: pid_t,
    pub uid: uid_t,
    pub euid: uid_t,
    pub gid: gid_t,
    pub egid: gid_t,
    pub machine: *mut glibtop_machine,
}
#[test]
fn bindgen_test_layout__glibtop() {
    assert_eq!(
        ::std::mem::size_of::<_glibtop>(),
        584usize,
        concat!("Size of: ", stringify!(_glibtop))
    );
    assert_eq!(
        ::std::mem::align_of::<_glibtop>(),
        8usize,
        concat!("Alignment of ", stringify!(_glibtop))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).method as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).error_method as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(error_method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).input as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).output as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).socket as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(socket)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).ncpu as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(ncpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).real_ncpu as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(real_ncpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).os_version_code as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(os_version_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).name as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).server_command as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(server_command)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).server_host as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(server_host)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).server_user as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(server_user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).server_rsh as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(server_rsh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).features as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(features)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).server_port as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(server_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).sysdeps as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(sysdeps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).required as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(required)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).pid as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).uid as *const _ as usize },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).euid as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(euid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).gid as *const _ as usize },
        564usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).egid as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(egid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop>())).machine as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop),
            "::",
            stringify!(machine)
        )
    );
}
extern "C" {
    pub static mut glibtop_global_server: *mut glibtop;
}
extern "C" {
    pub static mut glibtop_server_features: ::std::os::raw::c_ulong;
}
extern "C" {

    /// glibtop_init:
    ///
    /// Returns: (transfer none):
    pub fn glibtop_init() -> *mut glibtop;
}
extern "C" {

    /// glibtop_init_r:
    /// @server_ptr: (out):
    /// @features:
    /// @flags:
    ///
    /// Returns: (transfer none):
    pub fn glibtop_init_r(server_ptr: *mut *mut glibtop, features: ::std::os::raw::c_ulong, flags: ::std::os::raw::c_uint) -> *mut glibtop;
}
extern "C" {

    /// glibtop_init_s:
    /// @server_ptr: (out):
    /// @features:
    /// @flags:
    ///
    /// Returns: (transfer none):
    pub fn glibtop_init_s(server_ptr: *mut *mut glibtop, features: ::std::os::raw::c_ulong, flags: ::std::os::raw::c_uint) -> *mut glibtop;
}
extern "C" {
    pub fn glibtop_get_type() -> GType;
}
pub type glibtop_cpu = _glibtop_cpu;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _glibtop_cpu {
    pub flags: guint64,
    pub total: guint64,
    pub user: guint64,
    pub nice: guint64,
    pub sys: guint64,
    pub idle: guint64,
    pub iowait: guint64,
    pub irq: guint64,
    pub softirq: guint64,
    pub frequency: guint64,
    pub xcpu_total: [guint64; 1024usize],
    pub xcpu_user: [guint64; 1024usize],
    pub xcpu_nice: [guint64; 1024usize],
    pub xcpu_sys: [guint64; 1024usize],
    pub xcpu_idle: [guint64; 1024usize],
    pub xcpu_iowait: [guint64; 1024usize],
    pub xcpu_irq: [guint64; 1024usize],
    pub xcpu_softirq: [guint64; 1024usize],
    pub xcpu_flags: guint64,
}
#[test]
fn bindgen_test_layout__glibtop_cpu() {
    assert_eq!(
        ::std::mem::size_of::<_glibtop_cpu>(),
        65624usize,
        concat!("Size of: ", stringify!(_glibtop_cpu))
    );
    assert_eq!(
        ::std::mem::align_of::<_glibtop_cpu>(),
        8usize,
        concat!("Alignment of ", stringify!(_glibtop_cpu))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_cpu>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_cpu),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_cpu>())).total as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_cpu),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_cpu>())).user as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_cpu),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_cpu>())).nice as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_cpu),
            "::",
            stringify!(nice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_cpu>())).sys as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_cpu),
            "::",
            stringify!(sys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_cpu>())).idle as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_cpu),
            "::",
            stringify!(idle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_cpu>())).iowait as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_cpu),
            "::",
            stringify!(iowait)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_cpu>())).irq as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_cpu),
            "::",
            stringify!(irq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_cpu>())).softirq as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_cpu),
            "::",
            stringify!(softirq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_cpu>())).frequency as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_cpu),
            "::",
            stringify!(frequency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_cpu>())).xcpu_total as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_cpu),
            "::",
            stringify!(xcpu_total)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_cpu>())).xcpu_user as *const _ as usize },
        8272usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_cpu),
            "::",
            stringify!(xcpu_user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_cpu>())).xcpu_nice as *const _ as usize },
        16464usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_cpu),
            "::",
            stringify!(xcpu_nice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_cpu>())).xcpu_sys as *const _ as usize },
        24656usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_cpu),
            "::",
            stringify!(xcpu_sys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_cpu>())).xcpu_idle as *const _ as usize },
        32848usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_cpu),
            "::",
            stringify!(xcpu_idle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_cpu>())).xcpu_iowait as *const _ as usize },
        41040usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_cpu),
            "::",
            stringify!(xcpu_iowait)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_cpu>())).xcpu_irq as *const _ as usize },
        49232usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_cpu),
            "::",
            stringify!(xcpu_irq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_cpu>())).xcpu_softirq as *const _ as usize },
        57424usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_cpu),
            "::",
            stringify!(xcpu_softirq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_cpu>())).xcpu_flags as *const _ as usize },
        65616usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_cpu),
            "::",
            stringify!(xcpu_flags)
        )
    );
}
extern "C" {
    pub fn glibtop_get_cpu(buf: *mut glibtop_cpu);
}
extern "C" {
    pub fn glibtop_get_cpu_l(server: *mut glibtop, buf: *mut glibtop_cpu);
}
extern "C" {
    pub fn _glibtop_init_cpu_s(server: *mut glibtop);
}
extern "C" {
    pub fn glibtop_get_cpu_s(server: *mut glibtop, buf: *mut glibtop_cpu);
}
pub type glibtop_mem = _glibtop_mem;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glibtop_mem {
    pub flags: guint64,
    pub total: guint64,
    pub used: guint64,
    pub free: guint64,
    pub shared: guint64,
    pub buffer: guint64,
    pub cached: guint64,
    pub user: guint64,
    pub locked: guint64,
}
#[test]
fn bindgen_test_layout__glibtop_mem() {
    assert_eq!(
        ::std::mem::size_of::<_glibtop_mem>(),
        72usize,
        concat!("Size of: ", stringify!(_glibtop_mem))
    );
    assert_eq!(
        ::std::mem::align_of::<_glibtop_mem>(),
        8usize,
        concat!("Alignment of ", stringify!(_glibtop_mem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_mem>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_mem),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_mem>())).total as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_mem),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_mem>())).used as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_mem),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_mem>())).free as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_mem),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_mem>())).shared as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_mem),
            "::",
            stringify!(shared)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_mem>())).buffer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_mem),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_mem>())).cached as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_mem),
            "::",
            stringify!(cached)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_mem>())).user as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_mem),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glibtop_mem>())).locked as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_glibtop_mem),
            "::",
            stringify!(locked)
        )
    );
}
extern "C" {
    pub fn glibtop_get_mem(buf: *mut glibtop_mem);
}
extern "C" {
    pub fn glibtop_get_mem_l(server: *mut glibtop, buf: *mut glibtop_mem);
}
extern "C" {
    pub fn _glibtop_init_mem_s(server: *mut glibtop);
}
extern "C" {
    pub fn glibtop_get_mem_s(server: *mut glibtop, buf: *mut glibtop_mem);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
